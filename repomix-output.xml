This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  deployment-examples/
    server/
      .ebextensions/
        nodecommand.config
        securelistener.config
      app.yaml
      Dockerfile
      heroku.yml
  workflows/
    client-ci.yml
    server-ci.yml
culturalai/
  android/
    app/
      src/
        debug/
          AndroidManifest.xml
        main/
          java/
            com/
              lawthewall/
                culturalai/
                  MainActivity.kt
                  MainApplication.kt
          res/
            drawable/
              ic_launcher_background.xml
              rn_edit_text_material.xml
            mipmap-anydpi-v26/
              ic_launcher_round.xml
              ic_launcher.xml
            values/
              colors.xml
              strings.xml
              styles.xml
            values-night/
              colors.xml
          AndroidManifest.xml
      build.gradle
      proguard-rules.pro
    gradle/
      wrapper/
        gradle-wrapper.properties
    .gitignore
    build.gradle
    ext.gradle
    gradle.properties
    gradlew
    gradlew.bat
    settings.gradle
  src/
    types/
      custom.d.ts
      react-native.d.ts
      react.d.ts
  .gitignore
  app.json
  App.tsx
  babel.config.js
  index.js
  index.ts
  metro.config.js
  package.json
  simple-app.js
  tsconfig.json
scripts/
  build-mobile-demo.sh
  deploy-server.sh
  README.md
server/
  certs/
    .gitkeep
    server.cert
    server.csr
  config/
    production.js
  docs/
    ckb_versioning_plan.md
    cloud-deployment.md
  logs/
    .gitkeep
  middleware/
    clientErrorCollector.js
    errorHandler.js
    requestId.js
    requestLogger.js
  routes/
    admin.js
    analysis.js
    cultures.js
    idioms.js
    index.js
    norms.js
  scripts/
    deploy-cloud.sh
    setup-cloud-database.js
  test/
    auth.test.js
    setup.js
  utils/
    database.js
    dataRetention.js
    encryption.js
    logger.js
    openai.js
    validation.js
  .deployment
  .gitignore
  Dockerfile
  index.js
  package.json
  Procfile
src/
  assets/
    legal/
      privacy-policy.tsx
      terms-of-service.tsx
  components/
    ConsentModal.tsx
    DisclaimerBanner.tsx
    FeedbackButton.tsx
  navigation/
    AuthStack.tsx
    CulturalBriefingStack.tsx
    IdiomsStack.tsx
    MainTab.tsx
    RootNavigator.tsx
  screens/
    CulturalBriefingDetailScreen.tsx
    CultureSelectionScreen.tsx
    HomeScreen.tsx
    IdiomDetailScreen.tsx
    IdiomSearchScreen.tsx
    ImageAnalysisPlaceholderScreen.tsx
    LoginScreen.tsx
    SettingsScreen.tsx
    SignUpScreen.tsx
    TextAnalysisScreen.tsx
  services/
    analysisService.ts
    authContext.tsx
    authService.ts
    cultureService.ts
    feedbackService.ts
    privacyService.ts
  types/
    culture.ts
    custom.d.ts
    navigation.ts
    react-native.d.ts
    react.d.ts
    user.ts
  utils/
    config.ts
    consentManager.ts
    constants.ts
    database.ts
    secureStorage.ts
    testConnection.ts
  index.d.ts
.cursor-tasks.md
.gitignore
App.tsx
create_database.sql
global.d.ts
index.html
index.js
LICENSE
package.json
README.md
simple-app.js
test-db.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/deployment-examples/server/.ebextensions/nodecommand.config">
option_settings:
  aws:elasticbeanstalk:container:nodejs:
    NodeCommand: "npm start"
    NodeVersion: 18
  aws:elasticbeanstalk:application:environment:
    NODE_ENV: production
</file>

<file path=".github/deployment-examples/server/.ebextensions/securelistener.config">
option_settings:
  aws:elb:listener:443:
    ListenerProtocol: HTTPS
    SSLCertificateId: arn:aws:acm:us-east-1:XXXXXXXXXXXX:certificate/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    InstancePort: 80
    InstanceProtocol: HTTP
</file>

<file path=".github/deployment-examples/server/app.yaml">
# Example Google App Engine Deployment Configuration
runtime: nodejs18

env_variables:
  NODE_ENV: "production"
  PORT: "8080"
  
handlers:
- url: /.*
  script: auto
  secure: always

automatic_scaling:
  min_instances: 1
  max_instances: 5
  min_idle_instances: 1
  max_idle_instances: 1
  min_pending_latency: 30ms
  max_pending_latency: automatic
</file>

<file path=".github/deployment-examples/server/Dockerfile">
FROM node:18-alpine

WORKDIR /usr/src/app

# Copy package files and install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy app source
COPY . .

# Expose the port the app runs on
EXPOSE 8080

# Start the app
CMD [ "npm", "start" ]
</file>

<file path=".github/deployment-examples/server/heroku.yml">
build:
  docker:
    web: Dockerfile

run:
  web: npm start
</file>

<file path=".github/workflows/client-ci.yml">
name: Client CI/CD

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'App.tsx'
      - 'package.json'
  pull_request:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'App.tsx'
      - 'package.json'
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install Expo CLI
        run: npm install -g expo-cli
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linting
        run: |
          npm list eslint || npm install eslint --save-dev
          npx eslint . --ext .js,.jsx,.ts,.tsx || true # Don't fail the build for linting errors in MVP
      
      - name: Run TypeScript type checking
        run: |
          npm list typescript || npm install typescript --save-dev
          npx tsc --noEmit
      
      # For Android build (requires setup of credentials in secrets)
      - name: Build Android app (Demo)
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "For MVP demo: Would run 'expo build:android -t apk' here"
          echo "This requires Expo credentials setup prior to running"
          # expo build:android -t apk
      
      # For iOS build (requires setup of credentials in secrets)
      - name: Build iOS app (Demo)
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "For MVP demo: Would run 'expo build:ios -t simulator' here"
          echo "This requires Apple Developer credentials setup prior to running"
          # expo build:ios -t simulator
      
      # For web build (useful for demo purposes)
      - name: Build web app
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          expo build:web
      
      - name: Upload web build artifact
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v3
        with:
          name: web-build
          path: web-build
          retention-days: 5
</file>

<file path=".github/workflows/server-ci.yml">
name: Server CI/CD

on:
  push:
    branches: [ main ]
    paths:
      - 'server/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'server/**'
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: server/package-lock.json
      
      - name: Install dependencies
        run: |
          cd server
          npm ci
      
      - name: Run linting
        run: |
          cd server
          npm list eslint || npm install eslint --save-dev
          npx eslint . --ext .js || true # Don't fail the build for linting errors in MVP
      
      - name: Run tests
        run: |
          cd server
          # Update the test script in package.json before enabling this
          # npm test
          echo "Tests would run here in the future"
      
      # For manual/demo deployment, we'll just create a deployment artifact
      - name: Create deployment package
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          cd server
          mkdir -p ../deployment
          cp -r . ../deployment/server
          cd ..
          tar -czf server-deployment.tar.gz deployment/server
      
      - name: Upload deployment artifact
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v3
        with:
          name: server-deployment
          path: server-deployment.tar.gz
          retention-days: 5
</file>

<file path="culturalai/android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>

    <application android:usesCleartextTraffic="true" tools:targetApi="28" tools:ignore="GoogleAppIndexingWarning" tools:replace="android:usesCleartextTraffic" />
</manifest>
</file>

<file path="culturalai/android/app/src/main/java/com/lawthewall/culturalai/MainActivity.kt">
package com.lawthewall.culturalai

import android.os.Build
import android.os.Bundle

import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate

import expo.modules.ReactActivityDelegateWrapper

class MainActivity : ReactActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    // Set the theme to AppTheme BEFORE onCreate to support
    // coloring the background, status bar, and navigation bar.
    // This is required for expo-splash-screen.
    setTheme(R.style.AppTheme);
    super.onCreate(null)
  }

  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  override fun getMainComponentName(): String = "main"

  /**
   * Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]
   * which allows you to enable New Architecture with a single boolean flags [fabricEnabled]
   */
  override fun createReactActivityDelegate(): ReactActivityDelegate {
    return ReactActivityDelegateWrapper(
          this,
          BuildConfig.IS_NEW_ARCHITECTURE_ENABLED,
          object : DefaultReactActivityDelegate(
              this,
              mainComponentName,
              fabricEnabled
          ){})
  }

  /**
    * Align the back button behavior with Android S
    * where moving root activities to background instead of finishing activities.
    * @see <a href="https://developer.android.com/reference/android/app/Activity#onBackPressed()">onBackPressed</a>
    */
  override fun invokeDefaultOnBackPressed() {
      if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {
          if (!moveTaskToBack(false)) {
              // For non-root activities, use the default implementation to finish them.
              super.invokeDefaultOnBackPressed()
          }
          return
      }

      // Use the default back button implementation on Android S
      // because it's doing more than [Activity.moveTaskToBack] in fact.
      super.invokeDefaultOnBackPressed()
  }
}
</file>

<file path="culturalai/android/app/src/main/java/com/lawthewall/culturalai/MainApplication.kt">
package com.lawthewall.culturalai

import android.app.Application
import android.content.res.Configuration

import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.ReactHost
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader

import expo.modules.ApplicationLifecycleDispatcher
import expo.modules.ReactNativeHostWrapper

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost = ReactNativeHostWrapper(
        this,
        object : DefaultReactNativeHost(this) {
          override fun getPackages(): List<ReactPackage> {
            val packages = PackageList(this).packages
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // packages.add(MyReactNativePackage())
            return packages
          }

          override fun getJSMainModuleName(): String = ".expo/.virtual-metro-entry"

          override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

          override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
          override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED
      }
  )

  override val reactHost: ReactHost
    get() = ReactNativeHostWrapper.createReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
    ApplicationLifecycleDispatcher.onApplicationCreate(this)
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    ApplicationLifecycleDispatcher.onConfigurationChanged(this, newConfig)
  }
}
</file>

<file path="culturalai/android/app/src/main/res/drawable/ic_launcher_background.xml">
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:drawable="@color/splashscreen_background"/>
  <item>
    <bitmap android:gravity="center" android:src="@drawable/splashscreen_logo"/>
  </item>
</layer-list>
</file>

<file path="culturalai/android/app/src/main/res/drawable/rn_edit_text_material.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2014 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->
<inset xmlns:android="http://schemas.android.com/apk/res/android"
       android:insetLeft="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetRight="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetTop="@dimen/abc_edit_text_inset_top_material"
       android:insetBottom="@dimen/abc_edit_text_inset_bottom_material"
       >

    <selector>
        <!--
          This file is a copy of abc_edit_text_material (https://bit.ly/3k8fX7I).
          The item below with state_pressed="false" and state_focused="false" causes a NullPointerException.
          NullPointerException:tempt to invoke virtual method 'android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable(android.content.res.Resources)'

          <item android:state_pressed="false" android:state_focused="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>

          For more info, see https://bit.ly/3CdLStv (react-native/pull/29452) and https://bit.ly/3nxOMoR.
        -->
        <item android:state_enabled="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>
        <item android:drawable="@drawable/abc_textfield_activated_mtrl_alpha"/>
    </selector>

</inset>
</file>

<file path="culturalai/android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/iconBackground"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="culturalai/android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/iconBackground"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="culturalai/android/app/src/main/res/values/colors.xml">
<resources>
  <color name="splashscreen_background">#ffffff</color>
  <color name="iconBackground">#ffffff</color>
  <color name="colorPrimary">#023c69</color>
  <color name="colorPrimaryDark">#ffffff</color>
</resources>
</file>

<file path="culturalai/android/app/src/main/res/values/strings.xml">
<resources>
  <string name="app_name">culturalai</string>
  <string name="expo_splash_screen_resize_mode" translatable="false">contain</string>
  <string name="expo_splash_screen_status_bar_translucent" translatable="false">false</string>
</resources>
</file>

<file path="culturalai/android/app/src/main/res/values/styles.xml">
<resources xmlns:tools="http://schemas.android.com/tools">
  <style name="AppTheme" parent="Theme.EdgeToEdge">
    <item name="android:editTextBackground">@drawable/rn_edit_text_material</item>
    <item name="colorPrimary">@color/colorPrimary</item>
    <item name="android:statusBarColor">#ffffff</item>
  </style>
  <style name="Theme.App.SplashScreen" parent="AppTheme">
    <item name="android:windowBackground">@drawable/ic_launcher_background</item>
  </style>
</resources>
</file>

<file path="culturalai/android/app/src/main/res/values-night/colors.xml">
<resources/>
</file>

<file path="culturalai/android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
  <uses-permission android:name="android.permission.INTERNET"/>
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
  <uses-permission android:name="android.permission.VIBRATE"/>
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
  <queries>
    <intent>
      <action android:name="android.intent.action.VIEW"/>
      <category android:name="android.intent.category.BROWSABLE"/>
      <data android:scheme="https"/>
    </intent>
  </queries>
  <application android:name=".MainApplication" android:label="@string/app_name" android:icon="@mipmap/ic_launcher" android:roundIcon="@mipmap/ic_launcher_round" android:allowBackup="true" android:theme="@style/AppTheme" android:supportsRtl="true">
    <meta-data android:name="expo.modules.updates.ENABLED" android:value="false"/>
    <meta-data android:name="expo.modules.updates.EXPO_UPDATES_CHECK_ON_LAUNCH" android:value="ALWAYS"/>
    <meta-data android:name="expo.modules.updates.EXPO_UPDATES_LAUNCH_WAIT_MS" android:value="0"/>
    <activity android:name=".MainActivity" android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|uiMode" android:launchMode="singleTask" android:windowSoftInputMode="adjustResize" android:theme="@style/Theme.App.SplashScreen" android:exported="true" android:screenOrientation="portrait">
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>
    </activity>
  </application>
</manifest>
</file>

<file path="culturalai/android/app/build.gradle">
apply plugin: "com.android.application"
apply plugin: "org.jetbrains.kotlin.android"
apply plugin: "com.facebook.react"

def projectRoot = rootDir.getAbsoluteFile().getParentFile().getAbsolutePath()

/**
 * This is the configuration block to customize your React Native Android app.
 * By default you don't need to apply any configuration, just uncomment the lines you need.
 */
react {
    entryFile = file(["node", "-e", "require('expo/scripts/resolveAppEntry')", projectRoot, "android", "absolute"].execute(null, rootDir).text.trim())
    reactNativeDir = new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim()).getParentFile().getAbsoluteFile()
    hermesCommand = new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim()).getParentFile().getAbsolutePath() + "/sdks/hermesc/%OS-BIN%/hermesc"
    codegenDir = new File(["node", "--print", "require.resolve('@react-native/codegen/package.json', { paths: [require.resolve('react-native/package.json')] })"].execute(null, rootDir).text.trim()).getParentFile().getAbsoluteFile()

    enableBundleCompression = (findProperty('android.enableBundleCompression') ?: false).toBoolean()
    // Use Expo CLI to bundle the app, this ensures the Metro config
    // works correctly with Expo projects.
    cliFile = new File(["node", "--print", "require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })"].execute(null, rootDir).text.trim())
    bundleCommand = "export:embed"

    /* Folders */
     //   The root of your project, i.e. where "package.json" lives. Default is '../..'
    // root = file("../../")
    //   The folder where the react-native NPM package is. Default is ../../node_modules/react-native
    // reactNativeDir = file("../../node_modules/react-native")
    //   The folder where the react-native Codegen package is. Default is ../../node_modules/@react-native/codegen
    // codegenDir = file("../../node_modules/@react-native/codegen")

    /* Variants */
    //   The list of variants to that are debuggable. For those we're going to
    //   skip the bundling of the JS bundle and the assets. By default is just 'debug'.
    //   If you add flavors like lite, prod, etc. you'll have to list your debuggableVariants.
    // debuggableVariants = ["liteDebug", "prodDebug"]

    /* Bundling */
    //   A list containing the node command and its flags. Default is just 'node'.
    // nodeExecutableAndArgs = ["node"]

    //
    //   The path to the CLI configuration file. Default is empty.
    // bundleConfig = file(../rn-cli.config.js)
    //
    //   The name of the generated asset file containing your JS bundle
    // bundleAssetName = "MyApplication.android.bundle"
    //
    //   The entry file for bundle generation. Default is 'index.android.js' or 'index.js'
    // entryFile = file("../js/MyApplication.android.js")
    //
    //   A list of extra flags to pass to the 'bundle' commands.
    //   See https://github.com/react-native-community/cli/blob/main/docs/commands.md#bundle
    // extraPackagerArgs = []

    /* Hermes Commands */
    //   The hermes compiler command to run. By default it is 'hermesc'
    // hermesCommand = "$rootDir/my-custom-hermesc/bin/hermesc"
    //
    //   The list of flags to pass to the Hermes compiler. By default is "-O", "-output-source-map"
    // hermesFlags = ["-O", "-output-source-map"]

    /* Autolinking */
    autolinkLibrariesWithApp()
}

/**
 * Set this to true to Run Proguard on Release builds to minify the Java bytecode.
 */
def enableProguardInReleaseBuilds = (findProperty('android.enableProguardInReleaseBuilds') ?: false).toBoolean()

/**
 * The preferred build flavor of JavaScriptCore (JSC)
 *
 * For example, to use the international variant, you can use:
 * `def jscFlavor = 'org.webkit:android-jsc-intl:+'`
 *
 * The international variant includes ICU i18n library and necessary data
 * allowing to use e.g. `Date.toLocaleString` and `String.localeCompare` that
 * give correct results when using with locales other than en-US. Note that
 * this variant is about 6MiB larger per architecture than default.
 */
def jscFlavor = 'io.github.react-native-community:jsc-android:2026004.+'

android {
    ndkVersion rootProject.ext.ndkVersion

    buildToolsVersion rootProject.ext.buildToolsVersion
    compileSdk rootProject.ext.compileSdkVersion

    namespace 'com.lawthewall.culturalai'
    defaultConfig {
        applicationId 'com.lawthewall.culturalai'
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0.0"
    }
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
    }
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
        }
        release {
            // Caution! In production, you need to generate your own keystore file.
            // see https://reactnative.dev/docs/signed-apk-android.
            signingConfig signingConfigs.debug
            shrinkResources (findProperty('android.enableShrinkResourcesInReleaseBuilds')?.toBoolean() ?: false)
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            crunchPngs (findProperty('android.enablePngCrunchInReleaseBuilds')?.toBoolean() ?: true)
        }
    }
    packagingOptions {
        jniLibs {
            useLegacyPackaging (findProperty('expo.useLegacyPackaging')?.toBoolean() ?: false)
        }
    }
    androidResources {
        ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:!CVS:!thumbs.db:!picasa.ini:!*~'
    }
}

// Apply static values from `gradle.properties` to the `android.packagingOptions`
// Accepts values in comma delimited lists, example:
// android.packagingOptions.pickFirsts=/LICENSE,**/picasa.ini
["pickFirsts", "excludes", "merges", "doNotStrip"].each { prop ->
    // Split option: 'foo,bar' -> ['foo', 'bar']
    def options = (findProperty("android.packagingOptions.$prop") ?: "").split(",");
    // Trim all elements in place.
    for (i in 0..<options.size()) options[i] = options[i].trim();
    // `[] - ""` is essentially `[""].filter(Boolean)` removing all empty strings.
    options -= ""

    if (options.length > 0) {
        println "android.packagingOptions.$prop += $options ($options.length)"
        // Ex: android.packagingOptions.pickFirsts += '**/SCCS/**'
        options.each {
            android.packagingOptions[prop] += it
        }
    }
}

dependencies {
    // The version of react-native is set by the React Native Gradle Plugin
    implementation("com.facebook.react:react-android")

    def isGifEnabled = (findProperty('expo.gif.enabled') ?: "") == "true";
    def isWebpEnabled = (findProperty('expo.webp.enabled') ?: "") == "true";
    def isWebpAnimatedEnabled = (findProperty('expo.webp.animated') ?: "") == "true";

    if (isGifEnabled) {
        // For animated gif support
        implementation("com.facebook.fresco:animated-gif:${expoLibs.versions.fresco.get()}")
    }

    if (isWebpEnabled) {
        // For webp support
        implementation("com.facebook.fresco:webpsupport:${expoLibs.versions.fresco.get()}")
        if (isWebpAnimatedEnabled) {
            // Animated webp support
            implementation("com.facebook.fresco:animated-webp:${expoLibs.versions.fresco.get()}")
        }
    }

    if (hermesEnabled.toBoolean()) {
        implementation("com.facebook.react:hermes-android")
    } else {
        implementation jscFlavor
    }
}
</file>

<file path="culturalai/android/app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /usr/local/Cellar/android-sdk/24.3.3/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# react-native-reanimated
-keep class com.swmansion.reanimated.** { *; }
-keep class com.facebook.react.turbomodule.** { *; }

# Add any project specific keep options here:
</file>

<file path="culturalai/android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="culturalai/android/.gitignore">
# OSX
#
.DS_Store

# Android/IntelliJ
#
build/
.idea
.gradle
local.properties
*.iml
*.hprof
.cxx/

# Bundle artifacts
*.jsbundle
</file>

<file path="culturalai/android/build.gradle">
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
  repositories {
    google()
    mavenCentral()
  }
  dependencies {
    classpath('com.android.tools.build:gradle')
    classpath('com.facebook.react:react-native-gradle-plugin')
    classpath('org.jetbrains.kotlin:kotlin-gradle-plugin')
  }
}

// Apply the ext.gradle file to define SDK versions
apply from: "ext.gradle"

def reactNativeAndroidDir = new File(
  providers.exec {
    workingDir(rootDir)
    commandLine("node", "--print", "require.resolve('react-native/package.json')")
  }.standardOutput.asText.get().trim(),
  "../android"
)

allprojects {
  repositories {
    maven {
      // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm
      url(reactNativeAndroidDir)
    }

    google()
    mavenCentral()
    maven { url 'https://www.jitpack.io' }
  }
}

apply plugin: "expo-root-project"
apply plugin: "com.facebook.react.rootproject"
</file>

<file path="culturalai/android/ext.gradle">
// Define the Android SDK versions
rootProject.ext {
    buildToolsVersion = "33.0.2"
    minSdkVersion = 24
    compileSdkVersion = 33
    targetSdkVersion = 33
    ndkVersion = "25.1.8937393"
}
</file>

<file path="culturalai/android/gradle.properties">
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value: -Xmx512m -XX:MaxMetaspaceSize=256m
org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=512m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true

# Enable AAPT2 PNG crunching
android.enablePngCrunchInReleaseBuilds=true

# Use this property to specify which architecture you want to build.
# You can also override it from the CLI using
# ./gradlew <task> -PreactNativeArchitectures=x86_64
reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64

# Use this property to enable support to the new architecture.
# This will allow you to use TurboModules and the Fabric render in
# your application. You should enable this flag either if you want
# to write custom TurboModules/Fabric components OR use libraries that
# are providing them.
newArchEnabled=true

# Use this property to enable or disable the Hermes JS engine.
# If set to false, you will be using JSC instead.
hermesEnabled=true

# Enable GIF support in React Native images (~200 B increase)
expo.gif.enabled=true
# Enable webp support in React Native images (~85 KB increase)
expo.webp.enabled=true
# Enable animated webp support (~3.4 MB increase)
# Disabled by default because iOS doesn't support animated webp
expo.webp.animated=false

# Enable network inspector
EX_DEV_CLIENT_NETWORK_INSPECTOR=true

# Use legacy packaging to compress native libraries in the resulting APK.
expo.useLegacyPackaging=false

# Whether the app is configured to use edge-to-edge via the app config or `react-native-edge-to-edge` plugin
expo.edgeToEdgeEnabled=true
</file>

<file path="culturalai/android/gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="culturalai/android/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="culturalai/android/settings.gradle">
pluginManagement {
  def reactNativeGradlePlugin = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('@react-native/gradle-plugin/package.json', { paths: [require.resolve('react-native/package.json')] })")
    }.standardOutput.asText.get().trim()
  ).getParentFile().absolutePath
  includeBuild(reactNativeGradlePlugin)
  
  def expoPluginsPath = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('expo-modules-autolinking/package.json', { paths: [require.resolve('expo/package.json')] })")
    }.standardOutput.asText.get().trim(),
    "../android/expo-gradle-plugin"
  ).absolutePath
  includeBuild(expoPluginsPath)
}

plugins {
  id("com.facebook.react.settings")
  id("expo-autolinking-settings")
}

extensions.configure(com.facebook.react.ReactSettingsExtension) { ex ->
  if (System.getenv('EXPO_USE_COMMUNITY_AUTOLINKING') == '1') {
    ex.autolinkLibrariesFromCommand()
  } else {
    ex.autolinkLibrariesFromCommand(expoAutolinking.rnConfigCommand)
  }
}
expoAutolinking.useExpoModules()

rootProject.name = 'culturalai'

expoAutolinking.useExpoVersionCatalog()

include ':app'
includeBuild(expoAutolinking.reactNativeGradlePlugin)
</file>

<file path="culturalai/src/types/custom.d.ts">
declare module 'react-native-safe-area-context' {
  import React from 'react';
  import { ViewProps } from 'react-native';

  export interface SafeAreaProviderProps extends ViewProps {
    children?: React.ReactNode;
  }

  export const SafeAreaProvider: React.FC<SafeAreaProviderProps>;
}
</file>

<file path="culturalai/src/types/react-native.d.ts">
declare module 'react-native' {
  import React from 'react';

  export interface ViewProps {
    style?: any;
    children?: React.ReactNode;
  }

  export interface TextProps {
    style?: any;
    children?: React.ReactNode;
  }

  export interface StyleSheetStatic {
    create<T extends Record<string, any>>(styles: T): T;
  }

  export class View extends React.Component<ViewProps> {}
  export class Text extends React.Component<TextProps> {}
  
  export const StyleSheet: StyleSheetStatic;
}
</file>

<file path="culturalai/src/types/react.d.ts">
declare module 'react' {
  export interface ReactElement<P = any, T = any> {
    type: T;
    props: P;
    key: string | null;
  }

  export interface ReactNode {
    children?: ReactNode;
  }

  export function createElement(
    type: any,
    props?: any,
    ...children: any[]
  ): ReactElement;

  export const Fragment: any;

  export default {
    createElement,
    Fragment
  };
}
</file>

<file path="culturalai/.gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local
database.env

# typescript
*.tsbuildinfo
</file>

<file path="culturalai/app.json">
{
  "expo": {
    "name": "culturalai",
    "slug": "culturalai",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "package": "com.lawthewall.culturalai"
    },
    "web": {
      "favicon": "./assets/favicon.png",
      "bundler": "metro",
      "output": "static",
      "backgroundColor": "#ffffff",
      "themeColor": "#4A6FA5"
    }
  }
}
</file>

<file path="culturalai/App.tsx">
import * as React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Cultural AI App</Text>
      <Text style={styles.subtitle}>Welcome to the application!</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#4A6FA5',
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
});
</file>

<file path="culturalai/babel.config.js">
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
  };
};
</file>

<file path="culturalai/index.js">
import { registerRootComponent } from 'expo';
import App from './simple-app';

// Register the app
registerRootComponent(App);
</file>

<file path="culturalai/index.ts">
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
</file>

<file path="culturalai/metro.config.js">
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require('expo/metro-config');

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);

// Use our index.js file as the entry point
config.resolver.sourceExts = ['js', 'jsx', 'json', 'ts', 'tsx'];
config.resolver.assetExts = ['png', 'jpg', 'jpeg', 'gif', 'svg'];

module.exports = config;
</file>

<file path="culturalai/package.json">
{
  "name": "culturalai",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test-db": "ts-node ../../src/utils/testConnection.ts"
  },
  "dependencies": {
    "@expo/metro-runtime": "~5.0.4",
    "@expo/vector-icons": "^14.1.0",
    "@react-navigation/bottom-tabs": "^7.3.13",
    "@react-navigation/native": "^7.1.9",
    "@react-navigation/stack": "^7.3.2",
    "bcryptjs": "^3.0.2",
    "dotenv": "^16.5.0",
    "expo": "~53.0.9",
    "expo-secure-store": "^14.2.3",
    "expo-status-bar": "~2.2.3",
    "mssql": "^11.0.1",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-native": "0.79.2",
    "react-native-safe-area-context": "^5.4.0",
    "react-native-screens": "^4.10.0",
    "react-native-web": "^0.20.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/bcryptjs": "^2.4.6",
    "@types/mssql": "^9.1.7",
    "@types/react": "~19.0.10",
    "@types/react-native": "^0.72.8",
    "@types/uuid": "^10.0.0",
    "ts-node": "^10.9.2",
    "typescript": "~5.8.3"
  },
  "private": true
}
</file>

<file path="culturalai/simple-app.js">
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Cultural AI App</Text>
      <Text style={styles.subtitle}>Welcome to the application!</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#4A6FA5',
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
});
</file>

<file path="culturalai/tsconfig.json">
{
  "compilerOptions": {
    "strict": true,
    "jsx": "react-native",
    "baseUrl": ".",
    "paths": {
      "*": [
        "src/*",
        "*"
      ]
    },
    "typeRoots": [
      "./node_modules/@types",
      "./src/types"
    ],
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "node",
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "src/types/*.d.ts"
  ],
  "exclude": [
    "node_modules"
  ],
  "extends": "expo/tsconfig.base"
}
</file>

<file path="scripts/build-mobile-demo.sh">
#!/bin/bash

# Build script for Cultural AI Navigator mobile app demo
# This script helps build the mobile app for demonstration purposes

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${GREEN}=== Cultural AI Navigator - Mobile App Demo Build ===${NC}"
echo

# Check if npm is installed
if ! command -v npm &> /dev/null; then
    echo -e "${RED}Error: npm is not installed. Please install Node.js and npm.${NC}"
    exit 1
fi

# Check if expo-cli is installed
if ! command -v expo &> /dev/null; then
    echo -e "${YELLOW}Warning: expo-cli is not installed. Installing it now...${NC}"
    npm install -g expo-cli
fi

# Install dependencies
echo -e "${GREEN}Installing dependencies...${NC}"
npm install

# Build type selection
echo
echo -e "${GREEN}Select build type:${NC}"
echo "1) Android APK (requires Expo account)"
echo "2) iOS Simulator Build (requires macOS and Xcode)"
echo "3) Web Build (easiest for quick demo)"
echo "4) Expo Go QR Code (for testing on physical devices)"
read -p "Enter your choice (1-4): " BUILD_TYPE

case $BUILD_TYPE in
    1)
        echo -e "${GREEN}Building Android APK...${NC}"
        echo -e "${YELLOW}Note: This requires an Expo account and may take some time.${NC}"
        expo build:android -t apk
        ;;
    2)
        echo -e "${GREEN}Building for iOS Simulator...${NC}"
        echo -e "${YELLOW}Note: This requires macOS and Xcode.${NC}"
        expo build:ios -t simulator
        ;;
    3)
        echo -e "${GREEN}Building for Web...${NC}"
        expo build:web
        echo -e "${GREEN}Build completed. Output is in the web-build folder.${NC}"
        echo -e "${YELLOW}To serve the web build locally:${NC}"
        echo "npx serve web-build"
        ;;
    4)
        echo -e "${GREEN}Starting Expo development server...${NC}"
        echo -e "${YELLOW}Scan the QR code with the Expo Go app on your device.${NC}"
        expo start
        ;;
    *)
        echo -e "${RED}Invalid option. Exiting.${NC}"
        exit 1
        ;;
esac

echo
echo -e "${GREEN}Done!${NC}"
</file>

<file path="scripts/deploy-server.sh">
#!/bin/bash

# Server deployment script for Cultural AI Navigator
# This script helps deploy the server to different cloud environments

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${GREEN}=== Cultural AI Navigator - Server Deployment ===${NC}"
echo

# Default values
DEPLOY_ENV="development"
SERVER_DIR="./server"

# Process command line arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -e|--environment) DEPLOY_ENV="$2"; shift ;;
        -d|--directory) SERVER_DIR="$2"; shift ;;
        -h|--help)
            echo "Usage: $0 [options]"
            echo "Options:"
            echo "  -e, --environment ENV   Deployment environment (development, staging, production)"
            echo "  -d, --directory DIR     Path to server directory (default: ./server)"
            echo "  -h, --help              Show this help message"
            exit 0
            ;;
        *) echo "Unknown parameter: $1"; exit 1 ;;
    esac
    shift
done

# Check if server directory exists
if [ ! -d "$SERVER_DIR" ]; then
    echo -e "${RED}Error: Server directory '$SERVER_DIR' not found.${NC}"
    exit 1
fi

# Check if npm is installed
if ! command -v npm &> /dev/null; then
    echo -e "${RED}Error: npm is not installed. Please install Node.js and npm.${NC}"
    exit 1
fi

echo -e "${GREEN}Deploying server to $DEPLOY_ENV environment...${NC}"

# Install dependencies
echo -e "${GREEN}Installing dependencies...${NC}"
cd "$SERVER_DIR"
npm ci

# Environment-specific deployment
case $DEPLOY_ENV in
    development)
        echo -e "${GREEN}Starting server in development mode...${NC}"
        npm run dev
        ;;
    staging|production)
        echo -e "${GREEN}Building for $DEPLOY_ENV...${NC}"
        
        # For Heroku deployment (example)
        if command -v heroku &> /dev/null; then
            echo -e "${YELLOW}Detected Heroku CLI. Deploying to Heroku...${NC}"
            echo -e "${YELLOW}Note: This assumes you've already set up a Heroku app and logged in.${NC}"
            
            git subtree push --prefix server heroku main
            
            echo -e "${GREEN}Deployed to Heroku.${NC}"
        # For AWS Elastic Beanstalk deployment (example)
        elif command -v eb &> /dev/null; then
            echo -e "${YELLOW}Detected AWS EB CLI. Deploying to Elastic Beanstalk...${NC}"
            echo -e "${YELLOW}Note: This assumes you've already set up EB CLI and initialized your application.${NC}"
            
            eb deploy
            
            echo -e "${GREEN}Deployed to AWS Elastic Beanstalk.${NC}"
        # Manual deployment instructions
        else
            echo -e "${YELLOW}No cloud deployment CLI detected. Manual deployment steps:${NC}"
            echo "1. Install the appropriate CLI for your cloud provider:"
            echo "   - For Heroku: npm install -g heroku"
            echo "   - For AWS: pip install awsebcli"
            echo "   - For Google Cloud: Install Google Cloud SDK"
            echo
            echo "2. Configure your cloud provider credentials"
            echo
            echo "3. Deploy using the provider-specific commands"
            echo "   - For Heroku: git subtree push --prefix server heroku main"
            echo "   - For AWS EB: eb deploy"
            echo "   - For GCP App Engine: gcloud app deploy"
        fi
        ;;
    *)
        echo -e "${RED}Invalid environment: $DEPLOY_ENV${NC}"
        echo "Valid environments: development, staging, production"
        exit 1
        ;;
esac

echo
echo -e "${GREEN}Done!${NC}"
</file>

<file path="scripts/README.md">
# Cultural AI Navigator - Build & Deployment Scripts

This directory contains scripts for building and deploying the Cultural AI Navigator application.

## Scripts Overview

### `build-mobile-demo.sh`

This script helps you build the mobile application for demonstration purposes.

**Usage:**
```bash
./build-mobile-demo.sh
```

The script will guide you through different build options:
1. Android APK (requires Expo account)
2. iOS Simulator Build (requires macOS and Xcode)
3. Web Build (easiest for quick demo)
4. Expo Go QR Code (for testing on physical devices)

### `deploy-server.sh`

This script helps you deploy the server to different cloud environments.

**Usage:**
```bash
./deploy-server.sh [options]
```

**Options:**
- `-e, --environment ENV`: Deployment environment (development, staging, production)
- `-d, --directory DIR`: Path to server directory (default: ./server)
- `-h, --help`: Show help message

**Examples:**
```bash
# Start the server in development mode
./deploy-server.sh -e development

# Deploy to staging environment
./deploy-server.sh -e staging

# Deploy to production environment
./deploy-server.sh -e production

# Specify a different server directory
./deploy-server.sh -e production -d ./path/to/server
```

## CI/CD Integration

These scripts are designed to work with the GitHub Actions workflows in `.github/workflows/`:

- `client-ci.yml`: Handles client-side CI/CD
- `server-ci.yml`: Handles server-side CI/CD

The GitHub Actions workflows will automatically run tests and create deployment artifacts for manual deployment.

## Testing

For the server, we've set up a basic test framework using Mocha. To run the tests:

```bash
cd server
npm test
```

To run tests in watch mode:

```bash
cd server
npm run test:watch
```
</file>

<file path="server/certs/.gitkeep">
# This file ensures that this directory is tracked by Git
# even when it's empty. Certificate files should not be committed.
</file>

<file path="server/certs/server.cert">
-----BEGIN CERTIFICATE-----
MIIDNTCCAh0CFDEnvN7LCSnL8iXJEGYxUTlQFaLWMA0GCSqGSIb3DQEBCwUAMFcx
CzAJBgNVBAYTAlVTMQ4wDAYDVQQIDAVTdGF0ZTENMAsGA1UEBwwEQ2l0eTEVMBMG
A1UECgwMT3JnYW5pemF0aW9uMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjUwNTEx
MjM1NTMwWhcNMjYwNTExMjM1NTMwWjBXMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF
U3RhdGUxDTALBgNVBAcMBENpdHkxFTATBgNVBAoMDE9yZ2FuaXphdGlvbjESMBAG
A1UEAwwJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
tlLiwS+153iq+TvKL4vqH+L7dHMM4xYh7CPSWGDEhDu0fu51pwAo3uzoUXBUT9wG
ogc+HyEHNMeGx7d0f2Mrcdhk8Xbf36R7bKXJFeJNy4I6Q7jpBgTGrcwnKBVOVS+q
fJF7PgWNiljIRjKEf421+hi379Q7PJHQSL82Th+LOkjleZDvSHRnBintQZ8CFXfA
tr5PjsRyE5tg4rpLXCZzGgWtI+7B5HiH69v9vndJAbvZ+e0lfss6KfwYDgrEH27S
vUpG5U0lW676vhwSfKKwH9+2HQwOF/VRcdw7UPgJV4kKy8LD2wmD4EGKo5hsal8k
KkOZ4m4rLPD2NHAl4aZyzwIDAQABMA0GCSqGSIb3DQEBCwUAA4IBAQC126fuG4Et
wNWVwJ/ZQ/sDw9DqkicEcfLQcoOVdHxoTGqJzagtgBq1zt49doBkRXHMR7lQk8lf
zw/iJkwphtddyhmTpuNcZ64dXrqJ3/nH1HBzrl6dHQmpZTZc8zASl83BmKOqX9Vk
Wr9gyUepzn9tT2eCSKfSQGaDDZogPcXRBPRI7HzPJlziIqz6+LTVDeHsB2qVDsDx
vyeLg2kTgP0JV8pxXUHTmvH9x5Bl1GpwB2+crAg+FMPEGqJ/UJTMexxbLQ7ZvTvR
VA8cVCDW1bKmwWjsNFa2uvhlyL7+d/WMZUnX5Xq0D4FT7H0ZYiQAJHYmHKMoxqAL
hklGAZKasOaw
-----END CERTIFICATE-----
</file>

<file path="server/certs/server.csr">
-----BEGIN CERTIFICATE REQUEST-----
MIICnDCCAYQCAQAwVzELMAkGA1UEBhMCVVMxDjAMBgNVBAgMBVN0YXRlMQ0wCwYD
VQQHDARDaXR5MRUwEwYDVQQKDAxPcmdhbml6YXRpb24xEjAQBgNVBAMMCWxvY2Fs
aG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZS4sEvted4qvk7
yi+L6h/i+3RzDOMWIewj0lhgxIQ7tH7udacAKN7s6FFwVE/cBqIHPh8hBzTHhse3
dH9jK3HYZPF239+ke2ylyRXiTcuCOkO46QYExq3MJygVTlUvqnyRez4FjYpYyEYy
hH+NtfoYt+/UOzyR0Ei/Nk4fizpI5XmQ70h0ZwYp7UGfAhV3wLa+T47EchObYOK6
S1wmcxoFrSPuweR4h+vb/b53SQG72fntJX7LOin8GA4KxB9u0r1KRuVNJVuu+r4c
EnyisB/fth0MDhf1UXHcO1D4CVeJCsvCw9sJg+BBiqOYbGpfJCpDmeJuKyzw9jRw
JeGmcs8CAwEAAaAAMA0GCSqGSIb3DQEBCwUAA4IBAQCf2n0CHCMSSbgzvqYSrXg8
XFL+0nta7cbVmc1rYttTDqUvwjaD68oaHDCm0shw9GAKqOkNbJPWHuVPd4y7t/Sb
Xu9K+A5xeUx0ryKgS8X1Na7YWdcMVhS9MJafhgsEyUobeSYZ4kAqHDiodpzNBMvb
OwpZbmaaDuJ0oQve1u/dCCZET1EpqrADtNPGLxMIr0QTa054gCDbyoOTKaA4IpCF
VKLm6aT10qscv+KR4HCqBr9MUxsZgv1ehf75iA8S4dOOUNyMMxKM1TFlIv1HPJKZ
EBz1cQehg2WAuiaqOwfrzMekN2UV9/OZHeA3MN6LLvlpCtHphK3dzagG2rSEZBJ4
-----END CERTIFICATE REQUEST-----
</file>

<file path="server/config/production.js">
/**
 * Production environment configuration
 */

module.exports = {
  // Server Configuration
  server: {
    port: process.env.PORT || 3000,
    httpsPort: process.env.HTTPS_PORT || 3443,
    environment: 'production',
    enableHttps: process.env.ENABLE_HTTPS === 'true' || true,
    generateSelfSignedCerts: process.env.GENERATE_SELF_SIGNED_CERTS === 'true' || true
  },
  
  // Database Configuration
  // These will be overridden by environment variables in production
  database: {
    connectionString: process.env.DB_CONNECTION_STRING,
    server: process.env.DB_SERVER,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME || 'CulturalAI',
    trustServerCertificate: process.env.DB_TRUST_SERVER_CERTIFICATE === 'true' || true
  },
  
  // JWT Configuration
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRATION || '24h' 
  },
  
  // Logging Configuration
  logging: {
    level: process.env.LOG_LEVEL || 'info',
    enableRequestLogging: process.env.ENABLE_REQUEST_LOGGING === 'true' || true
  },
  
  // CORS Configuration
  cors: {
    allowedOrigins: process.env.CORS_ALLOWED_ORIGINS ? process.env.CORS_ALLOWED_ORIGINS.split(',') : ['*']
  },
  
  // AI Service Configuration
  ai: {
    apiKey: process.env.AI_SERVICE_API_KEY,
    endpoint: process.env.AI_SERVICE_ENDPOINT
  }
};
</file>

<file path="server/docs/ckb_versioning_plan.md">
# Cultural Knowledge Base (CKB) Versioning and Audit Trail Plan

## Overview

This document outlines the plan for implementing versioning and audit trails for the Cultural Knowledge Base (CKB) entries. This is important for tracking changes to cultural data over time, maintaining data integrity, and ensuring accountability.

## Goals

1. Track all changes to CKB entries
2. Maintain a history of previous versions
3. Record who made changes and when
4. Provide ability to revert to previous versions if needed
5. Support data quality assurance processes

## Implementation Plan

### Phase 1: Basic Versioning (Post-MVP)

1. **Database Schema Updates**
   - Add versioning tables for each CKB entity type:
     - `CulturesVersions`
     - `CulturalNormsVersions`
     - `IdiomsVersions`
     - `ScenariosVersions`
     - `ScenarioChoicesVersions`
   - Each versioning table will include:
     - All fields from the original table
     - `VersionID` (primary key)
     - `EntityID` (foreign key to the original entity)
     - `VersionNumber` (incremental version number)
     - `ChangedBy` (UserID of the admin who made the change)
     - `ChangedAt` (timestamp)
     - `ChangeReason` (text description of why the change was made)
     - `ChangeType` (CREATE, UPDATE, DELETE)

2. **Triggers/Procedures**
   - Create database triggers or application-level hooks that automatically:
     - Create a new version record when an entity is created
     - Create a new version record when an entity is updated
     - Create a new version record when an entity is deleted (logical deletion)

3. **API Enhancements**
   - Update admin API endpoints to:
     - Require a `changeReason` parameter for all write operations
     - Return version information in responses

### Phase 2: Advanced Versioning and Audit (Future)

1. **Diff Tracking**
   - Store only the differences between versions rather than complete copies
   - Implement algorithms to reconstruct full versions from diffs

2. **Version Comparison UI**
   - Add admin UI features to:
     - View side-by-side comparisons of different versions
     - Highlight specific changes between versions
     - Allow filtering version history by date range, user, etc.

3. **Reversion Capabilities**
   - Implement functionality to revert to a previous version
   - Create new version records when reversions occur

4. **Approval Workflows**
   - Implement multi-step approval processes for sensitive changes
   - Track approval history in the versioning system

## Data Structure Example

```sql
CREATE TABLE CulturesVersions (
  VersionID NVARCHAR(36) PRIMARY KEY,
  CultureID NVARCHAR(36) NOT NULL,
  VersionNumber INT NOT NULL,
  CultureName NVARCHAR(100) NOT NULL,
  Region NVARCHAR(100) NOT NULL,
  PrimaryLanguage NVARCHAR(100) NOT NULL,
  Description NVARCHAR(MAX) NOT NULL,
  LastUpdated DATETIME2 NOT NULL,
  ChangedBy NVARCHAR(36) NOT NULL,
  ChangedAt DATETIME2 NOT NULL,
  ChangeReason NVARCHAR(MAX) NOT NULL,
  ChangeType NVARCHAR(10) NOT NULL,
  CONSTRAINT FK_CulturesVersions_Cultures FOREIGN KEY (CultureID) REFERENCES Cultures(CultureID)
);
```

## API Usage Example

```javascript
// Example API call to update a culture with versioning
PUT /api/admin/cultures/jp-001
{
  "CultureName": "Japanese",
  "Region": "East Asia",
  "PrimaryLanguage": "Japanese",
  "Description": "Updated description with more details about Japanese culture...",
  "_meta": {
    "changeReason": "Updated description to include more details about business etiquette"
  }
}
```

## Implementation Timeline

- **Phase 1**: To be implemented after the MVP release
- **Phase 2**: To be considered for future releases based on user feedback and business requirements

## Conclusion

This versioning and audit trail system will ensure that all changes to the Cultural Knowledge Base are tracked, providing transparency and accountability while maintaining data integrity. The phased approach allows for basic versioning to be implemented relatively quickly after the MVP, with more advanced features added as needed in the future.
</file>

<file path="server/docs/cloud-deployment.md">
# Cloud Deployment Guide for Cultural AI Navigator Backend

This guide provides instructions for deploying the Cultural AI Navigator backend server to various cloud environments.

## Prerequisites

- Node.js 18 or higher
- SQL Server database (can be hosted in the cloud)
- A cloud provider account (Azure, AWS, Heroku, or similar)

## Environment Variables

The following environment variables need to be configured in your cloud environment:

### Server Configuration
- `PORT`: The HTTP port the server will listen on (default: 3000)
- `HTTPS_PORT`: The HTTPS port the server will listen on (default: 3443)
- `NODE_ENV`: Set to 'production' for production deployments

### Database Configuration
**Option 1: Connection string**
- `DB_CONNECTION_STRING`: Complete connection string to your SQL Server database

**Option 2: Individual connection parameters**
- `DB_SERVER`: Database server hostname
- `DB_USER`: Database username
- `DB_PASSWORD`: Database password
- `DB_NAME`: Database name (default: CulturalAI)
- `DB_TRUST_SERVER_CERTIFICATE`: Set to 'true' if using a self-signed certificate

### JWT Configuration
- `JWT_SECRET`: A secure random string for JWT token generation
- `JWT_EXPIRATION`: Token expiration time (default: 24h)

### Security Configuration
- `ENABLE_HTTPS`: Set to 'true' to enable HTTPS (recommended for production)
- `GENERATE_SELF_SIGNED_CERTS`: Set to 'true' to generate self-signed certs (not recommended for production)

### Logging Configuration
- `LOG_LEVEL`: Log level (default: info)
- `ENABLE_REQUEST_LOGGING`: Set to 'true' to enable detailed request logging

### CORS Configuration
- `CORS_ALLOWED_ORIGINS`: Comma-separated list of allowed origins for CORS

### AI Service Configuration
- `AI_SERVICE_API_KEY`: API key for the AI service
- `AI_SERVICE_ENDPOINT`: Endpoint URL for the AI service

## Database Setup

To set up the database schema in the cloud environment:

1. Ensure your database connection environment variables are configured
2. Run the database setup script:
   ```
   npm run db:setup
   ```

## Deployment Options

### Azure App Service

1. Create an App Service in Azure Portal
2. Configure environment variables in "Application settings"
3. Deploy using one of these methods:
   - GitHub Actions (recommended)
   - Azure CLI: `az webapp deploy --resource-group <resource-group> --name <app-name> --src-path server.zip`
   - Visual Studio Code Azure extension

### AWS Elastic Beanstalk

1. Create an Elastic Beanstalk environment
2. Configure environment variables in the EB Console
3. Deploy using one of these methods:
   - GitHub Actions (recommended)
   - EB CLI: `eb deploy`
   - AWS Console upload

### Heroku

1. Create a new Heroku app
2. Configure environment variables using:
   ```
   heroku config:set KEY=VALUE
   ```
3. Deploy using one of these methods:
   - GitHub integration
   - Heroku CLI: `git push heroku main`
   - GitHub Actions

### Docker Deployment

A Dockerfile is provided in the server directory. To build and run:

```bash
# Build the Docker image
docker build -t culturalai-server ./server

# Run the container
docker run -p 3000:3000 -p 3443:3443 --env-file ./server/.env culturalai-server
```

## Health Check

The server provides a health check endpoint at `/api/health` that can be used by load balancers or monitoring tools to verify the server is running correctly.

## Scaling Considerations

- The server is stateless and can be horizontally scaled
- For high availability, deploy multiple instances behind a load balancer
- Consider using a managed database service for the SQL Server database
- Implement a caching layer (like Redis) for frequently accessed data

## Monitoring

It's recommended to set up monitoring for the deployed application using:
- Azure Application Insights
- AWS CloudWatch
- Heroku Metrics
- Or another monitoring solution like New Relic or Datadog
</file>

<file path="server/logs/.gitkeep">
# This file ensures that this directory is tracked by Git
# even when it's empty. Log files should not be committed.
</file>

<file path="server/middleware/clientErrorCollector.js">
/**
 * Client Error Collector Middleware
 * Endpoint to collect and log client-side errors
 */

const logger = require('../utils/logger');

// Middleware to handle client error reports
const clientErrorCollector = (req, res) => {
  try {
    const { 
      message, 
      source, 
      lineno, 
      colno, 
      error, 
      stack, 
      componentStack,
      url,
      userAgent,
      timestamp 
    } = req.body;

    // Log the client error with context
    logger.error(`Client Error: ${message || 'Unknown error'}`, {
      clientError: true,
      source,
      location: { lineno, colno },
      errorObject: error,
      stack: stack || componentStack,
      url,
      userAgent: userAgent || req.headers['user-agent'],
      timestamp: timestamp || new Date().toISOString(),
      ip: req.ip,
      requestId: req.requestId || req.headers['x-request-id'],
      userId: req.user?.id || 'unauthenticated',
    });

    // Send success response
    res.status(200).json({ success: true, message: 'Error logged successfully' });
  } catch (err) {
    // Log if there's an error processing the client error
    logger.error('Error processing client error report', { 
      error: err.message,
      stack: err.stack,
      requestBody: req.body 
    });
    
    // Still return a success to the client
    res.status(200).json({ success: true, message: 'Error received but not processed correctly' });
  }
};

module.exports = clientErrorCollector;
</file>

<file path="server/middleware/errorHandler.js">
/**
 * Error handling middleware for the Cultural AI Navigator backend
 * Catches and logs errors, then sends appropriate responses
 */

const logger = require('../utils/logger');

// Error handling middleware
const errorHandler = (err, req, res, next) => {
  // Log the error with context
  logger.error(`${err.name}: ${err.message}`, {
    stack: err.stack,
    path: req.path,
    method: req.method,
    ip: req.ip,
    userId: req.user?.id || 'unauthenticated',
    requestId: req.headers['x-request-id'] || `req-${Date.now()}`,
  });

  // Default error status and message
  let statusCode = err.statusCode || 500;
  let errorMessage = err.message || 'Internal Server Error';
  let errorDetails = undefined;

  // In development mode, include error details
  if (process.env.NODE_ENV === 'development') {
    errorDetails = {
      stack: err.stack?.split('\n'),
      code: err.code,
    };
  }

  // Handle specific error types
  if (err.name === 'ValidationError') {
    statusCode = 400;
  } else if (err.name === 'UnauthorizedError' || err.name === 'JsonWebTokenError') {
    statusCode = 401;
  } else if (err.name === 'ForbiddenError') {
    statusCode = 403;
  } else if (err.name === 'NotFoundError') {
    statusCode = 404;
  }

  // Send response
  res.status(statusCode).json({
    error: {
      message: errorMessage,
      ...(errorDetails && { details: errorDetails }),
    },
  });
};

// Not Found handler (404)
const notFoundHandler = (req, res, next) => {
  logger.warn(`Route not found: ${req.method} ${req.path}`, {
    ip: req.ip,
    headers: req.headers,
    query: req.query,
  });

  res.status(404).json({
    error: {
      message: `Not Found: ${req.method} ${req.path}`,
    },
  });
};

// Custom error classes
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
    this.statusCode = 400;
  }
}

class UnauthorizedError extends Error {
  constructor(message = 'Unauthorized: Authentication required') {
    super(message);
    this.name = 'UnauthorizedError';
    this.statusCode = 401;
  }
}

class ForbiddenError extends Error {
  constructor(message = 'Forbidden: Insufficient permissions') {
    super(message);
    this.name = 'ForbiddenError';
    this.statusCode = 403;
  }
}

class NotFoundError extends Error {
  constructor(message = 'Resource not found') {
    super(message);
    this.name = 'NotFoundError';
    this.statusCode = 404;
  }
}

module.exports = {
  errorHandler,
  notFoundHandler,
  ValidationError,
  UnauthorizedError,
  ForbiddenError,
  NotFoundError,
};
</file>

<file path="server/middleware/requestId.js">
/**
 * Request ID middleware
 * Assigns a unique identifier to each request for tracking through logs
 */

const { v4: uuidv4 } = require('uuid');

// Middleware to add a unique request ID to each request
const requestIdMiddleware = (req, res, next) => {
  // Use existing request ID from headers if present, otherwise generate a new one
  const requestId = req.headers['x-request-id'] || `req-${uuidv4()}`;
  
  // Add the request ID to the request object for use in application code
  req.requestId = requestId;
  
  // Add the request ID to response headers
  res.setHeader('X-Request-ID', requestId);
  
  next();
};

module.exports = requestIdMiddleware;
</file>

<file path="server/middleware/requestLogger.js">
/**
 * HTTP Request Logging Middleware
 * Uses Morgan for HTTP request logging with custom format and winston logger integration
 */

const morgan = require('morgan');
const { httpLogStream } = require('../utils/logger');

// Define custom Morgan format for both machine parsing and human readability
const morganFormat = process.env.NODE_ENV === 'production'
  ? JSON.stringify({
      method: ':method',
      url: ':url',
      status: ':status',
      responseTime: ':response-time ms',
      contentLength: ':res[content-length]',
      referrer: ':referrer',
      userAgent: ':user-agent',
      ip: ':remote-addr',
      requestId: ':req[x-request-id]',
    })
  : ':method :url :status :response-time ms - :res[content-length] - :req[x-request-id]';

// Create the Morgan middleware with our custom format and logger stream
const requestLogger = morgan(morganFormat, {
  stream: httpLogStream,
  // Only log error responses in production
  skip: (req, res) => process.env.NODE_ENV === 'production' && res.statusCode < 400,
});

module.exports = requestLogger;
</file>

<file path="server/routes/admin.js">
/**
 * Admin routes for Cultural Knowledge Base (CKB) management
 */

const express = require('express');
const router = express.Router();
const { v4: uuidv4 } = require('uuid');
const { 
  validateCulture, 
  validateCulturalNorm, 
  validateIdiom, 
  validateScenario, 
  validateScenarioChoice 
} = require('../utils/validation');

// Mock database for MVP (replace with actual database in production)
const mockDb = {
  cultures: [
    {
      CultureID: 'jp-001',
      CultureName: 'Japanese',
      Region: 'East Asia',
      PrimaryLanguage: 'Japanese',
      Description: 'Japan has a rich cultural heritage spanning thousands of years, with strong emphasis on politeness, social harmony, and respect for tradition.',
      LastUpdated: new Date('2023-05-01')
    },
    {
      CultureID: 'ar-001',
      CultureName: 'Arabic (Gulf)',
      Region: 'Middle East',
      PrimaryLanguage: 'Arabic',
      Description: 'Gulf Arabic cultures value hospitality, respect, family bonds, and religious traditions, with distinct customs around greetings and social interactions.',
      LastUpdated: new Date('2023-05-02')
    },
    {
      CultureID: 'br-001',
      CultureName: 'Brazilian',
      Region: 'South America',
      PrimaryLanguage: 'Portuguese',
      Description: 'Brazilian culture is known for its warmth, diversity, and rich expressions in music, cuisine, and social gatherings, with relaxed yet specific social norms.',
      LastUpdated: new Date('2023-05-03')
    }
  ],
  culturalNorms: [
    {
      NormID: 'jp-norm-001',
      CultureID: 'jp-001',
      Category: 'Greeting',
      SubCategory: 'Bowing',
      Description: 'Bowing etiquette in Japan',
      DoBehavior: 'Bow when greeting someone, with the depth of bow reflecting the level of respect.',
      DontBehavior: 'Don\'t offer a handshake first, and don\'t bow with hands in pockets or while chewing gum.',
      Explanation: 'Bowing is an essential part of Japanese culture, showing respect and social status. The deeper and longer the bow, the more respect is shown.',
      SeverityLevel: 'High',
      LastUpdated: new Date('2023-05-01')
    }
  ],
  idioms: [
    {
      IdiomID: 'jp-idiom-001',
      CultureID: 'jp-001',
      Language: 'Japanese',
      Phrase: '猫の手も借りたい',
      LiteralTranslation: 'I want to borrow even a cat\'s paws',
      Meaning: 'To be extremely busy, needing all the help one can get',
      UsageExamples: ['年末は猫の手も借りたいほど忙しい。', 'We are so busy at the end of the year that we could use even a cat\'s paw.'],
      ContextNotes: 'Used when expressing how busy you are, especially in work contexts',
      PolitenessLevel: 'Neutral',
      LastUpdated: new Date('2023-05-01')
    }
  ],
  scenarios: [],
  scenarioChoices: []
};

// Authentication middleware for admin routes
const authenticateAdmin = (req, res, next) => {
  // In a real implementation, this would check if the user has admin privileges
  // For MVP, we'll use a simple token check
  const adminToken = req.headers['admin-token'];
  
  if (!adminToken || adminToken !== process.env.ADMIN_TOKEN) {
    return res.status(403).json({ error: 'Admin authentication required' });
  }
  
  next();
};

// Apply admin authentication to all routes
router.use(authenticateAdmin);

// GET all cultures (admin view)
router.get('/cultures', (req, res) => {
  try {
    res.json({ cultures: mockDb.cultures });
  } catch (error) {
    console.error('Error fetching cultures:', error);
    res.status(500).json({ error: 'Failed to fetch cultures' });
  }
});

// GET a specific culture (admin view)
router.get('/cultures/:id', (req, res) => {
  try {
    const culture = mockDb.cultures.find(c => c.CultureID === req.params.id);
    
    if (!culture) {
      return res.status(404).json({ error: 'Culture not found' });
    }
    
    res.json({ culture });
  } catch (error) {
    console.error('Error fetching culture:', error);
    res.status(500).json({ error: 'Failed to fetch culture' });
  }
});

// POST create a new culture
router.post('/cultures', (req, res) => {
  try {
    const newCulture = req.body;
    
    // Validate the culture data
    const validationResult = validateCulture(newCulture);
    
    if (!validationResult.isValid) {
      return res.status(400).json({ errors: validationResult.errors });
    }
    
    // Generate a new ID and set LastUpdated
    const cultureToSave = {
      ...newCulture,
      CultureID: `${newCulture.CultureName.substring(0, 2).toLowerCase()}-${uuidv4().substring(0, 6)}`,
      LastUpdated: new Date()
    };
    
    // In a real implementation, this would save to a database
    mockDb.cultures.push(cultureToSave);
    
    res.status(201).json({ 
      message: 'Culture created successfully', 
      culture: cultureToSave 
    });
  } catch (error) {
    console.error('Error creating culture:', error);
    res.status(500).json({ error: 'Failed to create culture' });
  }
});

// PUT update a culture
router.put('/cultures/:id', (req, res) => {
  try {
    const cultureId = req.params.id;
    const updatedCulture = req.body;
    
    // Validate the culture data
    const validationResult = validateCulture(updatedCulture);
    
    if (!validationResult.isValid) {
      return res.status(400).json({ errors: validationResult.errors });
    }
    
    // Find the culture to update
    const cultureIndex = mockDb.cultures.findIndex(c => c.CultureID === cultureId);
    
    if (cultureIndex === -1) {
      return res.status(404).json({ error: 'Culture not found' });
    }
    
    // Update the culture
    mockDb.cultures[cultureIndex] = {
      ...mockDb.cultures[cultureIndex],
      ...updatedCulture,
      CultureID: cultureId, // Ensure ID doesn't change
      LastUpdated: new Date()
    };
    
    res.json({ 
      message: 'Culture updated successfully', 
      culture: mockDb.cultures[cultureIndex] 
    });
  } catch (error) {
    console.error('Error updating culture:', error);
    res.status(500).json({ error: 'Failed to update culture' });
  }
});

// DELETE a culture
router.delete('/cultures/:id', (req, res) => {
  try {
    const cultureId = req.params.id;
    
    // Find the culture to delete
    const cultureIndex = mockDb.cultures.findIndex(c => c.CultureID === cultureId);
    
    if (cultureIndex === -1) {
      return res.status(404).json({ error: 'Culture not found' });
    }
    
    // Delete the culture
    mockDb.cultures.splice(cultureIndex, 1);
    
    // In a real implementation, we would also delete related records or handle cascading deletes
    
    res.json({ message: 'Culture deleted successfully' });
  } catch (error) {
    console.error('Error deleting culture:', error);
    res.status(500).json({ error: 'Failed to delete culture' });
  }
});

// Cultural Norms CRUD operations

// GET all cultural norms for a culture
router.get('/cultures/:cultureId/norms', (req, res) => {
  try {
    const cultureId = req.params.cultureId;
    
    // Check if culture exists
    const cultureExists = mockDb.cultures.some(c => c.CultureID === cultureId);
    
    if (!cultureExists) {
      return res.status(404).json({ error: 'Culture not found' });
    }
    
    // Get norms for this culture
    const norms = mockDb.culturalNorms.filter(n => n.CultureID === cultureId);
    
    res.json({ norms });
  } catch (error) {
    console.error('Error fetching cultural norms:', error);
    res.status(500).json({ error: 'Failed to fetch cultural norms' });
  }
});

// POST create a new cultural norm
router.post('/cultures/:cultureId/norms', (req, res) => {
  try {
    const cultureId = req.params.cultureId;
    const newNorm = req.body;
    
    // Check if culture exists
    const cultureExists = mockDb.cultures.some(c => c.CultureID === cultureId);
    
    if (!cultureExists) {
      return res.status(404).json({ error: 'Culture not found' });
    }
    
    // Ensure the norm is associated with the correct culture
    newNorm.CultureID = cultureId;
    
    // Validate the norm data
    const validationResult = validateCulturalNorm(newNorm);
    
    if (!validationResult.isValid) {
      return res.status(400).json({ errors: validationResult.errors });
    }
    
    // Generate a new ID and set LastUpdated
    const normToSave = {
      ...newNorm,
      NormID: `${cultureId}-norm-${uuidv4().substring(0, 6)}`,
      LastUpdated: new Date()
    };
    
    // In a real implementation, this would save to a database
    mockDb.culturalNorms.push(normToSave);
    
    res.status(201).json({ 
      message: 'Cultural norm created successfully', 
      norm: normToSave 
    });
  } catch (error) {
    console.error('Error creating cultural norm:', error);
    res.status(500).json({ error: 'Failed to create cultural norm' });
  }
});

// Similar CRUD operations for idioms, scenarios, and scenario choices would follow the same pattern
// with appropriate validation using the validation utilities

// Export the router
module.exports = router;
</file>

<file path="server/routes/analysis.js">
/**
 * Cultural Analysis API Routes
 */

const express = require('express');
const router = express.Router();
const { executeQuery } = require('../utils/database');
const { analyzeCulturalContext, translateIdiom } = require('../utils/openai');
const logger = require('../utils/logger');

/**
 * POST /api/analysis/text
 * Analyze text for cultural appropriateness
 */
router.post('/text', async (req, res) => {
  try {
    const { text, cultureId, textOrigin = 'mine' } = req.body;
    
    // Validate required fields
    if (!text || !cultureId) {
      return res.status(400).json({ message: 'Text and culture ID are required' });
    }
    
    // Look up culture name from the database
    const cultures = await executeQuery(
      'SELECT CultureName FROM Cultures WHERE CultureID = @cultureId',
      { cultureId }
    );
    
    if (cultures.length === 0) {
      return res.status(404).json({ message: 'Culture not found' });
    }
    
    const cultureName = cultures[0].CultureName;
    
    // Call OpenAI to analyze the text
    const analysis = await analyzeCulturalContext(text, cultureId, cultureName, textOrigin);
    
    res.json(analysis);
  } catch (error) {
    logger.error('Error analyzing text:', error);
    res.status(500).json({ message: 'Failed to analyze text', error: error.message });
  }
});

/**
 * POST /api/analysis/translate-idiom
 * Translate an idiom between cultures
 */
router.post('/translate-idiom', async (req, res) => {
  try {
    const { idiom, sourceCultureId, targetCultureId } = req.body;
    
    // Validate required fields
    if (!idiom || !sourceCultureId || !targetCultureId) {
      return res.status(400).json({ message: 'Idiom, source culture, and target culture are required' });
    }
    
    // Look up culture names from the database
    const cultures = await executeQuery(
      'SELECT CultureID, CultureName FROM Cultures WHERE CultureID IN (@sourceCultureId, @targetCultureId)',
      { 
        sourceCultureId,
        targetCultureId
      }
    );
    
    if (cultures.length < 2) {
      return res.status(404).json({ message: 'One or both cultures not found' });
    }
    
    const sourceCulture = cultures.find(c => c.CultureID === sourceCultureId)?.CultureName;
    const targetCulture = cultures.find(c => c.CultureID === targetCultureId)?.CultureName;
    
    // Call OpenAI to translate the idiom
    const translation = await translateIdiom(idiom, sourceCulture, targetCulture);
    
    res.json(translation);
  } catch (error) {
    logger.error('Error translating idiom:', error);
    res.status(500).json({ message: 'Failed to translate idiom', error: error.message });
  }
});

module.exports = router;
</file>

<file path="server/routes/cultures.js">
/**
 * Cultures API Routes
 */

const express = require('express');
const router = express.Router();
const { executeQuery } = require('../utils/database');
const { v4: uuidv4 } = require('uuid');

/**
 * GET /api/cultures
 * Get all cultures
 */
router.get('/', async (req, res) => {
  try {
    const cultures = await executeQuery(
      'SELECT CultureID, CultureName, Region, PrimaryLanguage, Description, LastUpdated FROM Cultures'
    );
    res.json(cultures);
  } catch (error) {
    console.error('Error getting cultures:', error);
    res.status(500).json({ message: 'Failed to get cultures', error: error.message });
  }
});

/**
 * GET /api/cultures/:id
 * Get a culture by ID
 */
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const cultures = await executeQuery(
      'SELECT CultureID, CultureName, Region, PrimaryLanguage, Description, LastUpdated FROM Cultures WHERE CultureID = @id',
      { id }
    );
    
    if (cultures.length === 0) {
      return res.status(404).json({ message: 'Culture not found' });
    }
    
    res.json(cultures[0]);
  } catch (error) {
    console.error('Error getting culture:', error);
    res.status(500).json({ message: 'Failed to get culture', error: error.message });
  }
});

/**
 * POST /api/cultures
 * Create a new culture
 */
router.post('/', async (req, res) => {
  try {
    const { cultureName, region, primaryLanguage, description } = req.body;
    
    // Validate required fields
    if (!cultureName || !region || !primaryLanguage || !description) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Generate UUID
    const cultureId = `culture-${uuidv4()}`;
    
    await executeQuery(
      `INSERT INTO Cultures (CultureID, CultureName, Region, PrimaryLanguage, Description, LastUpdated)
       VALUES (@cultureId, @cultureName, @region, @primaryLanguage, @description, GETDATE())`,
      {
        cultureId,
        cultureName,
        region,
        primaryLanguage,
        description
      }
    );
    
    res.status(201).json({ 
      cultureId,
      cultureName,
      region,
      primaryLanguage,
      description,
      lastUpdated: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error creating culture:', error);
    res.status(500).json({ message: 'Failed to create culture', error: error.message });
  }
});

/**
 * PUT /api/cultures/:id
 * Update a culture
 */
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { cultureName, region, primaryLanguage, description } = req.body;
    
    // Check if culture exists
    const cultures = await executeQuery(
      'SELECT COUNT(*) as count FROM Cultures WHERE CultureID = @id',
      { id }
    );
    
    if (cultures[0].count === 0) {
      return res.status(404).json({ message: 'Culture not found' });
    }
    
    // Update the culture
    await executeQuery(
      `UPDATE Cultures 
       SET CultureName = @cultureName, 
           Region = @region, 
           PrimaryLanguage = @primaryLanguage, 
           Description = @description,
           LastUpdated = GETDATE()
       WHERE CultureID = @id`,
      {
        id,
        cultureName,
        region,
        primaryLanguage,
        description
      }
    );
    
    res.json({ 
      cultureId: id,
      cultureName,
      region,
      primaryLanguage,
      description,
      lastUpdated: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error updating culture:', error);
    res.status(500).json({ message: 'Failed to update culture', error: error.message });
  }
});

/**
 * DELETE /api/cultures/:id
 * Delete a culture
 */
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check if culture exists
    const cultures = await executeQuery(
      'SELECT COUNT(*) as count FROM Cultures WHERE CultureID = @id',
      { id }
    );
    
    if (cultures[0].count === 0) {
      return res.status(404).json({ message: 'Culture not found' });
    }
    
    // Delete the culture
    await executeQuery(
      'DELETE FROM Cultures WHERE CultureID = @id',
      { id }
    );
    
    res.status(204).end();
  } catch (error) {
    console.error('Error deleting culture:', error);
    res.status(500).json({ message: 'Failed to delete culture', error: error.message });
  }
});

module.exports = router;
</file>

<file path="server/routes/idioms.js">
/**
 * Idioms API Routes
 */

const express = require('express');
const router = express.Router();
const { executeQuery } = require('../utils/database');
const { v4: uuidv4 } = require('uuid');

/**
 * GET /api/idioms
 * Get all idioms, optionally filtered by culture
 */
router.get('/', async (req, res) => {
  try {
    const { cultureId, language } = req.query;
    let query = 'SELECT * FROM Idioms';
    const params = {};
    
    // Apply filters if provided
    if (cultureId || language) {
      query += ' WHERE';
      
      if (cultureId) {
        query += ' CultureID = @cultureId';
        params.cultureId = cultureId;
      }
      
      if (cultureId && language) {
        query += ' AND';
      }
      
      if (language) {
        query += ' Language = @language';
        params.language = language;
      }
    }
    
    const idioms = await executeQuery(query, params);
    
    // Get usage examples for each idiom
    for (const idiom of idioms) {
      const examples = await executeQuery(
        'SELECT * FROM IdiomUsageExamples WHERE IdiomID = @idiomId',
        { idiomId: idiom.IdiomID }
      );
      idiom.examples = examples;
    }
    
    res.json(idioms);
  } catch (error) {
    console.error('Error getting idioms:', error);
    res.status(500).json({ message: 'Failed to get idioms', error: error.message });
  }
});

/**
 * GET /api/idioms/:id
 * Get an idiom by ID
 */
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const idioms = await executeQuery(
      'SELECT * FROM Idioms WHERE IdiomID = @id',
      { id }
    );
    
    if (idioms.length === 0) {
      return res.status(404).json({ message: 'Idiom not found' });
    }
    
    const idiom = idioms[0];
    
    // Get usage examples
    const examples = await executeQuery(
      'SELECT * FROM IdiomUsageExamples WHERE IdiomID = @idiomId',
      { idiomId: id }
    );
    
    idiom.examples = examples;
    
    res.json(idiom);
  } catch (error) {
    console.error('Error getting idiom:', error);
    res.status(500).json({ message: 'Failed to get idiom', error: error.message });
  }
});

/**
 * POST /api/idioms
 * Create a new idiom
 */
router.post('/', async (req, res) => {
  try {
    const { 
      cultureId, 
      language, 
      phrase, 
      literalTranslation, 
      meaning, 
      contextNotes, 
      politenessLevel,
      examples = [] 
    } = req.body;
    
    // Validate required fields
    if (!cultureId || !language || !phrase || !literalTranslation || !meaning || !politenessLevel) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Check if the culture exists
    const cultures = await executeQuery(
      'SELECT COUNT(*) as count FROM Cultures WHERE CultureID = @cultureId',
      { cultureId }
    );
    
    if (cultures[0].count === 0) {
      return res.status(404).json({ message: 'Culture not found' });
    }
    
    // Generate UUID
    const idiomId = `idiom-${uuidv4()}`;
    
    await executeQuery(
      `INSERT INTO Idioms (
        IdiomID, CultureID, Language, Phrase, LiteralTranslation, 
        Meaning, ContextNotes, PolitenessLevel, LastUpdated
      ) VALUES (
        @idiomId, @cultureId, @language, @phrase, @literalTranslation,
        @meaning, @contextNotes, @politenessLevel, GETDATE()
      )`,
      {
        idiomId,
        cultureId,
        language,
        phrase,
        literalTranslation,
        meaning,
        contextNotes: contextNotes || null,
        politenessLevel
      }
    );
    
    // Add usage examples if provided
    for (const example of examples) {
      const exampleId = `example-${uuidv4()}`;
      await executeQuery(
        `INSERT INTO IdiomUsageExamples (ExampleID, IdiomID, ExampleText)
         VALUES (@exampleId, @idiomId, @exampleText)`,
        {
          exampleId,
          idiomId,
          exampleText: example
        }
      );
    }
    
    res.status(201).json({ 
      idiomId,
      cultureId,
      language,
      phrase,
      literalTranslation,
      meaning,
      contextNotes,
      politenessLevel,
      examples,
      lastUpdated: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error creating idiom:', error);
    res.status(500).json({ message: 'Failed to create idiom', error: error.message });
  }
});

/**
 * PUT /api/idioms/:id
 * Update an idiom
 */
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { 
      cultureId, 
      language, 
      phrase, 
      literalTranslation, 
      meaning, 
      contextNotes, 
      politenessLevel,
      examples = [] 
    } = req.body;
    
    // Check if idiom exists
    const idioms = await executeQuery(
      'SELECT COUNT(*) as count FROM Idioms WHERE IdiomID = @id',
      { id }
    );
    
    if (idioms[0].count === 0) {
      return res.status(404).json({ message: 'Idiom not found' });
    }
    
    // Update the idiom
    await executeQuery(
      `UPDATE Idioms 
       SET CultureID = @cultureId,
           Language = @language,
           Phrase = @phrase,
           LiteralTranslation = @literalTranslation,
           Meaning = @meaning,
           ContextNotes = @contextNotes,
           PolitenessLevel = @politenessLevel,
           LastUpdated = GETDATE()
       WHERE IdiomID = @id`,
      {
        id,
        cultureId,
        language,
        phrase,
        literalTranslation,
        meaning,
        contextNotes: contextNotes || null,
        politenessLevel
      }
    );
    
    // Remove existing examples and add new ones
    await executeQuery(
      'DELETE FROM IdiomUsageExamples WHERE IdiomID = @idiomId',
      { idiomId: id }
    );
    
    for (const example of examples) {
      const exampleId = `example-${uuidv4()}`;
      await executeQuery(
        `INSERT INTO IdiomUsageExamples (ExampleID, IdiomID, ExampleText)
         VALUES (@exampleId, @idiomId, @exampleText)`,
        {
          exampleId,
          idiomId: id,
          exampleText: example
        }
      );
    }
    
    res.json({
      idiomId: id,
      cultureId,
      language,
      phrase,
      literalTranslation,
      meaning,
      contextNotes,
      politenessLevel,
      examples,
      lastUpdated: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error updating idiom:', error);
    res.status(500).json({ message: 'Failed to update idiom', error: error.message });
  }
});

/**
 * DELETE /api/idioms/:id
 * Delete an idiom
 */
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check if idiom exists
    const idioms = await executeQuery(
      'SELECT COUNT(*) as count FROM Idioms WHERE IdiomID = @id',
      { id }
    );
    
    if (idioms[0].count === 0) {
      return res.status(404).json({ message: 'Idiom not found' });
    }
    
    // Delete the idiom (usage examples will be deleted due to CASCADE)
    await executeQuery(
      'DELETE FROM Idioms WHERE IdiomID = @id',
      { id }
    );
    
    res.status(204).end();
  } catch (error) {
    console.error('Error deleting idiom:', error);
    res.status(500).json({ message: 'Failed to delete idiom', error: error.message });
  }
});

module.exports = router;
</file>

<file path="server/routes/index.js">
/**
 * Routes index file
 * Exports all route modules
 */

const express = require('express');
const router = express.Router();
const adminRoutes = require('./admin');
const cultureRoutes = require('./cultures');
const normRoutes = require('./norms');
const idiomRoutes = require('./idioms');
const analysisRoutes = require('./analysis');

// Mount the admin routes
router.use('/admin', adminRoutes);

// Mount the API routes
router.use('/api/cultures', cultureRoutes);
router.use('/api/norms', normRoutes);
router.use('/api/idioms', idiomRoutes);
router.use('/api/analysis', analysisRoutes);

// Export the router
module.exports = router;
</file>

<file path="server/routes/norms.js">
/**
 * Cultural Norms API Routes
 */

const express = require('express');
const router = express.Router();
const { executeQuery } = require('../utils/database');
const { v4: uuidv4 } = require('uuid');

/**
 * GET /api/norms
 * Get all cultural norms, optionally filtered by culture
 */
router.get('/', async (req, res) => {
  try {
    const { cultureId, category } = req.query;
    let query = 'SELECT * FROM CulturalNorms';
    const params = {};
    
    // Apply filters if provided
    if (cultureId || category) {
      query += ' WHERE';
      
      if (cultureId) {
        query += ' CultureID = @cultureId';
        params.cultureId = cultureId;
      }
      
      if (cultureId && category) {
        query += ' AND';
      }
      
      if (category) {
        query += ' Category = @category';
        params.category = category;
      }
    }
    
    const norms = await executeQuery(query, params);
    res.json(norms);
  } catch (error) {
    console.error('Error getting cultural norms:', error);
    res.status(500).json({ message: 'Failed to get cultural norms', error: error.message });
  }
});

/**
 * GET /api/norms/:id
 * Get a cultural norm by ID
 */
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const norms = await executeQuery(
      'SELECT * FROM CulturalNorms WHERE NormID = @id',
      { id }
    );
    
    if (norms.length === 0) {
      return res.status(404).json({ message: 'Cultural norm not found' });
    }
    
    res.json(norms[0]);
  } catch (error) {
    console.error('Error getting cultural norm:', error);
    res.status(500).json({ message: 'Failed to get cultural norm', error: error.message });
  }
});

/**
 * POST /api/norms
 * Create a new cultural norm
 */
router.post('/', async (req, res) => {
  try {
    const { 
      cultureId, 
      category, 
      subCategory, 
      description, 
      doBehavior, 
      dontBehavior, 
      explanation, 
      severityLevel 
    } = req.body;
    
    // Validate required fields
    if (!cultureId || !category || !description || !doBehavior || !dontBehavior || !explanation || !severityLevel) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Check if the culture exists
    const cultures = await executeQuery(
      'SELECT COUNT(*) as count FROM Cultures WHERE CultureID = @cultureId',
      { cultureId }
    );
    
    if (cultures[0].count === 0) {
      return res.status(404).json({ message: 'Culture not found' });
    }
    
    // Generate UUID
    const normId = `norm-${uuidv4()}`;
    
    await executeQuery(
      `INSERT INTO CulturalNorms (
        NormID, CultureID, Category, SubCategory, Description, 
        DoBehavior, DontBehavior, Explanation, SeverityLevel, LastUpdated
      ) VALUES (
        @normId, @cultureId, @category, @subCategory, @description,
        @doBehavior, @dontBehavior, @explanation, @severityLevel, GETDATE()
      )`,
      {
        normId,
        cultureId,
        category,
        subCategory: subCategory || null,
        description,
        doBehavior,
        dontBehavior,
        explanation,
        severityLevel
      }
    );
    
    res.status(201).json({ 
      normId,
      cultureId,
      category,
      subCategory,
      description,
      doBehavior,
      dontBehavior,
      explanation,
      severityLevel,
      lastUpdated: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error creating cultural norm:', error);
    res.status(500).json({ message: 'Failed to create cultural norm', error: error.message });
  }
});

/**
 * PUT /api/norms/:id
 * Update a cultural norm
 */
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { 
      cultureId, 
      category, 
      subCategory, 
      description, 
      doBehavior, 
      dontBehavior, 
      explanation, 
      severityLevel 
    } = req.body;
    
    // Check if norm exists
    const norms = await executeQuery(
      'SELECT COUNT(*) as count FROM CulturalNorms WHERE NormID = @id',
      { id }
    );
    
    if (norms[0].count === 0) {
      return res.status(404).json({ message: 'Cultural norm not found' });
    }
    
    // Update the norm
    await executeQuery(
      `UPDATE CulturalNorms 
       SET CultureID = @cultureId,
           Category = @category,
           SubCategory = @subCategory,
           Description = @description,
           DoBehavior = @doBehavior,
           DontBehavior = @dontBehavior,
           Explanation = @explanation,
           SeverityLevel = @severityLevel,
           LastUpdated = GETDATE()
       WHERE NormID = @id`,
      {
        id,
        cultureId,
        category,
        subCategory: subCategory || null,
        description,
        doBehavior,
        dontBehavior,
        explanation,
        severityLevel
      }
    );
    
    res.json({
      normId: id,
      cultureId,
      category,
      subCategory,
      description,
      doBehavior,
      dontBehavior,
      explanation,
      severityLevel,
      lastUpdated: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error updating cultural norm:', error);
    res.status(500).json({ message: 'Failed to update cultural norm', error: error.message });
  }
});

/**
 * DELETE /api/norms/:id
 * Delete a cultural norm
 */
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check if norm exists
    const norms = await executeQuery(
      'SELECT COUNT(*) as count FROM CulturalNorms WHERE NormID = @id',
      { id }
    );
    
    if (norms[0].count === 0) {
      return res.status(404).json({ message: 'Cultural norm not found' });
    }
    
    // Delete the norm
    await executeQuery(
      'DELETE FROM CulturalNorms WHERE NormID = @id',
      { id }
    );
    
    res.status(204).end();
  } catch (error) {
    console.error('Error deleting cultural norm:', error);
    res.status(500).json({ message: 'Failed to delete cultural norm', error: error.message });
  }
});

module.exports = router;
</file>

<file path="server/scripts/deploy-cloud.sh">
#!/bin/bash

# Cloud Deployment Script for Cultural AI Navigator Backend

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${GREEN}=== Cultural AI Navigator - Cloud Deployment Script ===${NC}"
echo

# Default values
CLOUD_PROVIDER="azure"
ENVIRONMENT="production"
SERVER_DIR="."

# Process command line arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -p|--provider) CLOUD_PROVIDER="$2"; shift ;;
        -e|--environment) ENVIRONMENT="$2"; shift ;;
        -d|--directory) SERVER_DIR="$2"; shift ;;
        -h|--help)
            echo "Usage: $0 [options]"
            echo "Options:"
            echo "  -p, --provider PROVIDER    Cloud provider (azure, aws, heroku) (default: azure)"
            echo "  -e, --environment ENV      Deployment environment (production, staging) (default: production)"
            echo "  -d, --directory DIR        Path to server directory (default: .)"
            echo "  -h, --help                 Show this help message"
            exit 0
            ;;
        *) echo "Unknown parameter: $1"; exit 1 ;;
    esac
    shift
done

# Check if server directory exists
if [ ! -d "$SERVER_DIR" ]; then
    echo -e "${RED}Error: Server directory '$SERVER_DIR' not found.${NC}"
    exit 1
fi

# Navigate to server directory
cd "$SERVER_DIR"

echo -e "${GREEN}Deploying to $CLOUD_PROVIDER ($ENVIRONMENT)...${NC}"

# Deploy based on cloud provider
case $CLOUD_PROVIDER in
    azure)
        echo -e "${GREEN}Deploying to Azure App Service...${NC}"
        
        # Check if Azure CLI is installed
        if ! command -v az &> /dev/null; then
            echo -e "${RED}Error: Azure CLI not found. Please install Azure CLI first.${NC}"
            echo -e "Visit: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli"
            exit 1
        fi
        
        # Check if user is logged in
        az account show &> /dev/null
        if [ $? -ne 0 ]; then
            echo -e "${YELLOW}You need to log in to Azure first.${NC}"
            az login
        fi
        
        # Create a deployment package
        echo -e "${GREEN}Creating deployment package...${NC}"
        zip -r ../server-deployment.zip . -x "node_modules/*" "*.git*"

        echo -e "${YELLOW}Now you need to upload the deployment package to Azure.${NC}"
        echo -e "You can use the following command (replace with your resource group and app name):"
        echo -e "az webapp deploy --resource-group <resource-group> --name <app-name> --src-path ../server-deployment.zip"
        echo
        echo -e "${YELLOW}Remember to configure environment variables in the Azure Portal.${NC}"
        echo -e "See server/docs/cloud-deployment.md for details on required environment variables."
        ;;
        
    aws)
        echo -e "${GREEN}Deploying to AWS Elastic Beanstalk...${NC}"
        
        # Check if EB CLI is installed
        if ! command -v eb &> /dev/null; then
            echo -e "${RED}Error: Elastic Beanstalk CLI not found. Please install EB CLI first.${NC}"
            echo -e "Run: pip install awsebcli"
            exit 1
        fi
        
        # Initialize EB if needed
        if [ ! -f .elasticbeanstalk/config.yml ]; then
            echo -e "${YELLOW}Elastic Beanstalk environment not initialized. Initializing now...${NC}"
            eb init
        fi
        
        # Deploy to EB
        echo -e "${GREEN}Deploying to Elastic Beanstalk...${NC}"
        eb deploy
        
        echo -e "${YELLOW}Remember to configure environment variables in the EB Console.${NC}"
        echo -e "See server/docs/cloud-deployment.md for details on required environment variables."
        ;;
        
    heroku)
        echo -e "${GREEN}Deploying to Heroku...${NC}"
        
        # Check if Heroku CLI is installed
        if ! command -v heroku &> /dev/null; then
            echo -e "${RED}Error: Heroku CLI not found. Please install Heroku CLI first.${NC}"
            echo -e "Visit: https://devcenter.heroku.com/articles/heroku-cli"
            exit 1
        fi
        
        # Check if user is logged in
        heroku auth:whoami &> /dev/null
        if [ $? -ne 0 ]; then
            echo -e "${YELLOW}You need to log in to Heroku first.${NC}"
            heroku login
        fi
        
        # Check if git is initialized
        if [ ! -d .git ]; then
            echo -e "${YELLOW}Git repository not initialized. Initializing now...${NC}"
            git init
            git add .
            git commit -m "Initial commit for Heroku deployment"
        fi
        
        # Check if Heroku app exists
        if ! heroku apps:info &> /dev/null; then
            echo -e "${YELLOW}Heroku app not found. Creating a new app...${NC}"
            heroku create
        fi
        
        # Deploy to Heroku
        echo -e "${GREEN}Deploying to Heroku...${NC}"
        git push heroku main
        
        echo -e "${YELLOW}Remember to configure environment variables in Heroku.${NC}"
        echo -e "See server/docs/cloud-deployment.md for details on required environment variables."
        ;;
        
    docker)
        echo -e "${GREEN}Building Docker image...${NC}"
        
        # Check if Docker is installed
        if ! command -v docker &> /dev/null; then
            echo -e "${RED}Error: Docker not found. Please install Docker first.${NC}"
            exit 1
        fi
        
        # Build Docker image
        docker build -t culturalai-server .
        
        echo -e "${GREEN}Docker image built successfully.${NC}"
        echo -e "${YELLOW}You can run the container with:${NC}"
        echo -e "docker run -p 3000:3000 -p 3443:3443 --env-file .env culturalai-server"
        ;;
        
    *)
        echo -e "${RED}Error: Unsupported cloud provider: $CLOUD_PROVIDER${NC}"
        echo "Supported providers: azure, aws, heroku, docker"
        exit 1
        ;;
esac

echo
echo -e "${GREEN}Deployment script completed.${NC}"
</file>

<file path="server/scripts/setup-cloud-database.js">
/**
 * Cloud Database Setup Script
 * 
 * This script can be used to set up the database schema in a cloud environment.
 * It reads the SQL file and executes it against the configured database.
 */

const fs = require('fs');
const path = require('path');
const sql = require('mssql');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Check for required environment variables
const requiredEnvVars = ['DB_CONNECTION_STRING', 'DB_SERVER', 'DB_USER', 'DB_PASSWORD'];
const missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);

if (missingEnvVars.length > 0) {
  console.error('Missing required environment variables:', missingEnvVars.join(', '));
  console.error('Please set these environment variables and try again.');
  process.exit(1);
}

// Read the SQL file
const sqlFilePath = path.resolve(__dirname, '../../create_database.sql');
const sqlScript = fs.readFileSync(sqlFilePath, 'utf8');

// Split the SQL script into individual statements
const statements = sqlScript
  .replace(/(\r\n|\n|\r)/gm, ' ') // Replace newlines with spaces
  .replace(/\/\*.*?\*\//g, '') // Remove comments
  .split(';') // Split on semicolon
  .map(statement => statement.trim())
  .filter(statement => statement.length > 0); // Remove empty statements

async function setupDatabase() {
  let pool;

  try {
    console.log('Connecting to database...');
    
    // Connect to the database
    if (process.env.DB_CONNECTION_STRING) {
      pool = await sql.connect(process.env.DB_CONNECTION_STRING);
    } else {
      // Use individual connection parameters if no connection string is provided
      pool = await sql.connect({
        server: process.env.DB_SERVER,
        user: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME || 'master',
        options: {
          trustServerCertificate: process.env.DB_TRUST_SERVER_CERTIFICATE === 'true'
        }
      });
    }

    console.log('Connected to database.');

    // Check if the CulturalAI database already exists
    const dbExistsResult = await pool.request().query("SELECT COUNT(*) as count FROM sys.databases WHERE name = 'CulturalAI'");
    const dbExists = dbExistsResult.recordset[0].count > 0;

    if (dbExists) {
      console.log('CulturalAI database already exists.');
    } else {
      console.log('Creating CulturalAI database...');
      
      // Execute each statement
      for (const statement of statements) {
        if (statement.length > 0) {
          try {
            await pool.request().query(statement);
            console.log('Executed statement:', statement.substring(0, 50) + '...');
          } catch (err) {
            console.error('Error executing statement:', statement.substring(0, 100));
            console.error('Error details:', err.message);
            // Continue with the next statement
          }
        }
      }
      
      console.log('Database setup complete.');
    }

    // Verify if tables exist
    try {
      const result = await pool.request().query(`
        SELECT COUNT(*) as table_count 
        FROM CulturalAI.INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_TYPE = 'BASE TABLE'
      `);
      
      console.log(`Number of tables in CulturalAI database: ${result.recordset[0].table_count}`);
    } catch (err) {
      console.error('Error checking tables:', err.message);
    }

  } catch (err) {
    console.error('Database setup error:', err.message);
    process.exit(1);
  } finally {
    if (pool) {
      await pool.close();
      console.log('Database connection closed.');
    }
  }
}

setupDatabase().catch(err => {
  console.error('Unhandled error:', err);
  process.exit(1);
});
</file>

<file path="server/test/auth.test.js">
const assert = require('assert');
const { describe, it, beforeEach, afterEach } = require('mocha');
const request = require('supertest');

// This would normally point to your actual server app
// For testing, we can use a reference or a test-specific instance
let app;

describe('Authentication Endpoints', () => {
  beforeEach(() => {
    // This is just a placeholder for the actual server setup
    // In a real test, you'd import your Express app or create a test instance
    console.log('Setting up individual test...');
    
    // Placeholder for actual app import
    app = {
      // Mock implementation for testing purposes
      // In a real test, this would be your actual Express app
    };
  });

  afterEach(() => {
    console.log('Cleaning up after test...');
    // Any cleanup needed after each test
  });

  // Example test for signup endpoint
  it('should create a new user when valid data is provided to signup', async () => {
    // This is an example test skeleton
    // In a real test, you would use supertest to make a request

    /*
    // Example of how the actual test would look:
    const response = await request(app)
      .post('/auth/signup')
      .send({
        email: 'test@example.com',
        password: 'Password123!'
      });
    
    assert.strictEqual(response.status, 201);
    assert.strictEqual(response.body.success, true);
    */
    
    // For now, we'll just pass the test
    assert.strictEqual(1, 1);
  });

  // Example test for login endpoint
  it('should authenticate a user with valid credentials', async () => {
    // Placeholder for login test
    
    /*
    // Example of how the actual test would look:
    const response = await request(app)
      .post('/auth/login')
      .send({
        email: 'test@example.com',
        password: 'Password123!'
      });
    
    assert.strictEqual(response.status, 200);
    assert.ok(response.body.token, 'Response should contain a token');
    */
    
    // For now, we'll just pass the test
    assert.strictEqual(1, 1);
  });

  // Example test for logout endpoint
  it('should invalidate a user session on logout', async () => {
    // Placeholder for logout test
    
    /*
    // Example of how the actual test would look:
    // First login to get a token
    const loginResponse = await request(app)
      .post('/auth/login')
      .send({
        email: 'test@example.com',
        password: 'Password123!'
      });
      
    const token = loginResponse.body.token;
    
    // Then use that token to logout
    const response = await request(app)
      .post('/auth/logout')
      .set('Authorization', `Bearer ${token}`);
    
    assert.strictEqual(response.status, 200);
    assert.strictEqual(response.body.success, true);
    */
    
    // For now, we'll just pass the test
    assert.strictEqual(1, 1);
  });
});
</file>

<file path="server/test/setup.js">
// Test setup for server tests
const { before, after } = require('mocha');

// Mock global values and configurations for testing
process.env.NODE_ENV = 'test';
process.env.JWT_SECRET = 'test-secret';
process.env.PORT = '3001';

// Place to set up any global test resources
before(async function() {
  // Setup code to run before any tests
  console.log('Setting up test environment...');
});

// Place to clean up any global test resources
after(async function() {
  // Cleanup code to run after all tests
  console.log('Cleaning up test environment...');
});
</file>

<file path="server/utils/database.js">
const sql = require('mssql');
const dotenv = require('dotenv');
const path = require('path');
const fs = require('fs');
const logger = require('./logger');

// Load environment variables from database.env at the project root
const dbEnvPath = path.resolve(__dirname, '../../database.env');
if (fs.existsSync(dbEnvPath)) {
  logger.info('Loading database configuration from database.env');
  dotenv.config({ path: dbEnvPath });
}

// Database connection pool
let pool = null;

/**
 * Initialize the database connection pool
 */
async function initializePool() {
  try {
    if (pool) {
      logger.info('Database pool already exists, closing before reinitializing');
      await pool.close();
    }

    // Use connection string if available, otherwise build from components
    const config = process.env.DB_CONNECTION_STRING 
      ? { connectionString: process.env.DB_CONNECTION_STRING }
      : {
          server: process.env.DB_SERVER || 'localhost',
          database: process.env.DB_NAME || 'CulturalAI',
          // Using Windows Authentication
          options: {
            trustedConnection: true,
            trustServerCertificate: process.env.DB_TRUST_SERVER_CERTIFICATE === 'true' || true,
            encrypt: false
          }
        };

    logger.info('Initializing database connection pool');
    pool = await sql.connect(config);
    logger.info('Database connection pool initialized successfully');
    
    return pool;
  } catch (error) {
    logger.error('Failed to initialize database connection pool', { 
      error: error.message,
      stack: error.stack
    });
    throw error;
  }
}

/**
 * Get the database connection pool, initializing if necessary
 */
async function getPool() {
  if (!pool) {
    return await initializePool();
  }
  return pool;
}

/**
 * Execute a database query
 * @param {string} query - SQL query string
 * @param {Object} params - Query parameters
 */
async function executeQuery(query, params = {}) {
  try {
    const dbPool = await getPool();
    const request = dbPool.request();

    // Add parameters to the request
    Object.entries(params).forEach(([key, value]) => {
      request.input(key, value);
    });

    const result = await request.query(query);
    return result;
  } catch (error) {
    logger.error('Database query error', { 
      error: error.message,
      query: query,
      params: JSON.stringify(params),
      stack: error.stack
    });
    throw error;
  }
}

module.exports = {
  initializePool,
  getPool,
  executeQuery
};
</file>

<file path="server/utils/dataRetention.js">
/**
 * Data Retention Policy Utilities
 * 
 * This module provides functions to implement data retention policies
 * for the Cultural AI application.
 */

const { anonymizePII } = require('./encryption');

// Configuration for data retention periods (in milliseconds)
const RETENTION_PERIODS = {
  // For MVP, we're not storing analyzed text beyond the session
  ANALYZED_TEXT: 0, // 0 means don't store at all
  
  // For future implementation
  USER_ACTIVITY_LOGS: 90 * 24 * 60 * 60 * 1000, // 90 days
  FEEDBACK_DATA: 365 * 24 * 60 * 60 * 1000, // 1 year
};

/**
 * Determines if data should be retained based on its type and age
 * 
 * @param {string} dataType - Type of data (e.g., 'ANALYZED_TEXT')
 * @param {Date} creationDate - When the data was created
 * @returns {boolean} - True if data should be retained, false if it should be deleted
 */
function shouldRetainData(dataType, creationDate) {
  if (!RETENTION_PERIODS[dataType]) {
    // If no specific retention period is defined, retain by default
    return true;
  }
  
  // If retention period is 0, don't retain at all
  if (RETENTION_PERIODS[dataType] === 0) {
    return false;
  }
  
  const now = new Date();
  const ageInMs = now - creationDate;
  
  return ageInMs <= RETENTION_PERIODS[dataType];
}

/**
 * Processes text according to data retention policy
 * For analyzed text in MVP, we don't store it at all
 * 
 * @param {string} text - The text to process
 * @param {string} dataType - Type of data (e.g., 'ANALYZED_TEXT')
 * @returns {string|null} - Processed text according to retention policy, or null if it shouldn't be stored
 */
function processTextForStorage(text, dataType = 'ANALYZED_TEXT') {
  // For analyzed text in MVP, don't store at all
  if (dataType === 'ANALYZED_TEXT' && RETENTION_PERIODS[dataType] === 0) {
    return null;
  }
  
  // For other types of data, anonymize PII before storage
  return anonymizePII(text);
}

/**
 * Creates a logger that respects data retention policies
 * 
 * @param {Object} options - Logger options
 * @returns {Function} - A logging function that respects data retention policies
 */
function createPrivacyAwareLogger(options = {}) {
  return function log(message, data = {}, dataType = 'ANALYZED_TEXT') {
    // For analyzed text, don't log the actual content
    if (dataType === 'ANALYZED_TEXT') {
      // Log metadata only, not the actual text
      console.log(message, {
        timestamp: new Date().toISOString(),
        dataType,
        contentLength: data.text ? data.text.length : 0,
        // Include other non-sensitive metadata
        ...Object.fromEntries(
          Object.entries(data).filter(([key]) => key !== 'text')
        )
      });
      return;
    }
    
    // For other types of data, anonymize before logging
    const safeData = { ...data };
    if (safeData.text) {
      safeData.text = anonymizePII(safeData.text);
    }
    
    console.log(message, {
      timestamp: new Date().toISOString(),
      dataType,
      ...safeData
    });
  };
}

// Create a privacy-aware logger instance
const privacyLogger = createPrivacyAwareLogger();

module.exports = {
  shouldRetainData,
  processTextForStorage,
  createPrivacyAwareLogger,
  privacyLogger,
  RETENTION_PERIODS
};
</file>

<file path="server/utils/encryption.js">
/**
 * Encryption utilities for securing sensitive data at rest
 */
const crypto = require('crypto');

// Encryption key and initialization vector should be stored securely
// In production, these should be in environment variables
const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'a-32-character-string-for-aes256key'; // Must be 32 bytes for aes-256-gcm
const IV_LENGTH = 16; // For AES, this is always 16 bytes

/**
 * Encrypts text using AES-256-GCM
 * 
 * @param {string} text - The text to encrypt
 * @returns {string} - Encrypted text as hex string with IV prepended
 */
function encrypt(text) {
  if (!text) return null;
  
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv('aes-256-gcm', Buffer.from(ENCRYPTION_KEY), iv);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  // Get the authentication tag
  const authTag = cipher.getAuthTag().toString('hex');
  
  // Return iv + authTag + encrypted data
  // Format: iv:authTag:encryptedData
  return `${iv.toString('hex')}:${authTag}:${encrypted}`;
}

/**
 * Decrypts text using AES-256-GCM
 * 
 * @param {string} encryptedText - The text to decrypt (format: iv:authTag:encryptedData)
 * @returns {string} - Decrypted text
 */
function decrypt(encryptedText) {
  if (!encryptedText) return null;
  
  const parts = encryptedText.split(':');
  if (parts.length !== 3) {
    throw new Error('Invalid encrypted text format');
  }
  
  const iv = Buffer.from(parts[0], 'hex');
  const authTag = Buffer.from(parts[1], 'hex');
  const encryptedData = parts[2];
  
  const decipher = crypto.createDecipheriv('aes-256-gcm', Buffer.from(ENCRYPTION_KEY), iv);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

/**
 * Hashes text using SHA-256 (for non-reversible hashing)
 * 
 * @param {string} text - The text to hash
 * @returns {string} - Hashed text
 */
function hash(text) {
  if (!text) return null;
  return crypto.createHash('sha256').update(text).digest('hex');
}

/**
 * Anonymizes personally identifiable information (PII) in text
 * This is a simple implementation - in production, use more sophisticated NLP techniques
 * 
 * @param {string} text - The text to anonymize
 * @returns {string} - Anonymized text
 */
function anonymizePII(text) {
  if (!text) return null;
  
  // Simple pattern replacements for common PII
  // In production, use more sophisticated NLP-based entity recognition
  let anonymized = text;
  
  // Replace email patterns
  anonymized = anonymized.replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, '[EMAIL]');
  
  // Replace phone number patterns (simple version)
  anonymized = anonymized.replace(/(\+\d{1,3}[\s.-])?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}/g, '[PHONE]');
  
  // Replace common name patterns (very simplistic approach)
  anonymized = anonymized.replace(/(?:Mr\.|Mrs\.|Ms\.|Dr\.) [A-Z][a-z]+ [A-Z][a-z]+/g, '[NAME]');
  
  return anonymized;
}

module.exports = {
  encrypt,
  decrypt,
  hash,
  anonymizePII
};
</file>

<file path="server/utils/logger.js">
/**
 * Logger utility for the application
 */
const winston = require('winston');
const path = require('path');
const fs = require('fs');

// Create logs directory if it doesn't exist
const logsDir = path.join(__dirname, '../logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

// Define log format
const logFormat = winston.format.printf(({ level, message, timestamp, ...meta }) => {
  return `${timestamp} ${level}: ${message} ${Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''}`;
});

// Create logger
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    logFormat
  ),
  defaultMeta: { service: 'cultural-ai' },
  transports: [
    // Write all logs to console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        logFormat
      )
    }),
    // Write all logs to files
    new winston.transports.File({ 
      filename: path.join(logsDir, 'error.log'), 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: path.join(logsDir, 'combined.log') 
    })
  ],
  exceptionHandlers: [
    new winston.transports.File({ 
      filename: path.join(logsDir, 'exceptions.log') 
    })
  ]
});

module.exports = logger;
</file>

<file path="server/utils/openai.js">
/**
 * OpenAI API Integration
 */
const OpenAI = require('openai');
const dotenv = require('dotenv');
const logger = require('./logger');

// Load environment variables
dotenv.config();

// Check if API key is set
if (!process.env.OPENAI_API_KEY && !process.env.AI_SERVICE_API_KEY) {
  logger.warn('OpenAI API key is not set. Cultural analysis features will not work properly.');
}

// OpenAI configuration
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || process.env.AI_SERVICE_API_KEY,
});

const defaultModel = process.env.OPENAI_MODEL || 'gpt-3.5-turbo';

/**
 * Analyze text for cultural appropriateness
 * 
 * @param {string} text - The text to analyze
 * @param {string} cultureId - The ID of the culture for context
 * @param {string} cultureName - The name of the culture
 * @param {string} textOrigin - Whether this is the user's text ('mine') or someone else's ('theirs')
 * @returns {Promise<object>} - Analysis results
 */
async function analyzeCulturalContext(text, cultureId, cultureName, textOrigin = 'mine') {
  try {
    if (!process.env.OPENAI_API_KEY && !process.env.AI_SERVICE_API_KEY) {
      return mockAnalysis(text, cultureName, textOrigin);
    }

    const prompt = `
You are a cultural intelligence expert who helps people communicate effectively across different cultures.

I need you to analyze the following text in the context of ${cultureName} culture.
The text is ${textOrigin === 'mine' ? 'something I wrote' : 'written by someone from this culture'}.

Text to analyze: "${text}"

Provide analysis in the following JSON format:
{
  "summary": "Brief summary of your analysis",
  "issues": [
    {
      "type": "Type of issue (Idiom, Formality, Directness, etc.)",
      "text": "The specific text that raised this issue",
      "explanation": "Explanation of why this might be an issue in this cultural context",
      "suggestion": "Suggested alternative if appropriate"
    }
  ],
  "alternatives": [
    "Alternative phrasings that would be more culturally appropriate"
  ]
}

If no issues are found, return an appropriate message in the summary and an empty issues array.
`;

    const response = await openai.chat.completions.create({
      model: defaultModel,
      messages: [
        { role: 'system', content: 'You are a cultural intelligence expert who helps with cross-cultural communication.' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.7,
      max_tokens: 800,
    });

    const analysisText = response.choices[0].message.content.trim();
    const analysis = JSON.parse(analysisText);
    
    return analysis;
  } catch (error) {
    logger.error('Error in OpenAI analysis:', error);
    return {
      summary: 'Error analyzing text. Please try again later.',
      issues: [],
      alternatives: []
    };
  }
}

/**
 * Translate an idiom between cultures
 * 
 * @param {string} idiom - The idiom to translate
 * @param {string} sourceCulture - The source culture
 * @param {string} targetCulture - The target culture
 * @returns {Promise<object>} - Translation results
 */
async function translateIdiom(idiom, sourceCulture, targetCulture) {
  try {
    if (!process.env.OPENAI_API_KEY && !process.env.AI_SERVICE_API_KEY) {
      return {
        originalIdiom: idiom,
        translation: 'API key not configured. Translation unavailable.',
        explanation: 'Please configure the OpenAI API key to use this feature.',
        culturalNotes: []
      };
    }

    const prompt = `
Translate the following idiom from ${sourceCulture} culture to an equivalent in ${targetCulture} culture.

Idiom: "${idiom}"

Provide the translation in the following JSON format:
{
  "originalIdiom": "${idiom}",
  "translation": "The closest equivalent idiom in ${targetCulture} culture",
  "literalTranslation": "The literal translation of the original idiom",
  "explanation": "Explanation of the meaning and how it relates to the original",
  "culturalNotes": [
    "Important cultural notes or context about this idiom",
    "Any usage guidelines or warnings"
  ]
}

If there is no clear equivalent, suggest the closest concept and explain the differences.
`;

    const response = await openai.chat.completions.create({
      model: defaultModel,
      messages: [
        { role: 'system', content: 'You are a linguistic expert specializing in cross-cultural idioms and expressions.' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.7,
      max_tokens: 500,
    });

    const translationText = response.choices[0].message.content.trim();
    const translation = JSON.parse(translationText);
    
    return translation;
  } catch (error) {
    logger.error('Error in idiom translation:', error);
    return {
      originalIdiom: idiom,
      translation: 'Error translating idiom. Please try again later.',
      explanation: 'An error occurred during translation.',
      culturalNotes: []
    };
  }
}

/**
 * Mock analysis for when API key is not available
 * @private
 */
function mockAnalysis(text, cultureName, textOrigin) {
  const mockAnalysis = {
    summary: `Analysis of text in relation to ${cultureName} culture.`,
    issues: []
  };
  
  // Check for idioms (very simplified)
  if (text.toLowerCase().includes('break a leg') || text.toLowerCase().includes('piece of cake')) {
    mockAnalysis.issues.push({
      type: 'Idiom',
      text: text.toLowerCase().includes('break a leg') ? 'break a leg' : 'piece of cake',
      explanation: 'This English idiom may not translate well in other cultures and could be confusing.',
      suggestion: 'Consider using more direct language instead of idioms when communicating across cultures.'
    });
  }
  
  // Check for formality issues (very simplified)
  if (text.toLowerCase().includes('hey') || text.toLowerCase().includes('whats up')) {
    mockAnalysis.issues.push({
      type: 'Formality',
      text: text.toLowerCase().includes('hey') ? 'hey' : 'whats up',
      explanation: 'This greeting is too casual for formal or initial business interactions in many cultures.',
      suggestion: 'Consider "Good morning/afternoon" or "Hello" for a more universally appropriate greeting.'
    });
  }
  
  // If no specific issues found, add a general note
  if (mockAnalysis.issues.length === 0) {
    mockAnalysis.issues.push({
      type: 'General',
      text: '(No specific issues detected)',
      explanation: 'No obvious cultural concerns detected in the provided text. However, always consider context and relationship with the recipient.'
    });
  }
  
  // Add alternative phrasings if appropriate (for user's own text)
  if (textOrigin === 'mine' && text.length > 10) {
    mockAnalysis.alternatives = [
      'A more culturally adapted version might be: "' + text.replace(/hey/i, 'Hello').replace(/whats up/i, 'How are you') + '"',
      'For formal contexts: "' + text.replace(/break a leg/i, 'I wish you success').replace(/piece of cake/i, 'very straightforward') + '"'
    ];
  }
  
  return mockAnalysis;
}

// Export functions
module.exports = {
  analyzeCulturalContext,
  translateIdiom
};
</file>

<file path="server/utils/validation.js">
/**
 * Validation utilities for Cultural Knowledge Base (CKB) data inputs
 * Contains validation rules for all CKB entities
 */

// Validation rules for Culture entity
const validateCulture = (culture) => {
  const errors = [];
  
  // Required fields
  if (!culture.CultureName || culture.CultureName.trim() === '') {
    errors.push('Culture name is required');
  } else if (culture.CultureName.length > 100) {
    errors.push('Culture name must be 100 characters or less');
  }
  
  if (!culture.Region || culture.Region.trim() === '') {
    errors.push('Region is required');
  } else if (culture.Region.length > 100) {
    errors.push('Region must be 100 characters or less');
  }
  
  if (!culture.PrimaryLanguage || culture.PrimaryLanguage.trim() === '') {
    errors.push('Primary language is required');
  } else if (culture.PrimaryLanguage.length > 100) {
    errors.push('Primary language must be 100 characters or less');
  }
  
  if (!culture.Description || culture.Description.trim() === '') {
    errors.push('Description is required');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

// Validation rules for CulturalNorm entity
const validateCulturalNorm = (norm) => {
  const errors = [];
  
  // Required fields
  if (!norm.CultureID || norm.CultureID.trim() === '') {
    errors.push('Culture ID is required');
  }
  
  if (!norm.Category || norm.Category.trim() === '') {
    errors.push('Category is required');
  } else if (norm.Category.length > 50) {
    errors.push('Category must be 50 characters or less');
  }
  
  // SubCategory is optional but has length constraint
  if (norm.SubCategory && norm.SubCategory.length > 100) {
    errors.push('SubCategory must be 100 characters or less');
  }
  
  if (!norm.Description || norm.Description.trim() === '') {
    errors.push('Description is required');
  }
  
  if (!norm.DoBehavior || norm.DoBehavior.trim() === '') {
    errors.push('Do behavior is required');
  }
  
  if (!norm.DontBehavior || norm.DontBehavior.trim() === '') {
    errors.push('Don\'t behavior is required');
  }
  
  if (!norm.Explanation || norm.Explanation.trim() === '') {
    errors.push('Explanation is required');
  }
  
  if (!norm.SeverityLevel || norm.SeverityLevel.trim() === '') {
    errors.push('Severity level is required');
  } else if (!['Low', 'Medium', 'High'].includes(norm.SeverityLevel)) {
    errors.push('Severity level must be one of: Low, Medium, High');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

// Validation rules for Idiom entity
const validateIdiom = (idiom) => {
  const errors = [];
  
  // Required fields
  if (!idiom.CultureID || idiom.CultureID.trim() === '') {
    errors.push('Culture ID is required');
  }
  
  if (!idiom.Language || idiom.Language.trim() === '') {
    errors.push('Language is required');
  } else if (idiom.Language.length > 100) {
    errors.push('Language must be 100 characters or less');
  }
  
  if (!idiom.Phrase || idiom.Phrase.trim() === '') {
    errors.push('Phrase is required');
  }
  
  if (!idiom.LiteralTranslation || idiom.LiteralTranslation.trim() === '') {
    errors.push('Literal translation is required');
  }
  
  if (!idiom.Meaning || idiom.Meaning.trim() === '') {
    errors.push('Meaning is required');
  }
  
  if (!idiom.PolitenessLevel || idiom.PolitenessLevel.trim() === '') {
    errors.push('Politeness level is required');
  } else if (!['Informal', 'Neutral', 'Formal', 'Very Formal'].includes(idiom.PolitenessLevel)) {
    errors.push('Politeness level must be one of: Informal, Neutral, Formal, Very Formal');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

// Validation rules for Scenario entity
const validateScenario = (scenario) => {
  const errors = [];
  
  // Required fields
  if (!scenario.CultureID || scenario.CultureID.trim() === '') {
    errors.push('Culture ID is required');
  }
  
  if (!scenario.Category || scenario.Category.trim() === '') {
    errors.push('Category is required');
  } else if (scenario.Category.length > 100) {
    errors.push('Category must be 100 characters or less');
  }
  
  if (!scenario.Title || scenario.Title.trim() === '') {
    errors.push('Title is required');
  } else if (scenario.Title.length > 255) {
    errors.push('Title must be 255 characters or less');
  }
  
  if (!scenario.SituationDescription || scenario.SituationDescription.trim() === '') {
    errors.push('Situation description is required');
  }
  
  // ImageURL is optional but should be a valid URL if provided
  if (scenario.ImageURL && !isValidURL(scenario.ImageURL)) {
    errors.push('Image URL must be a valid URL');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

// Validation rules for ScenarioChoice entity
const validateScenarioChoice = (choice) => {
  const errors = [];
  
  // Required fields
  if (!choice.ScenarioID || choice.ScenarioID.trim() === '') {
    errors.push('Scenario ID is required');
  }
  
  if (!choice.ChoiceText || choice.ChoiceText.trim() === '') {
    errors.push('Choice text is required');
  }
  
  if (typeof choice.IsCorrectChoice !== 'boolean') {
    errors.push('IsCorrectChoice must be a boolean value');
  }
  
  if (!choice.FeedbackText || choice.FeedbackText.trim() === '') {
    errors.push('Feedback text is required');
  }
  
  if (!choice.ConsequenceDescription || choice.ConsequenceDescription.trim() === '') {
    errors.push('Consequence description is required');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

// Helper function to validate URLs
function isValidURL(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

module.exports = {
  validateCulture,
  validateCulturalNorm,
  validateIdiom,
  validateScenario,
  validateScenarioChoice
};
</file>

<file path="server/.deployment">
[config]
command = npm start
</file>

<file path="server/.gitignore">
# Dependency directories
node_modules/

# Environment variables
.env
.env.local
.env.development
.env.test
.env.production
database.env

# Log files
logs/*
!logs/.gitkeep
*.log

# Build directories
dist/
build/

# SSL certificates
certs/*.pem
certs/*.key
certs/*.crt
!certs/.gitkeep

# OS specific files
.DS_Store
Thumbs.db

# IDE specific files
.idea/
.vscode/
*.swp
*.swo
</file>

<file path="server/Dockerfile">
FROM node:18-alpine

# Create app directory
WORKDIR /usr/src/app

# Copy package files and install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy application code
COPY . .

# Create certs directory if self-signed certs are needed
RUN mkdir -p certs

# Expose both HTTP and HTTPS ports
EXPOSE 3000 3443

# Set NODE_ENV to production
ENV NODE_ENV=production

# Set health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 \
  CMD wget -qO- http://localhost:3000/api/health || exit 1

# Start the server
CMD ["npm", "start"]
</file>

<file path="server/index.js">
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');
const { promisify } = require('util');
const fs = require('fs');
const http = require('http');
const https = require('https');
const path = require('path');
const helmet = require('helmet');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Import our utilities
const { encrypt, decrypt, anonymizePII } = require('./utils/encryption');
const { privacyLogger, processTextForStorage } = require('./utils/dataRetention');
const logger = require('./utils/logger');
const routes = require('./routes'); // Import our routes

// Import middleware
const requestIdMiddleware = require('./middleware/requestId');
const requestLogger = require('./middleware/requestLogger');
const { errorHandler, notFoundHandler } = require('./middleware/errorHandler');
const clientErrorCollector = require('./middleware/clientErrorCollector');

// Create Express app
const app = express();
const PORT = process.env.PORT || 3000;
const HTTPS_PORT = process.env.HTTPS_PORT || 3443;

// Initial setup log
logger.info(`Starting server in ${process.env.NODE_ENV || 'development'} mode`);

// Request ID middleware (must be first to ensure all requests have an ID)
app.use(requestIdMiddleware);

// Middleware for security
app.use(helmet()); // Adds various HTTP headers for security
app.use(requestLogger); // Replace morgan with our custom request logger
app.use(cors());
app.use(bodyParser.json());

// Middleware to redirect HTTP to HTTPS in production
if (process.env.NODE_ENV === 'production') {
  app.use((req, res, next) => {
    if (req.secure) {
      // Request is already secure
      next();
    } else {
      // Redirect to HTTPS
      const httpsUrl = `https://${req.hostname}:${HTTPS_PORT}${req.url}`;
      res.redirect(httpsUrl);
    }
  });
}

// Secret key for JWT
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-for-development';

// Authentication middleware
const authenticate = async (req, res, next) => {
  try {
    // Get token from headers
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const token = authHeader.split(' ')[1];
    
    // Verify token
    const decoded = await promisify(jwt.verify)(token, JWT_SECRET);
    
    // Add user data to request
    req.user = decoded;
    
    next();
  } catch (error) {
    logger.error('Authentication error', { 
      error: error.message, 
      stack: error.stack,
      requestId: req.requestId
    });
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
};

// Mount our routes
app.use('/api', routes);

// Routes
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

// Client error collection endpoint
app.post('/api/client-error', clientErrorCollector);

// Text Analysis endpoint
app.post('/api/analysis/text', authenticate, (req, res) => {
  try {
    const { text, cultureId, textOrigin } = req.body;
    
    if (!text || !cultureId) {
      return res.status(400).json({ error: 'Text and culture ID are required' });
    }
    
    // In a real implementation, this would call an AI service
    // For now, we'll use a mock implementation
    
    // For MVP: Don't store any PII from text analysis
    // Log only minimal information for debugging using our privacy-aware logger
    privacyLogger('Analysis request received', {
      userId: req.user.id,
      cultureId,
      textOrigin,
      text, // This will be handled properly by the privacy logger
      requestId: req.requestId
    }, 'ANALYZED_TEXT');
    
    // Mock analysis that looks for specific patterns
    const mockAnalysis = {
      summary: `Analysis of text in relation to ${getFullCultureName(cultureId)} culture.`,
      issues: []
    };
    
    // Check for idioms (very simplified)
    if (text.toLowerCase().includes('break a leg') || text.toLowerCase().includes('piece of cake')) {
      mockAnalysis.issues.push({
        type: 'Idiom',
        text: text.toLowerCase().includes('break a leg') ? 'break a leg' : 'piece of cake',
        explanation: 'This English idiom may not translate well in other cultures and could be confusing.',
        suggestion: 'Consider using more direct language instead of idioms when communicating across cultures.',
        idiomId: 'idiom123' // In a real implementation, this would be a database ID
      });
    }
    
    // Check for formality issues (very simplified)
    if (text.toLowerCase().includes('hey') || text.toLowerCase().includes('whats up')) {
      mockAnalysis.issues.push({
        type: 'Formality',
        text: text.toLowerCase().includes('hey') ? 'hey' : 'whats up',
        explanation: 'This greeting is too casual for formal or initial business interactions in many cultures.',
        suggestion: 'Consider "Good morning/afternoon" or "Hello" for a more universally appropriate greeting.'
      });
    }
    
    // If analyzing someone else's text (interpretation aid)
    if (textOrigin === 'theirs' && text.length > 20) {
      mockAnalysis.issues.push({
        type: 'Context',
        text: '(General observation)',
        explanation: `When interpreting this message from a ${getFullCultureName(cultureId)} context, consider that communication may be more indirect. Look for subtle cues rather than explicit statements.`
      });
    }
    
    // If no specific issues found, add a general note
    if (mockAnalysis.issues.length === 0) {
      mockAnalysis.issues.push({
        type: 'General',
        text: '(No specific issues detected)',
        explanation: 'No obvious cultural concerns detected in the provided text. However, always consider context and relationship with the recipient.'
      });
    }
    
    // Add alternative phrasings if appropriate (for user's own text)
    if (textOrigin === 'mine' && text.length > 10) {
      mockAnalysis.alternatives = [
        'A more culturally adapted version might be: "' + text.replace(/hey/i, 'Hello').replace(/whats up/i, 'How are you') + '"',
        'For formal contexts: "' + text.replace(/break a leg/i, 'I wish you success').replace(/piece of cake/i, 'very straightforward') + '"'
      ];
    }
    
    // Implement data retention policy - don't store analyzed text
    // If we needed to store it temporarily, we would process it first
    const textToStore = processTextForStorage(text);
    // Since our policy is not to store, textToStore will be null
    
    // Log successful analysis
    logger.info('Text analysis completed successfully', {
      userId: req.user.id,
      cultureId,
      textOrigin,
      requestId: req.requestId,
      issuesDetected: mockAnalysis.issues.length
    });
    
    res.json(mockAnalysis);
  } catch (error) {
    logger.error('Text analysis error', { 
      error: error.message, 
      stack: error.stack,
      requestId: req.requestId,
      userId: req.user?.id
    });
    res.status(500).json({ error: 'Failed to analyze text' });
  }
});

// Helper function to get full culture name
function getFullCultureName(cultureId) {
  const cultures = {
    'jp': 'Japanese',
    'de': 'German',
    'sa': 'Saudi Arabian',
    'us': 'American',
    'cn': 'Chinese',
    'fr': 'French',
    'br': 'Brazilian',
    'in': 'Indian'
  };
  
  return cultures[cultureId] || 'selected';
}

// Data deletion request endpoint (placeholder for manual fulfillment)
app.post('/api/user/data-deletion-request', authenticate, (req, res) => {
  try {
    // In a real implementation, this would create a data deletion request
    // For MVP, we'll just log it and return success
    privacyLogger('Data deletion request received', { 
      userId: req.user.id,
      requestId: req.requestId
    }, 'USER_REQUEST');
    
    // Send confirmation email (placeholder)
    logger.info('Sending confirmation email for data deletion request', {
      userId: req.user.id,
      requestId: req.requestId
    });
    
    res.json({ 
      success: true, 
      message: 'Your data deletion request has been received. We will process it within 30 days and send you a confirmation email.'
    });
  } catch (error) {
    logger.error('Data deletion request error', { 
      error: error.message, 
      stack: error.stack,
      requestId: req.requestId,
      userId: req.user?.id
    });
    res.status(500).json({ error: 'Failed to process data deletion request' });
  }
});

// Data export request endpoint (placeholder for manual fulfillment)
app.post('/api/user/data-export-request', authenticate, (req, res) => {
  try {
    // In a real implementation, this would create a data export request
    // For MVP, we'll just log it and return success
    privacyLogger('Data export request received', { userId: req.user.id }, 'USER_REQUEST');
    
    // Send confirmation email (placeholder)
    console.log(`Sending confirmation email for data export request to user`);
    
    res.json({ 
      success: true, 
      message: 'Your data export request has been received. We will process it within 30 days and send you a confirmation email with your data.'
    });
  } catch (error) {
    console.error('Data export request error:', error);
    res.status(500).json({ error: 'Failed to process data export request' });
  }
});

// Feedback submission endpoint for reporting issues with AI analysis
app.post('/api/feedback', async (req, res) => {
  try {
    const { 
      analysisId, 
      analysisType, 
      cultureId, 
      feedbackType, 
      feedbackText,
      timestamp 
    } = req.body;
    
    // Basic validation
    if (!feedbackType || !feedbackText) {
      return res.status(400).json({ error: 'Feedback type and text are required' });
    }
    
    // Get user ID if authenticated
    let userId = 'anonymous';
    try {
      const authHeader = req.headers.authorization;
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.split(' ')[1];
        const decoded = await promisify(jwt.verify)(token, JWT_SECRET);
        userId = decoded.id;
      }
    } catch (error) {
      // Continue as anonymous if token is invalid
      console.log('Anonymous feedback submission');
    }
    
    // In a real implementation, this would store the feedback in a database
    // For MVP, we'll just log it
    privacyLogger('Feedback received', {
      userId,
      analysisId,
      analysisType,
      cultureId,
      feedbackType,
      feedbackText: anonymizePII(feedbackText), // Anonymize any PII in feedback
      timestamp
    }, 'FEEDBACK');
    
    // In a production environment, we might:
    // 1. Store the feedback in a database
    // 2. Send notifications to the team
    // 3. Create tickets in an issue tracking system
    
    res.json({
      success: true,
      message: 'Thank you for your feedback. We appreciate your help in improving our AI.'
    });
  } catch (error) {
    console.error('Feedback submission error:', error);
    res.status(500).json({ error: 'Failed to process feedback' });
  }
});

// Apply the 404 and error handling middleware (must be last)
app.use(notFoundHandler);
app.use(errorHandler);

// Function to generate self-signed certificates for HTTPS
function generateSelfSignedCerts() {
  try {
    // Check if certs directory exists and is accessible
    const certsDir = path.join(__dirname, 'certs');
    if (!fs.existsSync(certsDir)) {
      fs.mkdirSync(certsDir, { recursive: true });
    }
    
    const keyPath = path.join(certsDir, 'server.key');
    const certPath = path.join(certsDir, 'server.cert');
    
    // Check if certificates already exist
    if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
      // Use existing certificates
      return {
        key: fs.readFileSync(keyPath),
        cert: fs.readFileSync(certPath)
      };
    }
    
    // If no existing certificates found and it's production, log error
    if (process.env.NODE_ENV === 'production') {
      logger.error('HTTPS certificates not found in production', {
        certsDir,
        keyPath,
        certPath
      });
      throw new Error('HTTPS certificates required for production');
    }
    
    // For development, generate new self-signed certificates using OpenSSL
    // Note: In a real production environment, you would use properly signed certificates
    logger.warn('Generating self-signed certificates for development use only');
    
    const { execSync } = require('child_process');
    
    // Generate private key
    execSync(`openssl genrsa -out ${keyPath} 2048`);
    
    // Generate self-signed certificate
    execSync(`openssl req -new -key ${keyPath} -out ${path.join(certsDir, 'server.csr')} -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"`);
    execSync(`openssl x509 -req -days 365 -in ${path.join(certsDir, 'server.csr')} -signkey ${keyPath} -out ${certPath}`);
    
    return {
      key: fs.readFileSync(keyPath),
      cert: fs.readFileSync(certPath)
    };
  } catch (error) {
    logger.error('Error generating self-signed certificates', { 
      error: error.message, 
      stack: error.stack
    });
    
    // Return null to indicate certificates could not be generated
    return null;
  }
}

// Start the servers
http.createServer(app).listen(PORT, () => {
  logger.info(`HTTP server running on port ${PORT}`);
});

// Start HTTPS server if enabled
if (process.env.ENABLE_HTTPS !== 'false') {
  try {
    const sslOptions = generateSelfSignedCerts();
    
    if (sslOptions) {
      https.createServer(sslOptions, app).listen(HTTPS_PORT, () => {
        logger.info(`HTTPS server running on port ${HTTPS_PORT}`);
      });
    } else {
      logger.warn('HTTPS server not started due to certificate issues');
    }
  } catch (error) {
    logger.error('Failed to start HTTPS server', {
      error: error.message,
      stack: error.stack
    });
  }
}

// Graceful shutdown handler
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  // Close servers, DB connections, etc.
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully');
  // Close servers, DB connections, etc.
  process.exit(0);
});

// Uncaught exception handler
process.on('uncaughtException', (error) => {
  logger.error('Uncaught exception', {
    error: error.message,
    stack: error.stack
  });
  
  // Fatal errors should cause the application to exit after logging
  if (error.fatal) {
    process.exit(1);
  }
});

// Unhandled rejection handler
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled promise rejection', {
    reason: reason instanceof Error ? reason.message : reason,
    stack: reason instanceof Error ? reason.stack : 'No stack trace available',
    promise
  });
});
</file>

<file path="server/package.json">
{
  "name": "culturalai-server",
  "version": "1.0.0",
  "description": "Server for Cultural AI application",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "mocha --require test/setup.js 'test/**/*.test.js'",
    "test:watch": "npm test -- --watch",
    "lint": "eslint .",
    "db:setup": "node scripts/setup-cloud-database.js",
    "postinstall": "node -e \"console.log('Server installed successfully')\""
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "body-parser": "^1.20.3",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "helmet": "^7.2.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "mssql": "^11.0.1",
    "openai": "^4.98.0",
    "uuid": "^9.0.1",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "eslint": "^8.55.0",
    "mocha": "^10.2.0",
    "nodemon": "^2.0.15",
    "supertest": "^6.3.3"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="server/Procfile">
web: node index.js
</file>

<file path="src/assets/legal/privacy-policy.tsx">
import React from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { StackNavigationProp } from '@react-navigation/stack';
import { TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { RootStackParamList } from '../types/navigation';

type PrivacyPolicyScreenNavigationProp = StackNavigationProp<RootStackParamList, 'PrivacyPolicy'>;

type Props = {
  navigation: PrivacyPolicyScreenNavigationProp;
};

const PrivacyPolicyScreen: React.FC<Props> = ({ navigation }) => {
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton} 
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Privacy Policy</Text>
        <View style={styles.placeholder} />
      </View>
      
      <ScrollView style={styles.content}>
        <Text style={styles.lastUpdated}>Last Updated: {new Date().toLocaleDateString()}</Text>
        
        <Text style={styles.sectionTitle}>1. Introduction</Text>
        <Text style={styles.paragraph}>
          Welcome to Cultural Nuance Navigator. We respect your privacy and are committed to protecting your personal data. 
          This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you use our mobile application.
        </Text>
        
        <Text style={styles.sectionTitle}>2. Information We Collect</Text>
        <Text style={styles.paragraph}>
          <Text style={styles.bold}>2.1 Personal Information:</Text> When you create an account, we collect your email address and password.
        </Text>
        <Text style={styles.paragraph}>
          <Text style={styles.bold}>2.2 Usage Data:</Text> We collect information about how you interact with our app, including:
        </Text>
        <Text style={styles.bulletPoint}>• Cultures you view and select</Text>
        <Text style={styles.bulletPoint}>• Text you submit for cultural analysis</Text>
        <Text style={styles.bulletPoint}>• Features you use within the app</Text>
        <Text style={styles.paragraph}>
          <Text style={styles.bold}>2.3 Device Information:</Text> We collect information about your device, including device type, operating system, and unique device identifiers.
        </Text>
        
        <Text style={styles.sectionTitle}>3. How We Use Your Information</Text>
        <Text style={styles.paragraph}>We use your information to:</Text>
        <Text style={styles.bulletPoint}>• Provide and maintain our services</Text>
        <Text style={styles.bulletPoint}>• Improve and personalize your experience</Text>
        <Text style={styles.bulletPoint}>• Analyze text for cultural context and provide feedback</Text>
        <Text style={styles.bulletPoint}>• Communicate with you about updates or changes</Text>
        <Text style={styles.bulletPoint}>• Ensure the security of our services</Text>
        
        <Text style={styles.sectionTitle}>4. Data Storage and Security</Text>
        <Text style={styles.paragraph}>
          We implement appropriate technical and organizational measures to protect your personal information. 
          However, no method of transmission over the internet or electronic storage is 100% secure.
        </Text>
        <Text style={styles.paragraph}>
          For the MVP version, we aim for transient processing of analyzed text, meaning we do not permanently store text submitted for analysis beyond the current session.
        </Text>
        
        <Text style={styles.sectionTitle}>5. Data Sharing and Disclosure</Text>
        <Text style={styles.paragraph}>
          We do not sell your personal information. We may share information with:
        </Text>
        <Text style={styles.bulletPoint}>• Service providers who help us deliver our services</Text>
        <Text style={styles.bulletPoint}>• Legal authorities when required by law</Text>
        
        <Text style={styles.sectionTitle}>6. Your Choices</Text>
        <Text style={styles.paragraph}>
          You can:
        </Text>
        <Text style={styles.bulletPoint}>• Access and update your account information</Text>
        <Text style={styles.bulletPoint}>• Opt-out of allowing your anonymized data to be used for improving our AI models</Text>
        <Text style={styles.bulletPoint}>• Request deletion of your account and associated data</Text>
        
        <Text style={styles.sectionTitle}>7. Children's Privacy</Text>
        <Text style={styles.paragraph}>
          Our services are not intended for children under 13. We do not knowingly collect information from children under 13.
        </Text>
        
        <Text style={styles.sectionTitle}>8. Changes to This Policy</Text>
        <Text style={styles.paragraph}>
          We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new policy on this page and updating the "Last Updated" date.
        </Text>
        
        <Text style={styles.sectionTitle}>9. Contact Us</Text>
        <Text style={styles.paragraph}>
          If you have any questions about this Privacy Policy, please contact us at:
        </Text>
        <Text style={styles.paragraph}>
          privacy@culturalnuancenavigator.com
        </Text>
        
        <View style={styles.footer} />
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f9f9f9',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  lastUpdated: {
    fontSize: 14,
    color: '#666',
    marginBottom: 20,
    fontStyle: 'italic',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 24,
    marginBottom: 12,
  },
  paragraph: {
    fontSize: 16,
    color: '#444',
    lineHeight: 24,
    marginBottom: 16,
  },
  bulletPoint: {
    fontSize: 16,
    color: '#444',
    lineHeight: 24,
    marginBottom: 8,
    marginLeft: 16,
  },
  bold: {
    fontWeight: 'bold',
  },
  footer: {
    height: 40,
  },
});

export default PrivacyPolicyScreen;
</file>

<file path="src/assets/legal/terms-of-service.tsx">
import React from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { StackNavigationProp } from '@react-navigation/stack';
import { TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { RootStackParamList } from '../types/navigation';

type TermsOfServiceScreenNavigationProp = StackNavigationProp<RootStackParamList, 'TermsOfService'>;

type Props = {
  navigation: TermsOfServiceScreenNavigationProp;
};

const TermsOfServiceScreen: React.FC<Props> = ({ navigation }) => {
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton} 
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Terms of Service</Text>
        <View style={styles.placeholder} />
      </View>
      
      <ScrollView style={styles.content}>
        <Text style={styles.lastUpdated}>Last Updated: {new Date().toLocaleDateString()}</Text>
        
        <Text style={styles.sectionTitle}>1. Acceptance of Terms</Text>
        <Text style={styles.paragraph}>
          By accessing or using the Cultural Nuance Navigator mobile application, you agree to be bound by these Terms of Service. 
          If you do not agree to these terms, please do not use our application.
        </Text>
        
        <Text style={styles.sectionTitle}>2. Description of Service</Text>
        <Text style={styles.paragraph}>
          Cultural Nuance Navigator provides cultural insights, analysis of text communications in cross-cultural contexts, 
          cultural briefings, and related services to help users navigate cultural differences.
        </Text>
        
        <Text style={styles.sectionTitle}>3. User Accounts</Text>
        <Text style={styles.paragraph}>
          To use certain features of our application, you may be required to create an account. You are responsible for:
        </Text>
        <Text style={styles.bulletPoint}>• Maintaining the confidentiality of your account information</Text>
        <Text style={styles.bulletPoint}>• All activities that occur under your account</Text>
        <Text style={styles.bulletPoint}>• Notifying us immediately of any unauthorized use of your account</Text>
        
        <Text style={styles.sectionTitle}>4. User Content</Text>
        <Text style={styles.paragraph}>
          When you submit text for analysis or provide other content through our application:
        </Text>
        <Text style={styles.bulletPoint}>• You retain ownership of your content</Text>
        <Text style={styles.bulletPoint}>• You grant us a license to use, process, and analyze your content to provide our services</Text>
        <Text style={styles.bulletPoint}>• You agree not to submit content that is unlawful, offensive, or infringes on others' rights</Text>
        
        <Text style={styles.sectionTitle}>5. Intellectual Property</Text>
        <Text style={styles.paragraph}>
          The application, including all content, features, and functionality, is owned by Cultural Nuance Navigator and is protected by copyright, 
          trademark, and other intellectual property laws.
        </Text>
        
        <Text style={styles.sectionTitle}>6. Disclaimer of Warranties</Text>
        <Text style={styles.paragraph}>
          The application and all content are provided "as is" without warranty of any kind. We do not guarantee that:
        </Text>
        <Text style={styles.bulletPoint}>• The application will meet your specific requirements</Text>
        <Text style={styles.bulletPoint}>• The application will be uninterrupted, timely, secure, or error-free</Text>
        <Text style={styles.bulletPoint}>• The results from using the application will be accurate or reliable</Text>
        <Text style={styles.paragraph}>
          Cultural insights provided are general in nature and may not apply to all individuals from a particular culture.
        </Text>
        
        <Text style={styles.sectionTitle}>7. Limitation of Liability</Text>
        <Text style={styles.paragraph}>
          To the maximum extent permitted by law, we shall not be liable for any indirect, incidental, special, consequential, or punitive damages 
          resulting from your use of or inability to use the application.
        </Text>
        
        <Text style={styles.sectionTitle}>8. Changes to Terms</Text>
        <Text style={styles.paragraph}>
          We reserve the right to modify these Terms of Service at any time. We will provide notice of significant changes by updating the "Last Updated" date.
          Your continued use of the application after such modifications constitutes your acceptance of the updated terms.
        </Text>
        
        <Text style={styles.sectionTitle}>9. Governing Law</Text>
        <Text style={styles.paragraph}>
          These Terms of Service shall be governed by and construed in accordance with the laws of the United States, 
          without regard to its conflict of law provisions.
        </Text>
        
        <Text style={styles.sectionTitle}>10. Contact Us</Text>
        <Text style={styles.paragraph}>
          If you have any questions about these Terms of Service, please contact us at:
        </Text>
        <Text style={styles.paragraph}>
          legal@culturalnuancenavigator.com
        </Text>
        
        <View style={styles.footer} />
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f9f9f9',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  lastUpdated: {
    fontSize: 14,
    color: '#666',
    marginBottom: 20,
    fontStyle: 'italic',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 24,
    marginBottom: 12,
  },
  paragraph: {
    fontSize: 16,
    color: '#444',
    lineHeight: 24,
    marginBottom: 16,
  },
  bulletPoint: {
    fontSize: 16,
    color: '#444',
    lineHeight: 24,
    marginBottom: 8,
    marginLeft: 16,
  },
  footer: {
    height: 40,
  },
});

export default TermsOfServiceScreen;
</file>

<file path="src/components/ConsentModal.tsx">
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  Modal, 
  StyleSheet, 
  TouchableOpacity, 
  ScrollView,
  Switch
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface ConsentModalProps {
  visible: boolean;
  onClose: () => void;
  onAccept: (aiImprovement: boolean) => void;
  onDecline: () => void;
  title: string;
  message: string;
  acceptButtonText?: string;
  declineButtonText?: string;
}

const ConsentModal: React.FC<ConsentModalProps> = ({
  visible,
  onClose,
  onAccept,
  onDecline,
  title,
  message,
  acceptButtonText = 'I Agree',
  declineButtonText = 'No Thanks'
}) => {
  const [aiImprovementConsent, setAiImprovementConsent] = useState(true);

  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.header}>
            <Text style={styles.title}>{title}</Text>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <Ionicons name="close" size={24} color="#666" />
            </TouchableOpacity>
          </View>
          
          <ScrollView style={styles.content}>
            <Text style={styles.message}>{message}</Text>
            
            <View style={styles.optionContainer}>
              <View style={styles.switchContainer}>
                <Text style={styles.optionText}>
                  Allow anonymous data to be used for improving our AI models
                </Text>
                <Switch
                  value={aiImprovementConsent}
                  onValueChange={setAiImprovementConsent}
                  trackColor={{ false: '#d0d0d0', true: '#81b0ff' }}
                  thumbColor={'#f4f3f4'}
                />
              </View>
              <Text style={styles.optionDescription}>
                This helps us improve our cultural understanding models. No personally identifiable information is used.
              </Text>
            </View>
          </ScrollView>
          
          <View style={styles.buttonsContainer}>
            <TouchableOpacity 
              style={[styles.button, styles.declineButton]} 
              onPress={onDecline}
            >
              <Text style={styles.declineButtonText}>{declineButtonText}</Text>
            </TouchableOpacity>
            
            <TouchableOpacity 
              style={[styles.button, styles.acceptButton]} 
              onPress={() => onAccept(aiImprovementConsent)}
            >
              <Text style={styles.acceptButtonText}>{acceptButtonText}</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    backgroundColor: '#fff',
    borderRadius: 12,
    width: '100%',
    maxWidth: 500,
    maxHeight: '80%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#4A6FA5',
  },
  closeButton: {
    padding: 4,
  },
  content: {
    padding: 16,
    maxHeight: 400,
  },
  message: {
    fontSize: 16,
    color: '#333',
    marginBottom: 20,
    lineHeight: 24,
  },
  optionContainer: {
    backgroundColor: '#f5f7fa',
    padding: 12,
    borderRadius: 8,
    marginBottom: 10,
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  optionText: {
    fontSize: 15,
    color: '#333',
    flex: 1,
    paddingRight: 10,
  },
  optionDescription: {
    fontSize: 13,
    color: '#666',
    lineHeight: 18,
  },
  buttonsContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#e0e0e0',
  },
  button: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 6,
    minWidth: 100,
    alignItems: 'center',
  },
  acceptButton: {
    backgroundColor: '#4A6FA5',
    marginLeft: 12,
  },
  acceptButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  declineButton: {
    backgroundColor: '#f5f5f5',
  },
  declineButtonText: {
    color: '#666',
    fontWeight: '600',
    fontSize: 16,
  },
});

export default ConsentModal;
</file>

<file path="src/components/DisclaimerBanner.tsx">
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

type DisclaimerBannerProps = {
  type?: 'cultural' | 'ai' | 'general';
  compact?: boolean;
  onClose?: () => void;
};

/**
 * A component to display important disclaimers about cultural nuances and AI limitations
 * to help minimize bias and stereotyping in the application.
 */
const DisclaimerBanner: React.FC<DisclaimerBannerProps> = ({ 
  type = 'cultural',
  compact = false,
  onClose
}) => {
  // Select disclaimer message based on type
  let message = '';
  
  switch (type) {
    case 'cultural':
      message = 'Cultural norms are general tendencies, not absolute rules. Individuals vary widely within cultures, and these insights should be used as general guidance, not stereotypes.';
      break;
    case 'ai':
      message = 'AI analysis is imperfect and may contain biases. Please use your judgment and consider context when applying these suggestions.';
      break;
    case 'general':
    default:
      message = 'This information is provided as general guidance only. Individual experiences and contexts may vary significantly.';
  }

  if (compact) {
    // Shorter version for compact mode
    message = type === 'cultural' 
      ? 'Cultural norms are general tendencies, not absolute rules for individuals.'
      : type === 'ai'
        ? 'AI analysis may contain biases. Use your judgment.'
        : 'For general guidance only. Individual contexts may vary.';
  }

  return (
    <View style={[
      styles.container,
      type === 'cultural' ? styles.culturalContainer : 
      type === 'ai' ? styles.aiContainer : styles.generalContainer,
      compact && styles.compactContainer
    ]}>
      <View style={styles.iconContainer}>
        <Ionicons 
          name={
            type === 'cultural' ? 'information-circle' : 
            type === 'ai' ? 'alert-circle' : 'help-circle'
          } 
          size={compact ? 16 : 20} 
          color="#fff" 
        />
      </View>
      
      <Text style={[
        styles.message,
        compact && styles.compactMessage
      ]}>
        {message}
      </Text>
      
      {onClose && (
        <TouchableOpacity style={styles.closeButton} onPress={onClose}>
          <Ionicons name="close" size={compact ? 16 : 20} color="#fff" />
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    marginVertical: 8,
  },
  culturalContainer: {
    backgroundColor: '#4A6FA5', // Blue for cultural disclaimers
  },
  aiContainer: {
    backgroundColor: '#9C5A9B', // Purple for AI disclaimers
  },
  generalContainer: {
    backgroundColor: '#5A9C7F', // Green for general disclaimers
  },
  compactContainer: {
    padding: 8,
    marginVertical: 4,
  },
  iconContainer: {
    marginRight: 10,
  },
  message: {
    color: '#fff',
    flex: 1,
    fontSize: 14,
    lineHeight: 20,
  },
  compactMessage: {
    fontSize: 12,
    lineHeight: 16,
  },
  closeButton: {
    marginLeft: 10,
  },
});

export default DisclaimerBanner;
</file>

<file path="src/components/FeedbackButton.tsx">
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  Modal, 
  TextInput, 
  ScrollView,
  ActivityIndicator,
  Alert
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { submitFeedback } from '../services/feedbackService';

type FeedbackButtonProps = {
  analysisId?: string;
  analysisType?: string;
  cultureId?: string;
  compact?: boolean;
};

/**
 * A button that opens a feedback form for users to report issues with AI analysis
 */
const FeedbackButton: React.FC<FeedbackButtonProps> = ({ 
  analysisId, 
  analysisType = 'text',
  cultureId,
  compact = false
}) => {
  const [modalVisible, setModalVisible] = useState(false);
  const [feedbackType, setFeedbackType] = useState<string>('');
  const [feedbackText, setFeedbackText] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleOpenModal = () => {
    setModalVisible(true);
  };

  const handleCloseModal = () => {
    setModalVisible(false);
    // Reset form
    setFeedbackType('');
    setFeedbackText('');
  };

  const handleSubmit = async () => {
    if (!feedbackType) {
      Alert.alert('Error', 'Please select a feedback type');
      return;
    }

    if (!feedbackText.trim()) {
      Alert.alert('Error', 'Please provide details about the issue');
      return;
    }

    try {
      setIsSubmitting(true);
      
      const result = await submitFeedback({
        analysisId,
        analysisType,
        cultureId,
        feedbackType,
        feedbackText,
        timestamp: new Date().toISOString()
      });
      
      setIsSubmitting(false);
      
      if (result.success) {
        Alert.alert(
          'Thank You',
          'Your feedback has been submitted. We appreciate your help in improving our AI.',
          [{ text: 'OK', onPress: handleCloseModal }]
        );
      } else {
        throw new Error(result.message || 'Failed to submit feedback');
      }
    } catch (error) {
      setIsSubmitting(false);
      Alert.alert(
        'Error',
        'Failed to submit feedback. Please try again later.',
        [{ text: 'OK' }]
      );
    }
  };

  const renderFeedbackTypeButton = (type: string, label: string, icon: string) => (
    <TouchableOpacity 
      style={[
        styles.feedbackTypeButton,
        feedbackType === type && styles.selectedFeedbackType
      ]}
      onPress={() => setFeedbackType(type)}
    >
      <Ionicons 
        name={icon as any} 
        size={18} 
        color={feedbackType === type ? '#fff' : '#4A6FA5'} 
      />
      <Text 
        style={[
          styles.feedbackTypeText,
          feedbackType === type && styles.selectedFeedbackTypeText
        ]}
      >
        {label}
      </Text>
    </TouchableOpacity>
  );

  return (
    <>
      <TouchableOpacity 
        style={[styles.button, compact && styles.compactButton]} 
        onPress={handleOpenModal}
      >
        <Ionicons name="flag-outline" size={compact ? 14 : 16} color="#4A6FA5" />
        <Text style={[styles.buttonText, compact && styles.compactButtonText]}>
          Report Issue
        </Text>
      </TouchableOpacity>

      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={handleCloseModal}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Report an Issue</Text>
              <TouchableOpacity onPress={handleCloseModal}>
                <Ionicons name="close" size={24} color="#333" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalBody}>
              <Text style={styles.sectionTitle}>What type of issue are you reporting?</Text>
              
              <View style={styles.feedbackTypeContainer}>
                {renderFeedbackTypeButton('bias', 'Cultural Bias', 'alert-circle-outline')}
                {renderFeedbackTypeButton('inaccuracy', 'Inaccurate Information', 'information-circle-outline')}
                {renderFeedbackTypeButton('offensive', 'Offensive Content', 'warning-outline')}
                {renderFeedbackTypeButton('other', 'Other Issue', 'help-circle-outline')}
              </View>

              <Text style={styles.sectionTitle}>Please provide details:</Text>
              <TextInput
                style={styles.textInput}
                multiline
                numberOfLines={5}
                placeholder="Describe the issue you found..."
                value={feedbackText}
                onChangeText={setFeedbackText}
              />

              <Text style={styles.disclaimer}>
                Your feedback helps us improve our AI and reduce bias. Thank you for contributing to a more culturally nuanced experience.
              </Text>
            </ScrollView>

            <View style={styles.modalFooter}>
              <TouchableOpacity 
                style={styles.cancelButton} 
                onPress={handleCloseModal}
                disabled={isSubmitting}
              >
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.submitButton} 
                onPress={handleSubmit}
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <ActivityIndicator size="small" color="#fff" />
                ) : (
                  <Text style={styles.submitButtonText}>Submit</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </>
  );
};

const styles = StyleSheet.create({
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f4f8',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#dbe1e8',
  },
  compactButton: {
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 16,
  },
  buttonText: {
    color: '#4A6FA5',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 6,
  },
  compactButtonText: {
    fontSize: 12,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContent: {
    backgroundColor: '#fff',
    borderRadius: 12,
    width: '100%',
    maxWidth: 500,
    maxHeight: '80%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  modalBody: {
    padding: 16,
    maxHeight: 400,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
    marginTop: 8,
  },
  feedbackTypeContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 16,
  },
  feedbackTypeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f4f8',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 20,
    marginRight: 8,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#dbe1e8',
  },
  selectedFeedbackType: {
    backgroundColor: '#4A6FA5',
    borderColor: '#4A6FA5',
  },
  feedbackTypeText: {
    color: '#4A6FA5',
    marginLeft: 6,
    fontSize: 14,
  },
  selectedFeedbackTypeText: {
    color: '#fff',
  },
  textInput: {
    borderWidth: 1,
    borderColor: '#dbe1e8',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    minHeight: 120,
    textAlignVertical: 'top',
    marginBottom: 16,
  },
  disclaimer: {
    fontSize: 12,
    color: '#666',
    fontStyle: 'italic',
    marginBottom: 16,
  },
  modalFooter: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  cancelButton: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    marginRight: 8,
  },
  cancelButtonText: {
    color: '#666',
    fontSize: 16,
    fontWeight: '500',
  },
  submitButton: {
    backgroundColor: '#4A6FA5',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  submitButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '500',
  },
});

export default FeedbackButton;
</file>

<file path="src/navigation/AuthStack.tsx">
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import LoginScreen from '../screens/LoginScreen';
import SignUpScreen from '../screens/SignUpScreen';
import { AuthStackParamList } from '../types/navigation';

const Stack = createStackNavigator<AuthStackParamList>();

const AuthStack = () => {
  return (
    <Stack.Navigator 
      initialRouteName="Login"
      screenOptions={{
        headerShown: false,
        cardStyle: { backgroundColor: '#f5f5f5' },
      }}
    >
      <Stack.Screen name="Login" component={LoginScreen} />
      <Stack.Screen name="SignUp" component={SignUpScreen} />
    </Stack.Navigator>
  );
};

export default AuthStack;
</file>

<file path="src/navigation/CulturalBriefingStack.tsx">
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { CulturalBriefingStackParamList } from '../types/navigation';
import CultureSelectionScreen from '../screens/CultureSelectionScreen';
import CulturalBriefingDetailScreen from '../screens/CulturalBriefingDetailScreen';

const Stack = createStackNavigator<CulturalBriefingStackParamList>();

const CulturalBriefingStack = () => {
  return (
    <Stack.Navigator
      initialRouteName="CultureSelection"
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen name="CultureSelection" component={CultureSelectionScreen} />
      <Stack.Screen name="CulturalBriefingDetail" component={CulturalBriefingDetailScreen} />
    </Stack.Navigator>
  );
};

export default CulturalBriefingStack;
</file>

<file path="src/navigation/IdiomsStack.tsx">
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { IdiomsStackParamList } from '../types/navigation';
import IdiomSearchScreen from '../screens/IdiomSearchScreen';
import IdiomDetailScreen from '../screens/IdiomDetailScreen';

const Stack = createStackNavigator<IdiomsStackParamList>();

const IdiomsStack: React.FC = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: '#4A6FA5',
        },
        headerTintColor: '#fff',
        headerTitleStyle: {
          fontWeight: 'bold',
        },
      }}
    >
      <Stack.Screen 
        name="IdiomSearch" 
        component={IdiomSearchScreen} 
        options={{ title: 'Idiom Demystifier' }}
      />
      <Stack.Screen
        name="IdiomDetail"
        component={IdiomDetailScreen}
        options={({ route }) => ({ 
          title: route.params?.idiomPhrase || 'Idiom Details' 
        })}
      />
    </Stack.Navigator>
  );
};

export default IdiomsStack;
</file>

<file path="src/navigation/MainTab.tsx">
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';
import HomeScreen from '../screens/HomeScreen';
import CulturalBriefingStack from './CulturalBriefingStack';
import TextAnalysisScreen from '../screens/TextAnalysisScreen';
import IdiomsStack from './IdiomsStack';
import ImageAnalysisPlaceholderScreen from '../screens/ImageAnalysisPlaceholderScreen';
import SettingsScreen from '../screens/SettingsScreen';
import { MainTabParamList } from '../types/navigation';

// Create placeholder screens for the other tabs
const PlaceholderScreen = ({ title }: { title: string }) => (
  <HomeScreen />
);

const Tab = createBottomTabNavigator<MainTabParamList>();

const MainTab = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: keyof typeof Ionicons.glyphMap;

          if (route.name === 'Home') {
            iconName = focused ? 'home' : 'home-outline';
          } else if (route.name === 'CulturalBriefings') {
            iconName = focused ? 'book' : 'book-outline';
          } else if (route.name === 'Analysis') {
            iconName = focused ? 'analytics' : 'analytics-outline';
          } else if (route.name === 'Idioms') {
            iconName = focused ? 'chatbubble' : 'chatbubble-outline';
          } else if (route.name === 'ImageAnalysis') {
            iconName = focused ? 'camera' : 'camera-outline';
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
          } else {
            iconName = 'help-circle-outline';
          }

          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: '#4A6FA5',
        tabBarInactiveTintColor: 'gray',
        headerShown: route.name !== 'CulturalBriefings' && route.name !== 'Idioms', // Hide header for CulturalBriefings and Idioms since they have their own stack
        headerStyle: {
          backgroundColor: '#4A6FA5',
        },
        headerTintColor: '#fff',
        headerTitleStyle: {
          fontWeight: 'bold',
        },
      })}
    >
      <Tab.Screen 
        name="Home" 
        component={HomeScreen} 
        options={{ title: 'Home' }}
      />
      <Tab.Screen 
        name="CulturalBriefings" 
        component={CulturalBriefingStack} 
        options={{ title: 'Cultural Briefings' }} 
      />
      <Tab.Screen 
        name="Analysis" 
        component={TextAnalysisScreen} 
        options={{ title: 'Analysis' }} 
      />
      <Tab.Screen 
        name="Idioms" 
        component={IdiomsStack} 
        options={{ title: 'Idioms' }} 
      />
      <Tab.Screen 
        name="ImageAnalysis" 
        component={ImageAnalysisPlaceholderScreen} 
        options={{ title: 'Image Analysis' }} 
      />
      <Tab.Screen 
        name="Settings" 
        component={SettingsScreen} 
        options={{ title: 'Settings' }} 
      />
    </Tab.Navigator>
  );
};

export default MainTab;
</file>

<file path="src/navigation/RootNavigator.tsx">
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { RootStackParamList } from '../types/navigation';
import { useAuth } from '../services/authContext';
import AuthStack from './AuthStack';
import MainTab from './MainTab';
import { ActivityIndicator, View, StyleSheet } from 'react-native';
import PrivacyPolicyScreen from '../assets/legal/privacy-policy';
import TermsOfServiceScreen from '../assets/legal/terms-of-service';

const Stack = createStackNavigator<RootStackParamList>();

const RootNavigator = () => {
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#4A6FA5" />
      </View>
    );
  }

  return (
    <NavigationContainer>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {user ? (
          <>
            <Stack.Screen name="Main" component={MainTab} />
            <Stack.Screen name="PrivacyPolicy" component={PrivacyPolicyScreen} />
            <Stack.Screen name="TermsOfService" component={TermsOfServiceScreen} />
          </>
        ) : (
          <Stack.Screen name="Auth" component={AuthStack} />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
});

export default RootNavigator;
</file>

<file path="src/screens/CulturalBriefingDetailScreen.tsx">
import React, { useEffect, useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity, 
  ActivityIndicator,
  SectionList,
  Alert
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { RouteProp } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';
import { Ionicons } from '@expo/vector-icons';
import { getCulturalBriefing } from '../services/cultureService';
import { CulturalBriefing, CulturalNorm, NormCategory } from '../types/culture';
import { CulturalBriefingStackParamList } from '../types/navigation';
import DisclaimerBanner from '../components/DisclaimerBanner';
import FeedbackButton from '../components/FeedbackButton';

type CulturalBriefingDetailScreenRouteProp = RouteProp<CulturalBriefingStackParamList, 'CulturalBriefingDetail'>;
type CulturalBriefingDetailScreenNavigationProp = StackNavigationProp<CulturalBriefingStackParamList, 'CulturalBriefingDetail'>;

type Props = {
  route: CulturalBriefingDetailScreenRouteProp;
  navigation: CulturalBriefingDetailScreenNavigationProp;
};

// Group norms by category
interface NormSection {
  title: string;
  data: CulturalNorm[];
}

// Flag colors for each culture (same as in CultureSelectionScreen)
const cultureColors: { [key: string]: { primary: string; secondary: string } } = {
  'jp-001': { primary: '#BC002D', secondary: '#FFFFFF' }, // Japan
  'ar-001': { primary: '#006C35', secondary: '#FFFFFF' }, // Arabic/Gulf
  'br-001': { primary: '#009739', secondary: '#FFDF00' }, // Brazil
};

// Simple flag component (same as in CultureSelectionScreen)
const CultureFlag = ({ cultureId }: { cultureId: string }) => {
  const colors = cultureColors[cultureId] || { primary: '#4A6FA5', secondary: '#FFFFFF' };
  
  let flagContent;
  
  switch (cultureId) {
    case 'jp-001': // Japan
      flagContent = (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <View style={{ 
            width: 30, 
            height: 30, 
            borderRadius: 15, 
            backgroundColor: colors.primary
          }} />
        </View>
      );
      break;
    case 'ar-001': // Arabic/Gulf
      flagContent = (
        <View style={{ flex: 1 }}>
          <View style={{ flex: 1, backgroundColor: colors.primary }} />
          <View style={{ flex: 1, backgroundColor: '#FFFFFF' }} />
          <View style={{ flex: 1, backgroundColor: '#000000' }} />
        </View>
      );
      break;
    case 'br-001': // Brazil
      flagContent = (
        <View style={{ 
          flex: 1, 
          backgroundColor: colors.primary,
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <View style={{ 
            width: 35, 
            height: 20, 
            backgroundColor: colors.secondary,
            transform: [{ rotate: '45deg' }]
          }} />
        </View>
      );
      break;
    default:
      flagContent = (
        <View style={{ 
          flex: 1, 
          justifyContent: 'center', 
          alignItems: 'center',
          backgroundColor: colors.primary
        }}>
          <Text style={{ 
            color: colors.secondary, 
            fontWeight: 'bold', 
            fontSize: 22
          }}>
            {cultureId.substring(0, 2).toUpperCase()}
          </Text>
        </View>
      );
  }
  
  return (
    <View style={styles.flagContainer}>
      {flagContent}
    </View>
  );
};

const CulturalBriefingDetailScreen: React.FC<Props> = ({ route, navigation }) => {
  const { cultureId } = route.params;
  const [briefing, setBriefing] = useState<CulturalBriefing | null>(null);
  const [sections, setSections] = useState<NormSection[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showDisclaimer, setShowDisclaimer] = useState(true);

  useEffect(() => {
    const fetchBriefing = async () => {
      try {
        setIsLoading(true);
        const data = await getCulturalBriefing(cultureId);
        setBriefing(data);
        
        if (data) {
          // Group norms by category
          const normsByCategory = data.norms.reduce((acc: { [key: string]: CulturalNorm[] }, norm) => {
            const categoryName = norm.category;
            if (!acc[categoryName]) {
              acc[categoryName] = [];
            }
            acc[categoryName].push(norm);
            return acc;
          }, {});
          
          // Convert to sections array
          const normSections = Object.entries(normsByCategory).map(([title, data]) => ({
            title,
            data,
          }));
          
          setSections(normSections);
        }
        
        setError(null);
      } catch (err) {
        console.error('Error fetching cultural briefing:', err);
        setError('Failed to load cultural briefing. Please try again.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchBriefing();
  }, [cultureId]);

  const handleSaveOffline = () => {
    // Placeholder functionality - just show an alert
    Alert.alert(
      "Feature Coming Soon",
      "Offline access will be available in a future update.",
      [{ text: "OK" }]
    );
  };

  const handleSetReminder = (norm: CulturalNorm) => {
    // Placeholder functionality - just show an alert
    Alert.alert(
      "Feature Coming Soon",
      `Reminders for "${norm.subCategory || norm.category}" will be available in a future update.`,
      [{ text: "OK" }]
    );
  };

  const renderSectionHeader = ({ section: { title } }: { section: NormSection }) => (
    <View style={styles.sectionHeader}>
      <Text style={styles.sectionTitle}>{title}</Text>
    </View>
  );

  const renderNormItem = ({ item }: { item: CulturalNorm }) => (
    <View style={styles.normCard}>
      {item.subCategory && (
        <Text style={styles.normSubCategory}>{item.subCategory}</Text>
      )}
      <Text style={styles.normDescription}>{item.description}</Text>
      
      <View style={styles.normContent}>
        <View style={styles.doSection}>
          <View style={styles.doIconContainer}>
            <Ionicons name="checkmark-circle" size={24} color="#4caf50" />
          </View>
          <Text style={styles.doHeading}>Do</Text>
          <Text style={styles.doBehavior}>{item.doBehavior}</Text>
        </View>
        
        <View style={styles.divider} />
        
        <View style={styles.dontSection}>
          <View style={styles.dontIconContainer}>
            <Ionicons name="close-circle" size={24} color="#f44336" />
          </View>
          <Text style={styles.dontHeading}>Don't</Text>
          <Text style={styles.dontBehavior}>{item.dontBehavior}</Text>
        </View>
      </View>
      
      <View style={styles.explanationSection}>
        <Text style={styles.explanationHeading}>Why it matters</Text>
        <Text style={styles.explanation}>{item.explanation}</Text>
      </View>
      
      <View style={styles.normActionRow}>
        <View style={styles.severityContainer}>
          <Text style={styles.severityLabel}>Importance: </Text>
          <Text style={[
            styles.severityValue,
            item.severityLevel === 'Critical' && styles.criticalSeverity,
            item.severityLevel === 'High' && styles.highSeverity,
            item.severityLevel === 'Medium' && styles.mediumSeverity,
            item.severityLevel === 'Low' && styles.lowSeverity,
          ]}>
            {item.severityLevel}
          </Text>
        </View>
        
        <TouchableOpacity
          style={styles.reminderButton}
          onPress={() => handleSetReminder(item)}
        >
          <Ionicons name="notifications-outline" size={16} color="#4A6FA5" />
          <Text style={styles.reminderButtonText}>Set Reminder</Text>
        </TouchableOpacity>
      </View>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#4A6FA5" />
      </View>
    );
  }

  if (error || !briefing) {
    return (
      <View style={styles.centerContainer}>
        <Text style={styles.errorText}>{error || 'Culture not found'}</Text>
        <TouchableOpacity 
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Go Back</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#4A6FA5" />
        </TouchableOpacity>
        
        <View style={styles.headerContainer}>
          <View style={styles.cultureInfoContainer}>
            <CultureFlag cultureId={cultureId} />
            <View style={styles.cultureTextContainer}>
              <Text style={styles.cultureName}>{briefing.cultureInfo.name}</Text>
              <Text style={styles.cultureRegion}>{briefing.cultureInfo.region}</Text>
            </View>
          </View>
          
          <TouchableOpacity 
            style={styles.saveButton}
            onPress={handleSaveOffline}
          >
            <Ionicons name="download-outline" size={18} color="#4A6FA5" />
            <Text style={styles.saveButtonText}>Save Offline</Text>
          </TouchableOpacity>
        </View>
        
        {showDisclaimer && (
          <DisclaimerBanner 
            type="cultural" 
            onClose={() => setShowDisclaimer(false)}
          />
        )}
        
        <View style={styles.descriptionContainer}>
          <Text style={styles.descriptionTitle}>About {briefing.cultureInfo.name} Culture</Text>
          <Text style={styles.descriptionText}>{briefing.cultureInfo.description}</Text>
        </View>
      </View>
      
      <View style={styles.contentContainer}>
        <Text style={styles.briefingTitle}>Cultural Norms & Etiquette</Text>
        
        <SectionList
          sections={sections}
          keyExtractor={(item) => item.id}
          renderItem={renderNormItem}
          renderSectionHeader={renderSectionHeader}
          stickySectionHeadersEnabled={true}
          contentContainerStyle={styles.listContent}
          ItemSeparatorComponent={() => <View style={styles.itemSeparator} />}
          SectionSeparatorComponent={() => <View style={styles.sectionSeparator} />}
          ListFooterComponent={() => (
            <View style={styles.footerContainer}>
              <Text style={styles.lastUpdatedText}>
                Last Updated: {new Date(briefing.lastUpdated).toLocaleDateString()}
              </Text>
              
              <View style={styles.feedbackButtonContainer}>
                <FeedbackButton 
                  cultureId={cultureId}
                  analysisType="cultural_briefing"
                  compact={true}
                />
              </View>
            </View>
          )}
        />
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  header: {
    backgroundColor: '#fff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    marginBottom: 10,
  },
  headerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  cultureInfoContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  cultureTextContainer: {
    flex: 1,
  },
  cultureName: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  cultureRegion: {
    fontSize: 16,
    color: '#666',
    marginBottom: 2,
  },
  saveButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f4f8',
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: '#d0e1f9',
  },
  saveButtonText: {
    color: '#4A6FA5',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 8,
  },
  descriptionContainer: {
    marginBottom: 12,
  },
  descriptionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  descriptionText: {
    fontSize: 14,
    color: '#555',
    lineHeight: 20,
  },
  contentContainer: {
    flex: 1,
  },
  briefingTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginVertical: 16,
    marginHorizontal: 16,
  },
  listContent: {
    paddingBottom: 20,
  },
  sectionHeader: {
    backgroundColor: '#4A6FA5',
    padding: 10,
    borderTopLeftRadius: 8,
    borderTopRightRadius: 8,
    marginHorizontal: 16,
  },
  sectionTitle: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  normCard: {
    backgroundColor: '#fff',
    padding: 16,
    marginHorizontal: 16,
    borderBottomLeftRadius: 8,
    borderBottomRightRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  normSubCategory: {
    fontSize: 15,
    fontWeight: '600',
    color: '#4A6FA5',
    marginBottom: 4,
  },
  normDescription: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 12,
  },
  normContent: {
    flexDirection: 'row',
    marginBottom: 16,
  },
  doSection: {
    flex: 1,
    marginRight: 8,
  },
  doIconContainer: {
    alignItems: 'flex-start',
    marginBottom: 4,
  },
  doHeading: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#4caf50',
    marginBottom: 4,
  },
  doBehavior: {
    fontSize: 14,
    color: '#555',
    lineHeight: 20,
  },
  divider: {
    width: 1,
    backgroundColor: '#e0e0e0',
    marginHorizontal: 8,
  },
  dontSection: {
    flex: 1,
    marginLeft: 8,
  },
  dontIconContainer: {
    alignItems: 'flex-start',
    marginBottom: 4,
  },
  dontHeading: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#f44336',
    marginBottom: 4,
  },
  dontBehavior: {
    fontSize: 14,
    color: '#555',
    lineHeight: 20,
  },
  explanationSection: {
    borderTopWidth: 1,
    borderTopColor: '#e0e0e0',
    paddingTop: 12,
    marginBottom: 12,
  },
  explanationHeading: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#555',
    marginBottom: 6,
  },
  explanation: {
    fontSize: 14,
    color: '#555',
    lineHeight: 20,
  },
  severityContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  severityLabel: {
    fontSize: 12,
    color: '#777',
  },
  severityValue: {
    fontSize: 12,
    fontWeight: 'bold',
  },
  criticalSeverity: {
    color: '#d32f2f',
  },
  highSeverity: {
    color: '#f57c00',
  },
  mediumSeverity: {
    color: '#0288d1',
  },
  lowSeverity: {
    color: '#388e3c',
  },
  itemSeparator: {
    height: 1,
    backgroundColor: '#e0e0e0',
    marginHorizontal: 16,
  },
  sectionSeparator: {
    height: 20,
  },
  errorText: {
    fontSize: 16,
    color: '#ff6b6b',
    marginBottom: 20,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: '#4A6FA5',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  footerContainer: {
    padding: 16,
    marginTop: 8,
  },
  lastUpdatedText: {
    fontSize: 12,
    color: '#666',
    fontStyle: 'italic',
    marginBottom: 16,
  },
  feedbackButtonContainer: {
    marginBottom: 16,
    alignItems: 'flex-end',
  },
});

export default CulturalBriefingDetailScreen;
</file>

<file path="src/screens/CultureSelectionScreen.tsx">
import React, { useEffect, useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList, 
  TouchableOpacity, 
  ActivityIndicator
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { StackNavigationProp } from '@react-navigation/stack';
import { getAllCultures } from '../services/cultureService';
import { Culture } from '../types/culture';
import { CulturalBriefingStackParamList } from '../types/navigation';
import { Ionicons } from '@expo/vector-icons';

type CultureSelectionScreenNavigationProp = StackNavigationProp<CulturalBriefingStackParamList, 'CultureSelection'>;

type Props = {
  navigation: CultureSelectionScreenNavigationProp;
};

// Flag colors for each culture
const cultureColors: { [key: string]: { primary: string; secondary: string } } = {
  'jp-001': { primary: '#BC002D', secondary: '#FFFFFF' }, // Japan
  'ar-001': { primary: '#006C35', secondary: '#FFFFFF' }, // Arabic/Gulf
  'br-001': { primary: '#009739', secondary: '#FFDF00' }, // Brazil
};

// Simple flag component instead of using images
const CultureFlag = ({ cultureId }: { cultureId: string }) => {
  const colors = cultureColors[cultureId] || { primary: '#4A6FA5', secondary: '#FFFFFF' };
  
  let flagContent;
  
  switch (cultureId) {
    case 'jp-001': // Japan
      flagContent = (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <View style={{ 
            width: 30, 
            height: 30, 
            borderRadius: 15, 
            backgroundColor: colors.primary
          }} />
        </View>
      );
      break;
    case 'ar-001': // Arabic/Gulf
      flagContent = (
        <View style={{ flex: 1 }}>
          <View style={{ flex: 1, backgroundColor: colors.primary }} />
          <View style={{ flex: 1, backgroundColor: '#FFFFFF' }} />
          <View style={{ flex: 1, backgroundColor: '#000000' }} />
        </View>
      );
      break;
    case 'br-001': // Brazil
      flagContent = (
        <View style={{ 
          flex: 1, 
          backgroundColor: colors.primary,
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <View style={{ 
            width: 35, 
            height: 20, 
            backgroundColor: colors.secondary,
            transform: [{ rotate: '45deg' }]
          }} />
        </View>
      );
      break;
    default:
      flagContent = (
        <View style={{ 
          flex: 1, 
          justifyContent: 'center', 
          alignItems: 'center',
          backgroundColor: colors.primary
        }}>
          <Text style={{ 
            color: colors.secondary, 
            fontWeight: 'bold', 
            fontSize: 22
          }}>
            {cultureId.substring(0, 2).toUpperCase()}
          </Text>
        </View>
      );
  }
  
  return (
    <View style={styles.flagContainer}>
      {flagContent}
    </View>
  );
};

const CultureSelectionScreen: React.FC<Props> = ({ navigation }) => {
  const [cultures, setCultures] = useState<Culture[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchCultures = async () => {
      try {
        setIsLoading(true);
        const data = await getAllCultures();
        setCultures(data);
        setError(null);
      } catch (err) {
        console.error('Error fetching cultures:', err);
        setError('Failed to load cultures. Please try again.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchCultures();
  }, []);

  const handleCultureSelect = (culture: Culture) => {
    navigation.navigate('CulturalBriefingDetail', { cultureId: culture.id });
  };

  const renderCultureItem = ({ item }: { item: Culture }) => (
    <TouchableOpacity 
      style={styles.cultureCard}
      onPress={() => handleCultureSelect(item)}
    >
      <CultureFlag cultureId={item.id} />
      <View style={styles.cultureInfo}>
        <Text style={styles.cultureName}>{item.name}</Text>
        <Text style={styles.cultureRegion}>{item.region}</Text>
        <Text style={styles.cultureDescription} numberOfLines={2}>
          {item.description}
        </Text>
      </View>
      <Ionicons name="chevron-forward" size={24} color="#4A6FA5" />
    </TouchableOpacity>
  );

  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#4A6FA5" />
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.centerContainer}>
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity 
          style={styles.retryButton}
          onPress={() => navigation.navigate('CultureSelection')}
        >
          <Text style={styles.retryButtonText}>Retry</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Select a Culture</Text>
        <Text style={styles.subtitle}>
          Choose a culture to explore its customs, norms, and etiquette
        </Text>
      </View>
      
      <FlatList
        data={cultures}
        renderItem={renderCultureItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContainer}
        ItemSeparatorComponent={() => <View style={styles.separator} />}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  header: {
    padding: 16,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  listContainer: {
    padding: 16,
  },
  cultureCard: {
    flexDirection: 'row',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  flagContainer: {
    width: 60,
    height: 60,
    borderRadius: 30,
    overflow: 'hidden',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    marginRight: 16,
  },
  cultureInfo: {
    flex: 1,
  },
  cultureName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  cultureRegion: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  cultureDescription: {
    fontSize: 14,
    color: '#666',
  },
  separator: {
    height: 16,
  },
  errorText: {
    fontSize: 16,
    color: '#ff6b6b',
    marginBottom: 20,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: '#4A6FA5',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

export default CultureSelectionScreen;
</file>

<file path="src/screens/HomeScreen.tsx">
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ActivityIndicator } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { CompositeNavigationProp } from '@react-navigation/native';
import { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';
import { StackNavigationProp } from '@react-navigation/stack';
import { MainTabParamList, RootStackParamList } from '../types/navigation';
import { useAuth } from '../services/authContext';

type HomeScreenNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Home'>,
  StackNavigationProp<RootStackParamList>
>;

type Props = {
  navigation: HomeScreenNavigationProp;
};

const HomeScreen: React.FC<Props> = () => {
  const { user, signOut, isLoading } = useAuth();

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#4A6FA5" />
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.title}>Cultural Nuance Navigator</Text>
        <Text style={styles.welcomeText}>
          Welcome, {user?.email ?? 'User'}!
        </Text>
        <Text style={styles.instructionText}>
          This home screen will be expanded with features including:
        </Text>
        <View style={styles.featureList}>
          <Text style={styles.featureItem}>• Cultural Briefings</Text>
          <Text style={styles.featureItem}>• Real-Time Analysis</Text>
          <Text style={styles.featureItem}>• Idiom Demystifier</Text>
          <Text style={styles.featureItem}>• Scenario Simulator</Text>
        </View>
        <TouchableOpacity 
          style={styles.logoutButton} 
          onPress={signOut}
        >
          <Text style={styles.logoutButtonText}>Log Out</Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  content: {
    flex: 1,
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 20,
    color: '#333',
    textAlign: 'center',
  },
  welcomeText: {
    fontSize: 18,
    marginBottom: 30,
    color: '#4A6FA5',
    textAlign: 'center',
  },
  instructionText: {
    fontSize: 16,
    marginBottom: 10,
    color: '#333',
    textAlign: 'center',
  },
  featureList: {
    alignSelf: 'stretch',
    marginLeft: 50,
    marginBottom: 40,
  },
  featureItem: {
    fontSize: 16,
    marginBottom: 8,
    color: '#555',
  },
  logoutButton: {
    backgroundColor: '#ff6b6b',
    borderRadius: 8,
    padding: 15,
    width: '80%',
    alignItems: 'center',
  },
  logoutButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
});

export default HomeScreen;
</file>

<file path="src/screens/IdiomDetailScreen.tsx">
import React, { useEffect, useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  ActivityIndicator, 
  Alert,
  TouchableOpacity
} from 'react-native';
import { StackNavigationProp } from '@react-navigation/stack';
import { RouteProp } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { IdiomsStackParamList } from '../types/navigation';
import { Idiom, PolitenessLevel } from '../types/culture';
import { getIdiomById } from '../services/cultureService';

type IdiomDetailScreenNavigationProp = StackNavigationProp<IdiomsStackParamList, 'IdiomDetail'>;
type IdiomDetailScreenRouteProp = RouteProp<IdiomsStackParamList, 'IdiomDetail'>;

interface Props {
  navigation: IdiomDetailScreenNavigationProp;
  route: IdiomDetailScreenRouteProp;
}

const IdiomDetailScreen: React.FC<Props> = ({ navigation, route }) => {
  const { idiomId } = route.params;
  const [idiom, setIdiom] = useState<Idiom | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchIdiomDetails = async () => {
      try {
        const idiomDetails = await getIdiomById(idiomId);
        setIdiom(idiomDetails);
      } catch (error) {
        console.error('Failed to fetch idiom details:', error);
        setError('Failed to load idiom details. Please try again later.');
      } finally {
        setLoading(false);
      }
    };

    fetchIdiomDetails();
  }, [idiomId]);

  const getPolitenessColor = (level: PolitenessLevel) => {
    switch (level) {
      case 'formal':
        return '#4A6FA5'; // Blue
      case 'informal':
        return '#58A05F'; // Green
      case 'slang':
        return '#E67E22'; // Orange
      case 'vulgar':
        return '#E74C3C'; // Red
      default:
        return '#718096'; // Gray
    }
  };

  const getPolitenessLabel = (level: PolitenessLevel) => {
    switch (level) {
      case 'formal':
        return 'Formal';
      case 'informal':
        return 'Informal';
      case 'slang':
        return 'Slang';
      case 'vulgar':
        return 'Vulgar';
      default:
        return 'Unknown';
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#4A6FA5" />
        <Text style={styles.loadingText}>Loading idiom details...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="alert-circle-outline" size={64} color="#E53E3E" />
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Go Back</Text>
        </TouchableOpacity>
      </View>
    );
  }

  if (!idiom) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="help-circle-outline" size={64} color="#718096" />
        <Text style={styles.errorText}>Idiom not found</Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Go Back</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.idiomPhrase}>{idiom.phrase}</Text>
        <View 
          style={[
            styles.politenessTag, 
            { backgroundColor: getPolitenessColor(idiom.politenessLevel) }
          ]}
        >
          <Text style={styles.politenessText}>
            {getPolitenessLabel(idiom.politenessLevel)}
          </Text>
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Literal Translation</Text>
        <Text style={styles.sectionContent}>{idiom.literalTranslation}</Text>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Meaning</Text>
        <Text style={styles.sectionContent}>{idiom.meaning}</Text>
      </View>

      {idiom.usageExamples && idiom.usageExamples.length > 0 && (
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Usage Examples</Text>
          {idiom.usageExamples.map((example, index) => (
            <View key={index} style={styles.exampleItem}>
              <Ionicons name="chatbubble-outline" size={18} color="#4A6FA5" />
              <Text style={styles.exampleText}>{example}</Text>
            </View>
          ))}
        </View>
      )}

      {idiom.contextNotes && (
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Context Notes</Text>
          <Text style={styles.sectionContent}>{idiom.contextNotes}</Text>
        </View>
      )}

      <View style={styles.section}>
        <Text style={styles.metaData}>
          Language: {idiom.language} • Last Updated: {new Date(idiom.lastUpdated).toLocaleDateString()}
        </Text>
      </View>

      {/* This is just a placeholder for the "Save this Idiom" button */}
      <TouchableOpacity style={styles.saveButton} disabled={true}>
        <Ionicons name="bookmark-outline" size={20} color="#FFFFFF" />
        <Text style={styles.saveButtonText}>Save this Idiom</Text>
      </TouchableOpacity>

      <View style={styles.bottomSpacer} />
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F7FA',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F7FA',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#4A5568',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
    backgroundColor: '#F5F7FA',
  },
  errorText: {
    fontSize: 18,
    color: '#4A5568',
    textAlign: 'center',
    marginTop: 16,
    marginBottom: 24,
  },
  retryButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    backgroundColor: '#4A6FA5',
    borderRadius: 8,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  header: {
    backgroundColor: 'white',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  idiomPhrase: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#2D3748',
    marginBottom: 8,
  },
  politenessTag: {
    alignSelf: 'flex-start',
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 4,
    marginTop: 4,
  },
  politenessText: {
    color: 'white',
    fontSize: 12,
    fontWeight: 'bold',
  },
  section: {
    backgroundColor: 'white',
    padding: 20,
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2D3748',
    marginBottom: 8,
  },
  sectionContent: {
    fontSize: 16,
    color: '#4A5568',
    lineHeight: 24,
  },
  exampleItem: {
    flexDirection: 'row',
    marginBottom: 8,
    alignItems: 'flex-start',
  },
  exampleText: {
    fontSize: 16,
    color: '#4A5568',
    marginLeft: 8,
    flex: 1,
    lineHeight: 24,
  },
  metaData: {
    fontSize: 14,
    color: '#718096',
    fontStyle: 'italic',
  },
  saveButton: {
    flexDirection: 'row',
    backgroundColor: '#A0AEC0', // Gray color to indicate it's disabled
    marginHorizontal: 20,
    marginTop: 24,
    paddingVertical: 16,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  bottomSpacer: {
    height: 40,
  },
});

export default IdiomDetailScreen;
</file>

<file path="src/screens/IdiomSearchScreen.tsx">
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  FlatList, 
  TouchableOpacity,
  ActivityIndicator,
  Alert
} from 'react-native';
import { StackNavigationProp } from '@react-navigation/stack';
import { Picker } from '@react-native-picker/picker';
import { Ionicons } from '@expo/vector-icons';
import { IdiomsStackParamList } from '../types/navigation';
import { Culture, Idiom } from '../types/culture';
import { fetchCultures, searchIdiomsByCulture } from '../services/cultureService';

type IdiomSearchScreenNavigationProp = StackNavigationProp<IdiomsStackParamList, 'IdiomSearch'>;

interface Props {
  navigation: IdiomSearchScreenNavigationProp;
}

const IdiomSearchScreen: React.FC<Props> = ({ navigation }) => {
  const [cultures, setCultures] = useState<Culture[]>([]);
  const [selectedCultureId, setSelectedCultureId] = useState<string>('');
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [idioms, setIdioms] = useState<Idiom[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [hasSearched, setHasSearched] = useState<boolean>(false);

  // Fetch available cultures when component mounts
  useEffect(() => {
    const loadCultures = async () => {
      try {
        const availableCultures = await fetchCultures();
        setCultures(availableCultures);
        
        // Set the first culture as selected by default if any exist
        if (availableCultures.length > 0) {
          setSelectedCultureId(availableCultures[0].id);
        }
      } catch (error) {
        console.error('Failed to load cultures:', error);
        Alert.alert('Error', 'Failed to load available cultures. Please try again later.');
      }
    };

    loadCultures();
  }, []);

  const handleSearch = async () => {
    if (!selectedCultureId) {
      Alert.alert('Selection Required', 'Please select a culture first.');
      return;
    }

    setLoading(true);
    setHasSearched(true);

    try {
      const results = await searchIdiomsByCulture(selectedCultureId, searchQuery);
      setIdioms(results);
    } catch (error) {
      console.error('Failed to search idioms:', error);
      Alert.alert('Error', 'Failed to search for idioms. Please try again later.');
      setIdioms([]);
    } finally {
      setLoading(false);
    }
  };

  const renderItem = ({ item }: { item: Idiom }) => (
    <TouchableOpacity 
      style={styles.idiomItem}
      onPress={() => navigation.navigate('IdiomDetail', { 
        idiomId: item.id,
        idiomPhrase: item.phrase 
      })}
    >
      <View style={styles.idiomItemContent}>
        <Text style={styles.idiomPhrase}>{item.phrase}</Text>
        <Text style={styles.idiomMeaning} numberOfLines={2}>{item.meaning}</Text>
      </View>
      <Ionicons name="chevron-forward" size={24} color="#4A6FA5" />
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.sectionTitle}>Search for Idioms</Text>
      
      <View style={styles.pickerContainer}>
        <Text style={styles.label}>Select Culture:</Text>
        <View style={styles.pickerWrapper}>
          <Picker
            selectedValue={selectedCultureId}
            onValueChange={(itemValue) => setSelectedCultureId(itemValue)}
            style={styles.picker}
          >
            {cultures.map((culture) => (
              <Picker.Item 
                key={culture.id} 
                label={culture.name} 
                value={culture.id} 
              />
            ))}
          </Picker>
        </View>
      </View>

      <View style={styles.searchContainer}>
        <TextInput
          style={styles.searchInput}
          placeholder="Search for idioms (optional)"
          value={searchQuery}
          onChangeText={setSearchQuery}
        />
        <TouchableOpacity 
          style={styles.searchButton}
          onPress={handleSearch}
        >
          <Ionicons name="search" size={24} color="white" />
        </TouchableOpacity>
      </View>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#4A6FA5" />
          <Text style={styles.loadingText}>Searching for idioms...</Text>
        </View>
      ) : hasSearched ? (
        idioms.length > 0 ? (
          <FlatList
            data={idioms}
            renderItem={renderItem}
            keyExtractor={(item) => item.id}
            contentContainerStyle={styles.listContainer}
            ListHeaderComponent={
              <Text style={styles.resultsText}>
                Found {idioms.length} idiom{idioms.length !== 1 ? 's' : ''}
              </Text>
            }
          />
        ) : (
          <View style={styles.noResultsContainer}>
            <Ionicons name="search-outline" size={48} color="#aaa" />
            <Text style={styles.noResultsText}>No idioms found</Text>
            <Text style={styles.noResultsSubtext}>
              Try different search terms or browse all idioms by leaving the search field empty.
            </Text>
          </View>
        )
      ) : (
        <View style={styles.initialStateContainer}>
          <Ionicons name="chatbubble-ellipses-outline" size={64} color="#4A6FA5" opacity={0.5} />
          <Text style={styles.initialStateText}>
            Select a culture and search to discover idioms and their meanings
          </Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#F5F7FA',
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#2D3748',
  },
  pickerContainer: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
    color: '#4A5568',
  },
  pickerWrapper: {
    borderWidth: 1,
    borderColor: '#CBD5E0',
    borderRadius: 8,
    backgroundColor: 'white',
  },
  picker: {
    height: 50,
    width: '100%',
  },
  searchContainer: {
    flexDirection: 'row',
    marginBottom: 24,
  },
  searchInput: {
    flex: 1,
    height: 50,
    borderWidth: 1,
    borderColor: '#CBD5E0',
    borderRadius: 8,
    paddingHorizontal: 16,
    backgroundColor: 'white',
    fontSize: 16,
  },
  searchButton: {
    width: 50,
    height: 50,
    backgroundColor: '#4A6FA5',
    borderRadius: 8,
    marginLeft: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#4A5568',
  },
  listContainer: {
    paddingBottom: 16,
  },
  resultsText: {
    fontSize: 16,
    marginBottom: 16,
    color: '#4A5568',
  },
  idiomItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: 'white',
    padding: 16,
    marginBottom: 8,
    borderRadius: 8,
    borderLeftWidth: 4,
    borderLeftColor: '#4A6FA5',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  idiomItemContent: {
    flex: 1,
    marginRight: 8,
  },
  idiomPhrase: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2D3748',
    marginBottom: 4,
  },
  idiomMeaning: {
    fontSize: 14,
    color: '#4A5568',
  },
  noResultsContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
  },
  noResultsText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#4A5568',
    marginTop: 16,
    marginBottom: 8,
  },
  noResultsSubtext: {
    fontSize: 14,
    color: '#718096',
    textAlign: 'center',
  },
  initialStateContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
  },
  initialStateText: {
    fontSize: 16,
    color: '#718096',
    textAlign: 'center',
    marginTop: 16,
  },
});

export default IdiomSearchScreen;
</file>

<file path="src/screens/ImageAnalysisPlaceholderScreen.tsx">
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  Image,
  ScrollView
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const ImageAnalysisPlaceholderScreen: React.FC = () => {
  const [modalVisible, setModalVisible] = useState(false);
  const [imageError, setImageError] = useState(false);

  return (
    <View style={styles.container}>
      <View style={styles.featureComingSoon}>
        <Ionicons name="image-outline" size={80} color="#4A6FA5" style={styles.icon} />
        <Text style={styles.title}>Image Analysis</Text>
        <Text style={styles.subtitle}>Coming Soon</Text>
        <Text style={styles.description}>
          In a future update, you'll be able to analyze images for cultural context and significance.
        </Text>
        
        <TouchableOpacity 
          style={styles.infoButton}
          onPress={() => setModalVisible(true)}
        >
          <Text style={styles.infoButtonText}>Learn More</Text>
        </TouchableOpacity>
      </View>

      {/* Modal with more detailed information about the upcoming feature */}
      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <ScrollView>
              <Text style={styles.modalTitle}>Image Analysis Feature</Text>
              
              <View style={styles.featureDescription}>
                <Ionicons name="scan-outline" size={24} color="#4A6FA5" />
                <Text style={styles.featureText}>
                  Scan objects, gestures, and symbols to understand their cultural significance.
                </Text>
              </View>
              
              <View style={styles.featureDescription}>
                <Ionicons name="alert-circle-outline" size={24} color="#4A6FA5" />
                <Text style={styles.featureText}>
                  Get alerts about potentially inappropriate or sensitive imagery in different cultural contexts.
                </Text>
              </View>
              
              <View style={styles.featureDescription}>
                <Ionicons name="book-outline" size={24} color="#4A6FA5" />
                <Text style={styles.featureText}>
                  Learn about cultural artifacts, traditional dress, and important symbols.
                </Text>
              </View>
              
              <View style={styles.featureDescription}>
                <Ionicons name="restaurant-outline" size={24} color="#4A6FA5" />
                <Text style={styles.featureText}>
                  Identify foods and dining customs from different cultures.
                </Text>
              </View>
              
              {/* Placeholder image visualization */}
              <View style={styles.placeholderImage}>
                <Ionicons name="camera" size={48} color="#4A6FA5" style={{opacity: 0.5}} />
                <Text style={styles.placeholderImageText}>Image Analysis Preview</Text>
              </View>
              
              <Text style={styles.disclaimer}>
                This feature is currently in development. We're working on making cross-cultural
                image recognition accurate, respectful, and helpful for your travels and interactions.
              </Text>
              
              <TouchableOpacity 
                style={styles.closeButton}
                onPress={() => setModalVisible(false)}
              >
                <Text style={styles.closeButtonText}>Close</Text>
              </TouchableOpacity>
            </ScrollView>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F7FA',
    padding: 16,
  },
  featureComingSoon: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  icon: {
    marginBottom: 20,
    opacity: 0.8,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#2D3748',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#4A6FA5',
    marginBottom: 24,
  },
  description: {
    fontSize: 16,
    color: '#4A5568',
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 32,
    paddingHorizontal: 20,
  },
  infoButton: {
    backgroundColor: '#4A6FA5',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  infoButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 16,
    padding: 20,
    width: '90%',
    maxHeight: '80%',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  modalTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#2D3748',
    marginBottom: 24,
    textAlign: 'center',
  },
  featureDescription: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 20,
    paddingHorizontal: 10,
  },
  featureText: {
    fontSize: 16,
    color: '#4A5568',
    marginLeft: 12,
    flex: 1,
    lineHeight: 22,
  },
  placeholderImage: {
    width: '100%',
    height: 200,
    marginVertical: 20,
    borderRadius: 8,
    backgroundColor: '#E2E8F0',
    justifyContent: 'center',
    alignItems: 'center',
  },
  placeholderImageText: {
    fontSize: 16,
    color: '#4A5568',
    marginTop: 10,
  },
  disclaimer: {
    fontSize: 14,
    color: '#718096',
    fontStyle: 'italic',
    textAlign: 'center',
    marginVertical: 20,
    lineHeight: 20,
  },
  closeButton: {
    backgroundColor: '#E2E8F0',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    alignSelf: 'center',
    marginTop: 10,
  },
  closeButtonText: {
    color: '#4A5568',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

export default ImageAnalysisPlaceholderScreen;
</file>

<file path="src/screens/LoginScreen.tsx">
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity, 
  ActivityIndicator,
  Alert,
  Platform,
  KeyboardAvoidingView,
  ScrollView
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { StackNavigationProp } from '@react-navigation/stack';
import { LoginCredentials } from '../types/user';
import { AuthStackParamList } from '../types/navigation';
import { useAuth } from '../services/authContext';

type LoginScreenNavigationProp = StackNavigationProp<AuthStackParamList, 'Login'>;

type Props = {
  navigation: LoginScreenNavigationProp;
};

const LoginScreen: React.FC<Props> = ({ navigation }) => {
  const { signIn, isSigningIn } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [emailError, setEmailError] = useState('');
  const [passwordError, setPasswordError] = useState('');

  // Validate email format
  const validateEmail = (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const isValid = emailRegex.test(email);
    setEmailError(isValid ? '' : 'Please enter a valid email address');
    return isValid;
  };

  // Validate password presence
  const validatePassword = (password: string): boolean => {
    const isValid = password.trim().length > 0;
    setPasswordError(isValid ? '' : 'Please enter your password');
    return isValid;
  };

  const handleLogin = async () => {
    // Validate all fields
    const isEmailValid = validateEmail(email);
    const isPasswordValid = validatePassword(password);

    if (!isEmailValid || !isPasswordValid) {
      return; // Stop if any validation fails
    }

    try {
      const credentials: LoginCredentials = {
        email,
        password,
      };

      await signIn(credentials);
      // Navigation will be handled by the auth state change
    } catch (error) {
      Alert.alert(
        'Login Failed',
        error instanceof Error ? error.message : 'Invalid credentials. Please try again.'
      );
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardAvoidingView}
      >
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <Text style={styles.title}>Welcome Back</Text>
          
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              style={styles.input}
              value={email}
              onChangeText={setEmail}
              onBlur={() => validateEmail(email)}
              placeholder="Enter your email"
              keyboardType="email-address"
              autoCapitalize="none"
            />
            {emailError ? <Text style={styles.errorText}>{emailError}</Text> : null}
          </View>
          
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Password</Text>
            <TextInput
              style={styles.input}
              value={password}
              onChangeText={setPassword}
              onBlur={() => validatePassword(password)}
              placeholder="Enter your password"
              secureTextEntry
            />
            {passwordError ? <Text style={styles.errorText}>{passwordError}</Text> : null}
          </View>
          
          <TouchableOpacity style={styles.forgotPasswordContainer}>
            <Text style={styles.forgotPasswordText}>Forgot Password?</Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={styles.button} 
            onPress={handleLogin}
            disabled={isSigningIn}
          >
            {isSigningIn ? (
              <ActivityIndicator size="small" color="white" />
            ) : (
              <Text style={styles.buttonText}>Log In</Text>
            )}
          </TouchableOpacity>
          
          <View style={styles.footer}>
            <Text style={styles.footerText}>Don't have an account?</Text>
            <TouchableOpacity onPress={() => navigation.navigate('SignUp')}>
              <Text style={styles.linkText}>Sign Up</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  scrollContainer: {
    flexGrow: 1,
    padding: 20,
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 30,
    textAlign: 'center',
    color: '#333',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
    color: '#333',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  errorText: {
    color: 'red',
    fontSize: 14,
    marginTop: 5,
  },
  forgotPasswordContainer: {
    alignItems: 'flex-end',
    marginBottom: 20,
  },
  forgotPasswordText: {
    color: '#4A6FA5',
    fontSize: 14,
  },
  button: {
    backgroundColor: '#4A6FA5',
    borderRadius: 8,
    padding: 15,
    alignItems: 'center',
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 20,
  },
  footerText: {
    color: '#666',
    marginRight: 5,
  },
  linkText: {
    color: '#4A6FA5',
    fontWeight: 'bold',
  },
});

export default LoginScreen;
</file>

<file path="src/screens/SettingsScreen.tsx">
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  ScrollView, 
  Alert,
  Switch,
  ActivityIndicator
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../services/authContext';
import { CompositeNavigationProp } from '@react-navigation/native';
import { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';
import { StackNavigationProp } from '@react-navigation/stack';
import { MainTabParamList, RootStackParamList } from '../types/navigation';
import { 
  getTextAnalysisConsent, 
  getAIImprovementConsent, 
  storeTextAnalysisConsent, 
  storeAIImprovementConsent 
} from '../utils/consentManager';
import { requestDataDeletion, requestDataExport } from '../services/privacyService';

type SettingsScreenNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Settings'>,
  StackNavigationProp<RootStackParamList>
>;

type Props = {
  navigation: SettingsScreenNavigationProp;
};

const SettingsScreen: React.FC<Props> = ({ navigation }) => {
  const { user, signOut } = useAuth();
  const [textAnalysisConsent, setTextAnalysisConsent] = useState<boolean>(false);
  const [aiImprovementConsent, setAiImprovementConsent] = useState<boolean>(false);
  const [isLoadingConsent, setIsLoadingConsent] = useState(true);
  const [isRequestingDeletion, setIsRequestingDeletion] = useState(false);
  const [isRequestingExport, setIsRequestingExport] = useState(false);

  useEffect(() => {
    // Load saved consent preferences
    const loadConsentPreferences = async () => {
      setIsLoadingConsent(true);
      const textConsent = await getTextAnalysisConsent();
      const aiConsent = await getAIImprovementConsent();
      
      setTextAnalysisConsent(textConsent === true);
      setAiImprovementConsent(aiConsent === true);
      setIsLoadingConsent(false);
    };
    
    loadConsentPreferences();
  }, []);

  const handleToggleTextAnalysisConsent = async (value: boolean) => {
    setTextAnalysisConsent(value);
    await storeTextAnalysisConsent(value);
    
    if (!value) {
      // If disabling text analysis consent, also disable AI improvement
      setAiImprovementConsent(false);
      await storeAIImprovementConsent(false);
    }
  };

  const handleToggleAIImprovementConsent = async (value: boolean) => {
    setAiImprovementConsent(value);
    await storeAIImprovementConsent(value);
    
    if (value && !textAnalysisConsent) {
      // If enabling AI improvement, must also enable text analysis consent
      setTextAnalysisConsent(true);
      await storeTextAnalysisConsent(true);
      
      Alert.alert(
        'Consent Update', 
        'Text Analysis Consent has also been enabled, as it\'s required for AI Improvement Consent.'
      );
    }
  };

  const handleDataDeletionRequest = async () => {
    Alert.alert(
      'Request Data Deletion',
      'This will initiate a process to delete all your data from our servers. This action cannot be undone. Do you want to proceed?',
      [
        {
          text: 'Cancel',
          style: 'cancel'
        },
        {
          text: 'Request Deletion',
          style: 'destructive',
          onPress: async () => {
            try {
              setIsRequestingDeletion(true);
              const result = await requestDataDeletion();
              setIsRequestingDeletion(false);
              
              if (result.success) {
                Alert.alert(
                  'Request Submitted',
                  'Your data deletion request has been submitted. We will process it within 30 days and send you a confirmation email.'
                );
              } else {
                throw new Error('Failed to submit request');
              }
            } catch (error) {
              setIsRequestingDeletion(false);
              Alert.alert(
                'Error',
                'Failed to submit data deletion request. Please try again later.'
              );
            }
          }
        }
      ]
    );
  };

  const handleDataExportRequest = async () => {
    Alert.alert(
      'Request Data Export',
      'This will initiate a process to export all your data. We will send you an email with your data within 30 days.',
      [
        {
          text: 'Cancel',
          style: 'cancel'
        },
        {
          text: 'Request Export',
          onPress: async () => {
            try {
              setIsRequestingExport(true);
              const result = await requestDataExport();
              setIsRequestingExport(false);
              
              if (result.success) {
                Alert.alert(
                  'Request Submitted',
                  'Your data export request has been submitted. We will process it within 30 days and send you an email with your data.'
                );
              } else {
                throw new Error('Failed to submit request');
              }
            } catch (error) {
              setIsRequestingExport(false);
              Alert.alert(
                'Error',
                'Failed to submit data export request. Please try again later.'
              );
            }
          }
        }
      ]
    );
  };

  const handleLogout = async () => {
    try {
      await signOut();
    } catch (error) {
      console.error('Logout error:', error);
      Alert.alert('Error', 'Failed to log out. Please try again.');
    }
  };

  const showComingSoonAlert = (feature: string) => {
    Alert.alert(
      "Coming Soon",
      `The ${feature} feature will be available in a future update.`,
      [{ text: "OK" }]
    );
  };

  const renderSettingItem = (
    title: string, 
    icon: keyof typeof Ionicons.glyphMap, 
    onPress: () => void, 
    rightElement?: React.ReactNode
  ) => (
    <TouchableOpacity style={styles.settingItem} onPress={onPress}>
      <View style={styles.settingItemLeft}>
        <View style={styles.iconContainer}>
          <Ionicons name={icon} size={22} color="#4A6FA5" />
        </View>
        <Text style={styles.settingTitle}>{title}</Text>
      </View>
      <View style={styles.settingItemRight}>
        {rightElement || <Ionicons name="chevron-forward" size={20} color="#999" />}
      </View>
    </TouchableOpacity>
  );

  const renderSectionHeader = (title: string) => (
    <View style={styles.sectionHeader}>
      <Text style={styles.sectionTitle}>{title}</Text>
    </View>
  );

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView style={styles.scrollView}>
        <View style={styles.headerContainer}>
          <Text style={styles.headerTitle}>Settings</Text>
        </View>

        <View style={styles.userInfoContainer}>
          <View style={styles.userAvatarPlaceholder}>
            <Text style={styles.userAvatarText}>
              {user?.email?.substring(0, 1).toUpperCase() || 'U'}
            </Text>
          </View>
          <Text style={styles.userEmail}>{user?.email || 'User'}</Text>
        </View>

        {renderSectionHeader("Account")}
        {renderSettingItem(
          "Change Password", 
          "key-outline", 
          () => showComingSoonAlert("change password")
        )}
        {renderSettingItem(
          "Delete Account", 
          "trash-outline", 
          () => showComingSoonAlert("delete account")
        )}
        {renderSettingItem(
          "Logout", 
          "log-out-outline", 
          handleLogout
        )}

        {renderSectionHeader("Preferences")}
        {renderSettingItem(
          "Notifications", 
          "notifications-outline", 
          () => showComingSoonAlert("notifications"),
          <Switch 
            value={false} 
            disabled={true}
            trackColor={{ false: '#d0d0d0', true: '#81b0ff' }}
            thumbColor={'#f4f3f4'}
          />
        )}
        {renderSettingItem(
          "Language (English)", 
          "language-outline", 
          () => showComingSoonAlert("language selection")
        )}
        {renderSettingItem(
          "Appearance", 
          "contrast-outline", 
          () => showComingSoonAlert("appearance settings")
        )}

        {renderSectionHeader("Privacy & Data")}
        {renderSettingItem(
          "Privacy Policy", 
          "shield-checkmark-outline", 
          () => navigation.navigate('PrivacyPolicy')
        )}
        {renderSettingItem(
          "Terms of Service", 
          "document-text-outline", 
          () => navigation.navigate('TermsOfService')
        )}
        {renderSettingItem(
          "Text Analysis Consent", 
          "analytics-outline", 
          () => {}, // No action on press, just toggle
          isLoadingConsent ? (
            <ActivityIndicator size="small" color="#4A6FA5" />
          ) : (
            <Switch 
              value={textAnalysisConsent}
              onValueChange={handleToggleTextAnalysisConsent}
              trackColor={{ false: '#d0d0d0', true: '#81b0ff' }}
              thumbColor={'#f4f3f4'}
            />
          )
        )}
        {renderSettingItem(
          "AI Improvement Consent", 
          "bulb-outline", 
          () => {}, // No action on press, just toggle
          isLoadingConsent ? (
            <ActivityIndicator size="small" color="#4A6FA5" />
          ) : (
            <Switch 
              value={aiImprovementConsent}
              disabled={!textAnalysisConsent}
              onValueChange={handleToggleAIImprovementConsent}
              trackColor={{ false: '#d0d0d0', true: '#81b0ff' }}
              thumbColor={textAnalysisConsent ? '#f4f3f4' : '#d0d0d0'}
            />
          )
        )}
        {renderSettingItem(
          "Request Data Deletion", 
          "trash-bin-outline", 
          handleDataDeletionRequest,
          isRequestingDeletion ? (
            <ActivityIndicator size="small" color="#4A6FA5" />
          ) : null
        )}
        {renderSettingItem(
          "Request Data Export", 
          "download-outline", 
          handleDataExportRequest,
          isRequestingExport ? (
            <ActivityIndicator size="small" color="#4A6FA5" />
          ) : null
        )}

        {renderSectionHeader("About")}
        {renderSettingItem(
          "App Version", 
          "information-circle-outline", 
          () => {}, 
          <Text style={styles.versionText}>1.0.0</Text>
        )}
        {renderSettingItem(
          "Send Feedback", 
          "mail-outline", 
          () => showComingSoonAlert("feedback form")
        )}
        
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
  },
  headerContainer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    marginBottom: 0,
  },
  headerTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
  },
  userInfoContainer: {
    backgroundColor: '#fff',
    paddingVertical: 20,
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    marginBottom: 16,
  },
  userAvatarPlaceholder: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#4A6FA5',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  userAvatarText: {
    color: '#fff',
    fontSize: 24,
    fontWeight: 'bold',
  },
  userEmail: {
    fontSize: 16,
    color: '#333',
  },
  sectionHeader: {
    paddingHorizontal: 20,
    paddingVertical: 8,
    backgroundColor: '#f0f0f0',
  },
  sectionTitle: {
    fontWeight: '600',
    color: '#666',
    fontSize: 14,
  },
  settingItem: {
    flexDirection: 'row',
    backgroundColor: '#fff',
    paddingVertical: 14,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  settingItemLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  iconContainer: {
    width: 30,
    marginRight: 10,
  },
  settingTitle: {
    fontSize: 16,
    color: '#333',
  },
  settingItemRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  versionText: {
    fontSize: 14,
    color: '#999',
  },
});

export default SettingsScreen;
</file>

<file path="src/screens/SignUpScreen.tsx">
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity, 
  ActivityIndicator,
  Alert,
  Platform,
  KeyboardAvoidingView,
  ScrollView
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { StackNavigationProp } from '@react-navigation/stack';
import { SignUpCredentials } from '../types/user';
import { AuthStackParamList } from '../types/navigation';
import { useAuth } from '../services/authContext';

type SignUpScreenNavigationProp = StackNavigationProp<AuthStackParamList, 'SignUp'>;

type Props = {
  navigation: SignUpScreenNavigationProp;
};

const SignUpScreen: React.FC<Props> = ({ navigation }) => {
  const { signUp, isSigningUp } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [emailError, setEmailError] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const [confirmPasswordError, setConfirmPasswordError] = useState('');

  // Validate email format
  const validateEmail = (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const isValid = emailRegex.test(email);
    setEmailError(isValid ? '' : 'Please enter a valid email address');
    return isValid;
  };

  // Validate password complexity
  const validatePassword = (password: string): boolean => {
    const isValid = password.length >= 8;
    setPasswordError(isValid ? '' : 'Password must be at least 8 characters long');
    return isValid;
  };

  // Validate password match
  const validatePasswordMatch = (password: string, confirmPassword: string): boolean => {
    const isValid = password === confirmPassword;
    setConfirmPasswordError(isValid ? '' : 'Passwords do not match');
    return isValid;
  };

  const handleSignUp = async () => {
    // Validate all fields
    const isEmailValid = validateEmail(email);
    const isPasswordValid = validatePassword(password);
    const doPasswordsMatch = validatePasswordMatch(password, confirmPassword);

    if (!isEmailValid || !isPasswordValid || !doPasswordsMatch) {
      return; // Stop if any validation fails
    }

    try {
      const credentials: SignUpCredentials = {
        email,
        password,
        confirmPassword,
      };

      await signUp(credentials);
      // Navigation will be handled by the auth state change
    } catch (error) {
      Alert.alert(
        'Registration Failed',
        error instanceof Error ? error.message : 'Something went wrong. Please try again.'
      );
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardAvoidingView}
      >
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <Text style={styles.title}>Create Account</Text>
          
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              style={styles.input}
              value={email}
              onChangeText={setEmail}
              onBlur={() => validateEmail(email)}
              placeholder="Enter your email"
              keyboardType="email-address"
              autoCapitalize="none"
            />
            {emailError ? <Text style={styles.errorText}>{emailError}</Text> : null}
          </View>
          
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Password</Text>
            <TextInput
              style={styles.input}
              value={password}
              onChangeText={setPassword}
              onBlur={() => validatePassword(password)}
              placeholder="Enter your password"
              secureTextEntry
            />
            {passwordError ? <Text style={styles.errorText}>{passwordError}</Text> : null}
          </View>
          
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Confirm Password</Text>
            <TextInput
              style={styles.input}
              value={confirmPassword}
              onChangeText={setConfirmPassword}
              onBlur={() => validatePasswordMatch(password, confirmPassword)}
              placeholder="Confirm your password"
              secureTextEntry
            />
            {confirmPasswordError ? <Text style={styles.errorText}>{confirmPasswordError}</Text> : null}
          </View>
          
          <TouchableOpacity 
            style={styles.button} 
            onPress={handleSignUp}
            disabled={isSigningUp}
          >
            {isSigningUp ? (
              <ActivityIndicator size="small" color="white" />
            ) : (
              <Text style={styles.buttonText}>Sign Up</Text>
            )}
          </TouchableOpacity>
          
          <View style={styles.footer}>
            <Text style={styles.footerText}>Already have an account?</Text>
            <TouchableOpacity onPress={() => navigation.navigate('Login')}>
              <Text style={styles.linkText}>Log In</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  scrollContainer: {
    flexGrow: 1,
    padding: 20,
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 30,
    textAlign: 'center',
    color: '#333',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
    color: '#333',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  errorText: {
    color: 'red',
    fontSize: 14,
    marginTop: 5,
  },
  button: {
    backgroundColor: '#4A6FA5',
    borderRadius: 8,
    padding: 15,
    alignItems: 'center',
    marginTop: 10,
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 20,
  },
  footerText: {
    color: '#666',
    marginRight: 5,
  },
  linkText: {
    color: '#4A6FA5',
    fontWeight: 'bold',
  },
});

export default SignUpScreen;
</file>

<file path="src/screens/TextAnalysisScreen.tsx">
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  StyleSheet, 
  TouchableOpacity, 
  ActivityIndicator,
  ScrollView,
  Alert
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import { RadioButton } from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import { getCultures } from '../services/cultureService';
import { analyzeText } from '../services/analysisService';
import { Culture } from '../types/culture';
import ConsentModal from '../components/ConsentModal';
import DisclaimerBanner from '../components/DisclaimerBanner';
import FeedbackButton from '../components/FeedbackButton';
import { 
  getTextAnalysisConsent, 
  storeTextAnalysisConsent, 
  storeAIImprovementConsent 
} from '../utils/consentManager';

const TextAnalysisScreen = () => {
  const [text, setText] = useState('');
  const [cultures, setCultures] = useState<Culture[]>([]);
  const [selectedCultureId, setSelectedCultureId] = useState<string>('');
  const [isMyText, setIsMyText] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const [feedback, setFeedback] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);
  const [showConsentModal, setShowConsentModal] = useState(false);
  const [hasCheckedConsent, setHasCheckedConsent] = useState(false);
  const [analysisId, setAnalysisId] = useState<string | undefined>(undefined);

  const navigation = useNavigation();

  // Fetch available cultures when component mounts
  useEffect(() => {
    const fetchCultures = async () => {
      try {
        const culturesData = await getCultures();
        setCultures(culturesData);
        if (culturesData.length > 0) {
          setSelectedCultureId(culturesData[0].id);
        }
      } catch (error) {
        console.error('Failed to fetch cultures:', error);
        setError('Failed to load cultures. Please try again later.');
      }
    };

    fetchCultures();
  }, []);

  // Check if user has already given consent
  useEffect(() => {
    const checkConsent = async () => {
      const hasConsented = await getTextAnalysisConsent();
      setHasCheckedConsent(true);
      // If consent status is null (not set yet), we'll show the modal when they try to analyze
    };

    checkConsent();
  }, []);

  const handleAnalyzeText = async () => {
    if (!text.trim()) {
      Alert.alert('Error', 'Please enter some text to analyze');
      return;
    }

    if (!selectedCultureId) {
      Alert.alert('Error', 'Please select a culture for analysis');
      return;
    }

    // Check for consent before proceeding
    const hasConsented = await getTextAnalysisConsent();
    if (hasConsented === null) {
      // If consent hasn't been given yet, show the modal
      setShowConsentModal(true);
      return;
    } else if (hasConsented === false) {
      // If user explicitly declined consent before
      Alert.alert(
        'Consent Required', 
        'You need to provide consent for text analysis to use this feature. You can update your consent in the Settings > Privacy & Data section.',
        [{ text: 'OK' }]
      );
      return;
    }

    // If we get here, consent has been given, proceed with analysis
    performAnalysis();
  };

  const performAnalysis = async () => {
    setIsLoading(true);
    setError(null);
    setFeedback(null);

    try {
      const result = await analyzeText(text, selectedCultureId, isMyText);
      setFeedback(result);
      // Generate a simple analysis ID for feedback purposes
      setAnalysisId(`text-${Date.now()}`);
    } catch (error) {
      console.error('Text analysis error:', error);
      setError('Failed to analyze text. Please try again later.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleConsentAccepted = async (aiImprovementConsent: boolean) => {
    // Store both consent values
    await storeTextAnalysisConsent(true);
    await storeAIImprovementConsent(aiImprovementConsent);
    
    setShowConsentModal(false);
    
    // Now proceed with the analysis
    performAnalysis();
  };

  const handleConsentDeclined = async () => {
    // Store explicit decline
    await storeTextAnalysisConsent(false);
    await storeAIImprovementConsent(false);
    
    setShowConsentModal(false);
    
    Alert.alert(
      'Consent Declined',
      'You cannot use the text analysis feature without providing consent. You can update your consent in the Settings > Privacy & Data section.',
      [{ text: 'OK' }]
    );
  };

  const renderFeedback = () => {
    if (!feedback) return null;

    return (
      <View style={styles.feedbackContainer}>
        <Text style={styles.feedbackTitle}>Analysis Results</Text>
        
        {/* Add disclaimer banner for AI analysis */}
        <DisclaimerBanner type="ai" />
        
        {feedback.summary && (
          <View style={styles.summaryContainer}>
            <Text style={styles.summaryTitle}>Summary</Text>
            <Text style={styles.summaryText}>{feedback.summary}</Text>
          </View>
        )}

        {feedback.issues && feedback.issues.length > 0 && (
          <View>
            <Text style={styles.issuesTitle}>Cultural Considerations</Text>
            {feedback.issues.map((issue: any, index: number) => (
              <View key={index} style={styles.issueItem}>
                <Text style={styles.issueType}>{issue.type}</Text>
                <Text style={styles.issueText}>{issue.text}</Text>
                <Text style={styles.issueExplanation}>{issue.explanation}</Text>
                {issue.suggestion && (
                  <Text style={styles.issueSuggestion}>
                    <Text style={{fontWeight: 'bold'}}>Suggestion: </Text>
                    {issue.suggestion}
                  </Text>
                )}
                {issue.idiomId && (
                  <TouchableOpacity 
                    style={styles.idiomButton}
                    onPress={() => {
                      // Navigate to idiom details screen
                      // This would be implemented when the Idiom Demystifier is ready
                      Alert.alert('Feature Coming Soon', 'Idiom details will be available in a future update');
                    }}
                  >
                    <Text style={styles.idiomButtonText}>View Idiom Details</Text>
                  </TouchableOpacity>
                )}
              </View>
            ))}
          </View>
        )}

        {feedback.alternatives && feedback.alternatives.length > 0 && (
          <View>
            <Text style={styles.alternativesTitle}>Suggested Alternatives</Text>
            {feedback.alternatives.map((alt: string, index: number) => (
              <Text key={index} style={styles.alternativeText}>• {alt}</Text>
            ))}
          </View>
        )}
        
        {/* Add cultural disclaimer */}
        <DisclaimerBanner type="cultural" />
        
        {/* Add feedback button */}
        <View style={styles.feedbackButtonContainer}>
          <FeedbackButton 
            analysisId={analysisId} 
            analysisType="text" 
            cultureId={selectedCultureId} 
          />
        </View>
      </View>
    );
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.contentContainer}>
        <Text style={styles.title}>Real-Time Text Analysis</Text>
        <Text style={styles.description}>
          Enter text to analyze for cultural nuances and receive feedback.
        </Text>
        
        {/* Add disclaimer banner at the top */}
        <DisclaimerBanner type="cultural" compact={true} />
        
        <View style={styles.formContainer}>
          <Text style={styles.label}>Select Culture:</Text>
          <View style={styles.pickerContainer}>
            <Picker
              selectedValue={selectedCultureId}
              onValueChange={(itemValue) => setSelectedCultureId(itemValue)}
              style={styles.picker}
            >
              {cultures.map((culture) => (
                <Picker.Item 
                  key={culture.id} 
                  label={culture.name} 
                  value={culture.id} 
                />
              ))}
            </Picker>
          </View>

          <Text style={styles.label}>Text Origin:</Text>
          <View style={styles.radioContainer}>
            <View style={styles.radioOption}>
              <RadioButton
                value="mine"
                status={isMyText ? 'checked' : 'unchecked'}
                onPress={() => setIsMyText(true)}
                color="#4A6FA5"
              />
              <Text style={styles.radioLabel}>My Text (I'm writing it)</Text>
            </View>
            <View style={styles.radioOption}>
              <RadioButton
                value="theirs"
                status={!isMyText ? 'checked' : 'unchecked'}
                onPress={() => setIsMyText(false)}
                color="#4A6FA5"
              />
              <Text style={styles.radioLabel}>Their Text (I'm reading it)</Text>
            </View>
          </View>

          <Text style={styles.label}>Enter Text:</Text>
          <TextInput
            style={styles.textInput}
            multiline
            numberOfLines={6}
            placeholder="Type or paste text here..."
            value={text}
            onChangeText={setText}
          />

          <TouchableOpacity 
            style={styles.analyzeButton}
            onPress={handleAnalyzeText}
            disabled={isLoading}
          >
            {isLoading ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <Text style={styles.analyzeButtonText}>Analyze Text</Text>
            )}
          </TouchableOpacity>
        </View>

        {error && (
          <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{error}</Text>
          </View>
        )}

        {renderFeedback()}

        <ConsentModal 
          visible={showConsentModal}
          onAccept={handleConsentAccepted}
          onDecline={handleConsentDeclined}
        />
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  contentContainer: {
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8,
  },
  description: {
    fontSize: 16,
    color: '#666',
    marginBottom: 16,
  },
  formContainer: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 8,
  },
  pickerContainer: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    marginBottom: 16,
  },
  picker: {
    height: 50,
  },
  radioContainer: {
    marginBottom: 16,
  },
  radioOption: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  radioLabel: {
    fontSize: 16,
    color: '#333',
  },
  textInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    padding: 12,
    fontSize: 16,
    minHeight: 120,
    textAlignVertical: 'top',
    marginBottom: 16,
  },
  analyzeButton: {
    backgroundColor: '#4A6FA5',
    paddingVertical: 12,
    borderRadius: 4,
    alignItems: 'center',
  },
  analyzeButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '500',
  },
  errorContainer: {
    backgroundColor: '#ffebee',
    padding: 16,
    borderRadius: 8,
    marginBottom: 16,
  },
  errorText: {
    color: '#c62828',
    fontSize: 16,
  },
  feedbackContainer: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  feedbackTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 16,
  },
  summaryContainer: {
    marginBottom: 16,
    padding: 12,
    backgroundColor: '#f0f4f8',
    borderRadius: 8,
  },
  summaryTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  summaryText: {
    fontSize: 16,
    color: '#333',
  },
  issuesTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  issueItem: {
    marginBottom: 16,
    padding: 12,
    backgroundColor: '#fff',
    borderRadius: 8,
    borderLeftWidth: 4,
    borderLeftColor: '#4A6FA5',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },
  issueType: {
    fontSize: 16,
    fontWeight: '600',
    color: '#4A6FA5',
    marginBottom: 4,
  },
  issueText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 8,
  },
  issueExplanation: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
  },
  issueSuggestion: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
  },
  idiomButton: {
    backgroundColor: '#4A6FA5',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    alignSelf: 'flex-start',
  },
  idiomButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
  },
  alternativesTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginTop: 16,
    marginBottom: 12,
  },
  alternativeText: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
    paddingLeft: 8,
  },
  feedbackButtonContainer: {
    marginTop: 16,
    alignItems: 'flex-end',
  }
});

export default TextAnalysisScreen;
</file>

<file path="src/services/analysisService.ts">
import axios from 'axios';
import { API_BASE_URL } from '../utils/constants';
import { getToken } from './authService';

/**
 * Analyze text for cultural nuances
 * @param text The text to analyze
 * @param cultureId The ID of the target culture
 * @param isMyText Whether this is the user's own text (true) or someone else's (false)
 * @returns Analysis results
 */
export const analyzeText = async (
  text: string,
  cultureId: string,
  isMyText: boolean
) => {
  try {
    const token = await getToken();
    
    const response = await axios.post(
      `${API_BASE_URL}/analysis/text`,
      {
        text,
        cultureId,
        textOrigin: isMyText ? 'mine' : 'theirs'
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    return response.data;
  } catch (error) {
    console.error('Error analyzing text:', error);
    throw error;
  }
};

/**
 * Mock implementation for text analysis during development
 * This can be used until the backend API is fully implemented
 */
export const mockAnalyzeText = async (
  text: string,
  cultureId: string,
  isMyText: boolean
) => {
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  // For demo purposes, return mock data based on input
  const containsIdiom = text.toLowerCase().includes('break a leg') || 
                       text.toLowerCase().includes('piece of cake');
  
  const containsFormalityIssue = text.toLowerCase().includes('hey') || 
                               text.toLowerCase().includes('whats up');
  
  const mockResponse = {
    summary: `Analysis of text in relation to ${cultureId === 'jp' ? 'Japanese' : 
              cultureId === 'de' ? 'German' : 
              cultureId === 'sa' ? 'Saudi Arabian' : 'selected'} culture.`,
    issues: []
  };
  
  if (containsIdiom) {
    mockResponse.issues.push({
      type: 'Idiom',
      text: 'break a leg',
      explanation: 'This English idiom wishing someone good luck may not translate well in other cultures and could be confusing.',
      suggestion: 'Consider using "Good luck" or "All the best" instead.',
      idiomId: 'idiom123'
    });
  }
  
  if (containsFormalityIssue) {
    mockResponse.issues.push({
      type: 'Formality',
      text: text.toLowerCase().includes('hey') ? 'hey' : 'whats up',
      explanation: 'This greeting is too casual for formal or initial business interactions in many cultures.',
      suggestion: 'Consider "Good morning/afternoon" or "Hello" for a more universally appropriate greeting.'
    });
  }
  
  // If analyzing someone else's text (interpretation aid)
  if (!isMyText && text.length > 20) {
    mockResponse.issues.push({
      type: 'Context',
      text: '(General observation)',
      explanation: 'When interpreting this message, consider that in some cultures, communication may be more indirect. Look for subtle cues rather than explicit statements.'
    });
  }
  
  // If no specific issues found, add a general note
  if (mockResponse.issues.length === 0) {
    mockResponse.issues.push({
      type: 'General',
      text: '(No specific issues detected)',
      explanation: 'No obvious cultural concerns detected in the provided text. However, always consider context and relationship with the recipient.'
    });
  }
  
  // Add alternative phrasings if appropriate (for user's own text)
  if (isMyText && text.length > 10) {
    mockResponse.alternatives = [
      'A more culturally adapted version might be: "' + text.replace(/hey/i, 'Hello').replace(/whats up/i, 'How are you') + '"',
      'For formal contexts: "' + text.replace(/break a leg/i, 'I wish you success').replace(/piece of cake/i, 'very straightforward') + '"'
    ];
  }
  
  return mockResponse;
};

// Use mock implementation for now
// When real backend is ready, replace this with the actual implementation
export { mockAnalyzeText as analyzeText };
</file>

<file path="src/services/authContext.tsx">
import React, { createContext, useState, useEffect, useContext } from 'react';
import { User, LoginCredentials, SignUpCredentials } from '../types/user';
import { login, signUp, logout } from './authService';
import { 
  getUserData, 
  storeUserData, 
  getToken, 
  storeToken, 
  clearStorage 
} from '../utils/secureStorage';

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  isSigningIn: boolean;
  isSigningUp: boolean;
  error: string | null;
  signIn: (credentials: LoginCredentials) => Promise<void>;
  signUp: (credentials: SignUpCredentials) => Promise<void>;
  signOut: () => Promise<void>;
}

// Create the auth context with default value
const AuthContext = createContext<AuthContextType>({
  user: null,
  isLoading: true,
  isSigningIn: false,
  isSigningUp: false,
  error: null,
  signIn: async () => {},
  signUp: async () => {},
  signOut: async () => {}
});

// Auth provider component to wrap the app
export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isSigningIn, setIsSigningIn] = useState(false);
  const [isSigningUp, setIsSigningUp] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Check for existing token on app load
  useEffect(() => {
    const bootstrapAsync = async () => {
      try {
        const token = await getToken();
        if (token) {
          const userData = await getUserData();
          setUser(userData);
        }
      } catch (e) {
        console.error('Failed to load user data:', e);
      } finally {
        setIsLoading(false);
      }
    };

    bootstrapAsync();
  }, []);

  // Sign in function
  const signInUser = async (credentials: LoginCredentials) => {
    setIsSigningIn(true);
    setError(null);
    
    try {
      const user = await login(credentials);
      await storeUserData(user);
      await storeToken('mock-jwt-token'); // In a real app, this would be a JWT from the API
      setUser(user);
    } catch (e) {
      setError(e instanceof Error ? e.message : 'An error occurred during sign in');
      throw e; // Re-throw to allow caller to handle
    } finally {
      setIsSigningIn(false);
    }
  };

  // Sign up function
  const signUpUser = async (credentials: SignUpCredentials) => {
    setIsSigningUp(true);
    setError(null);
    
    try {
      const user = await signUp(credentials);
      await storeUserData(user);
      await storeToken('mock-jwt-token'); // In a real app, this would be a JWT from the API
      setUser(user);
    } catch (e) {
      setError(e instanceof Error ? e.message : 'An error occurred during sign up');
      throw e; // Re-throw to allow caller to handle
    } finally {
      setIsSigningUp(false);
    }
  };

  // Sign out function
  const signOutUser = async () => {
    try {
      await logout(); // API call if needed
      await clearStorage();
      setUser(null);
    } catch (e) {
      console.error('Error signing out:', e);
      throw e;
    }
  };

  return (
    <AuthContext.Provider 
      value={{
        user,
        isLoading,
        isSigningIn,
        isSigningUp,
        error,
        signIn: signInUser,
        signUp: signUpUser,
        signOut: signOutUser
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

// Custom hook to use the auth context
export const useAuth = () => useContext(AuthContext);

export default AuthContext;
</file>

<file path="src/services/authService.ts">
import { SignUpCredentials, LoginCredentials, User } from '../types/user';
import { executeQuery } from '../utils/database';
import { v4 as uuidv4 } from 'uuid';
import bcrypt from 'bcryptjs';

// For demo purposes, we'll use a mock API
// In a real application, these would call actual API endpoints
const BASE_URL = 'https://api.example.com'; // Replace with actual API URL when available

export const signUp = async (credentials: SignUpCredentials): Promise<User> => {
  // Validate password match
  if (credentials.password !== credentials.confirmPassword) {
    throw new Error('Passwords do not match');
  }
  
  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(credentials.email)) {
    throw new Error('Invalid email format');
  }
  
  // Validate password (min length, complexity)
  if (credentials.password.length < 8) {
    throw new Error('Password must be at least 8 characters long');
  }
  
  try {
    // Check if email already exists
    const existingUsers = await executeQuery<{ count: number }>(
      'SELECT COUNT(*) as count FROM Users WHERE Email = @email',
      { email: credentials.email }
    );
    
    if (existingUsers[0].count > 0) {
      throw new Error('Email already exists');
    }
    
    // Generate new user ID
    const userId = `user-${uuidv4()}`;
    
    // Hash the password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(credentials.password, salt);
    
    // Insert the new user
    await executeQuery(
      `INSERT INTO Users (UserID, Email, HashedPassword, CreatedAt, IsActive, IsVerified) 
       VALUES (@userId, @email, @hashedPassword, GETDATE(), 1, 0)`,
      {
        userId,
        email: credentials.email,
        hashedPassword
      }
    );
    
    // Return the created user (without password)
    return {
      id: userId,
      email: credentials.email,
      createdAt: new Date().toISOString()
    };
  } catch (error) {
    console.error('Error during sign up:', error);
    throw error;
  }
};

export const login = async (credentials: LoginCredentials): Promise<User> => {
  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(credentials.email)) {
    throw new Error('Invalid email format');
  }
  
  try {
    // Find user by email
    const users = await executeQuery<User & { HashedPassword: string }>(
      `SELECT UserID as id, Email as email, HashedPassword, CreatedAt as createdAt
       FROM Users WHERE Email = @email AND IsActive = 1`,
      { email: credentials.email }
    );
    
    if (users.length === 0) {
      throw new Error('Invalid credentials');
    }
    
    const user = users[0];
    
    // Verify password
    const isMatch = await bcrypt.compare(credentials.password, user.HashedPassword);
    if (!isMatch) {
      throw new Error('Invalid credentials');
    }
    
    // Update LastLogin
    await executeQuery(
      'UPDATE Users SET LastLogin = GETDATE() WHERE UserID = @userId',
      { userId: user.id }
    );
    
    // Return the user without password
    const { HashedPassword, ...userWithoutPassword } = user;
    return userWithoutPassword;
  } catch (error) {
    console.error('Error during login:', error);
    throw error;
  }
};

export const logout = async (): Promise<void> => {
  // No database operation required for logout in this implementation
  // Client-side token will be removed
  return Promise.resolve();
};
</file>

<file path="src/services/cultureService.ts">
import { Culture, CulturalNorm, Idiom, CulturalBriefing, NormCategory, SeverityLevel, PolitenessLevel } from '../types/culture';
import { executeQuery } from '../utils/database';

// Get all available cultures
export const getAllCultures = async (): Promise<Culture[]> => {
  try {
    const cultures = await executeQuery<Culture>(`
      SELECT 
        CultureID as id, 
        CultureName as name, 
        Region as region, 
        PrimaryLanguage as primaryLanguage, 
        Description as description, 
        LastUpdated as lastUpdated 
      FROM Cultures
    `);
    
    return cultures;
  } catch (error) {
    console.error('Error fetching cultures:', error);
    throw error;
  }
};

// Get a specific culture by ID
export const getCultureById = async (cultureId: string): Promise<Culture | null> => {
  try {
    const cultures = await executeQuery<Culture>(`
      SELECT 
        CultureID as id, 
        CultureName as name, 
        Region as region, 
        PrimaryLanguage as primaryLanguage, 
        Description as description, 
        LastUpdated as lastUpdated 
      FROM Cultures 
      WHERE CultureID = @cultureId
    `, { cultureId });
    
    return cultures.length > 0 ? cultures[0] : null;
  } catch (error) {
    console.error(`Error fetching culture with ID ${cultureId}:`, error);
    throw error;
  }
};

// Get all cultural norms for a specific culture
export const getNormsByCultureId = async (cultureId: string): Promise<CulturalNorm[]> => {
  try {
    const norms = await executeQuery<CulturalNorm>(`
      SELECT 
        NormID as id, 
        CultureID as cultureId, 
        Category as category, 
        SubCategory as subCategory, 
        Description as description, 
        DoBehavior as doBehavior, 
        DontBehavior as dontBehavior, 
        Explanation as explanation, 
        SeverityLevel as severityLevel, 
        LastUpdated as lastUpdated 
      FROM CulturalNorms 
      WHERE CultureID = @cultureId
    `, { cultureId });
    
    return norms;
  } catch (error) {
    console.error(`Error fetching norms for culture ID ${cultureId}:`, error);
    throw error;
  }
};

// Get cultural norms by category for a specific culture
export const getNormsByCategory = async (cultureId: string, category: NormCategory): Promise<CulturalNorm[]> => {
  try {
    const norms = await executeQuery<CulturalNorm>(`
      SELECT 
        NormID as id, 
        CultureID as cultureId, 
        Category as category, 
        SubCategory as subCategory, 
        Description as description, 
        DoBehavior as doBehavior, 
        DontBehavior as dontBehavior, 
        Explanation as explanation, 
        SeverityLevel as severityLevel, 
        LastUpdated as lastUpdated 
      FROM CulturalNorms 
      WHERE CultureID = @cultureId AND Category = @category
    `, { cultureId, category });
    
    return norms;
  } catch (error) {
    console.error(`Error fetching norms for culture ID ${cultureId} and category ${category}:`, error);
    throw error;
  }
};

// Get a full cultural briefing for a culture
export const getCulturalBriefing = async (cultureId: string): Promise<CulturalBriefing | null> => {
  try {
    const culture = await getCultureById(cultureId);
    if (!culture) return null;
    
    const norms = await getNormsByCultureId(cultureId);
    
    // Group norms by category
    const normsByCategory = norms.reduce<Record<string, CulturalNorm[]>>((acc, norm) => {
      const category = norm.category.toString();
      if (!acc[category]) acc[category] = [];
      acc[category].push(norm);
      return acc;
    }, {});
    
    return {
      culture,
      normsByCategory,
      lastUpdated: culture.lastUpdated
    };
  } catch (error) {
    console.error(`Error fetching cultural briefing for culture ID ${cultureId}:`, error);
    throw error;
  }
};

// Search for idioms in a specific culture
export const searchIdiomsByCulture = async (cultureId: string, query?: string): Promise<Idiom[]> => {
  try {
    let sql = `
      SELECT 
        i.IdiomID as id, 
        i.CultureID as cultureId, 
        i.Language as language, 
        i.Phrase as phrase, 
        i.LiteralTranslation as literalTranslation, 
        i.Meaning as meaning, 
        i.ContextNotes as contextNotes, 
        i.PolitenessLevel as politenessLevel, 
        i.LastUpdated as lastUpdated
      FROM Idioms i
      WHERE i.CultureID = @cultureId
    `;
    
    const params: any = { cultureId };
    
    if (query && query.trim() !== '') {
      sql += ` AND (i.Phrase LIKE @query OR i.Meaning LIKE @query)`;
      params.query = `%${query}%`;
    }
    
    const idioms = await executeQuery<Idiom>(sql, params);
    
    // Fetch usage examples for each idiom
    for (const idiom of idioms) {
      const usageExamples = await executeQuery<{ ExampleText: string }>(`
        SELECT ExampleText FROM IdiomUsageExamples 
        WHERE IdiomID = @idiomId
      `, { idiomId: idiom.id });
      
      idiom.usageExamples = usageExamples.map(ex => ex.ExampleText);
    }
    
    return idioms;
  } catch (error) {
    console.error(`Error searching idioms for culture ID ${cultureId}:`, error);
    throw error;
  }
};

// Get a specific idiom by ID
export const getIdiomById = async (idiomId: string): Promise<Idiom | null> => {
  try {
    const idioms = await executeQuery<Idiom>(`
      SELECT 
        IdiomID as id, 
        CultureID as cultureId, 
        Language as language, 
        Phrase as phrase, 
        LiteralTranslation as literalTranslation, 
        Meaning as meaning, 
        ContextNotes as contextNotes, 
        PolitenessLevel as politenessLevel, 
        LastUpdated as lastUpdated 
      FROM Idioms 
      WHERE IdiomID = @idiomId
    `, { idiomId });
    
    if (idioms.length === 0) return null;
    
    const idiom = idioms[0];
    
    // Get usage examples
    const usageExamples = await executeQuery<{ ExampleText: string }>(`
      SELECT ExampleText FROM IdiomUsageExamples 
      WHERE IdiomID = @idiomId
    `, { idiomId });
    
    idiom.usageExamples = usageExamples.map(ex => ex.ExampleText);
    
    return idiom;
  } catch (error) {
    console.error(`Error fetching idiom with ID ${idiomId}:`, error);
    throw error;
  }
};
</file>

<file path="src/services/feedbackService.ts">
import { API_BASE_URL } from '../utils/config';
import { getAuthToken } from './authService';

/**
 * Feedback data interface
 */
export interface FeedbackData {
  analysisId?: string;
  analysisType?: string;
  cultureId?: string;
  feedbackType: string;
  feedbackText: string;
  timestamp: string;
}

/**
 * Submit user feedback about AI analysis
 * 
 * @param {FeedbackData} feedback - The feedback data to submit
 * @returns {Promise<{ success: boolean, message?: string }>} Result of the submission
 */
export const submitFeedback = async (feedback: FeedbackData): Promise<{ success: boolean, message?: string }> => {
  try {
    const token = await getAuthToken();
    
    const response = await fetch(`${API_BASE_URL}/api/feedback`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(token ? { 'Authorization': `Bearer ${token}` } : {})
      },
      body: JSON.stringify(feedback)
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to submit feedback');
    }
    
    return {
      success: true,
      message: data.message
    };
  } catch (error) {
    console.error('Feedback submission error:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
};

/**
 * Get feedback categories
 * 
 * @returns {Promise<string[]>} List of feedback categories
 */
export const getFeedbackCategories = async (): Promise<string[]> => {
  return [
    'bias',
    'inaccuracy',
    'offensive',
    'other'
  ];
};
</file>

<file path="src/services/privacyService.ts">
import { API_BASE_URL } from '../utils/config';
import { getAuthToken } from './authService';

/**
 * Request deletion of all user data
 * 
 * @returns {Promise<{ success: boolean, message?: string }>} Result of the request
 */
export const requestDataDeletion = async (): Promise<{ success: boolean, message?: string }> => {
  try {
    const token = await getAuthToken();
    
    if (!token) {
      throw new Error('Authentication required');
    }
    
    const response = await fetch(`${API_BASE_URL}/api/user/data-deletion-request`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      }
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to request data deletion');
    }
    
    return {
      success: true,
      message: data.message
    };
  } catch (error) {
    console.error('Data deletion request error:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
};

/**
 * Request export of all user data
 * 
 * @returns {Promise<{ success: boolean, message?: string }>} Result of the request
 */
export const requestDataExport = async (): Promise<{ success: boolean, message?: string }> => {
  try {
    const token = await getAuthToken();
    
    if (!token) {
      throw new Error('Authentication required');
    }
    
    const response = await fetch(`${API_BASE_URL}/api/user/data-export-request`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      }
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to request data export');
    }
    
    return {
      success: true,
      message: data.message
    };
  } catch (error) {
    console.error('Data export request error:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
};
</file>

<file path="src/types/culture.ts">
export interface Culture {
  id: string;
  name: string;
  region: string;
  primaryLanguage: string;
  description: string;
  lastUpdated: string;
}

export interface CulturalNorm {
  id: string;
  cultureId: string;
  category: NormCategory;
  subCategory?: string;
  description: string;
  doBehavior: string;
  dontBehavior: string;
  explanation: string;
  severityLevel: SeverityLevel;
  lastUpdated: string;
}

export interface Idiom {
  id: string;
  cultureId: string;
  language: string;
  phrase: string;
  literalTranslation: string;
  meaning: string;
  usageExamples: string[];
  contextNotes?: string;
  politenessLevel: PolitenessLevel;
  lastUpdated: string;
}

export enum NormCategory {
  Greeting = 'Greeting',
  Dining = 'Dining',
  Business = 'Business',
  Gesture = 'Gesture',
  SensitiveTopic = 'SensitiveTopic',
  Communication = 'Communication',
  General = 'General'
}

export enum SeverityLevel {
  Low = 'Low',
  Medium = 'Medium',
  High = 'High',
  Critical = 'Critical'
}

export type PolitenessLevel = 'formal' | 'informal' | 'slang' | 'vulgar';

export interface CulturalBriefing {
  cultureInfo: Culture;
  norms: CulturalNorm[];
}
</file>

<file path="src/types/custom.d.ts">
declare module 'react-native-safe-area-context' {
  import React from 'react';
  import { ViewProps } from 'react-native';

  export interface SafeAreaProviderProps extends ViewProps {
    children?: React.ReactNode;
  }

  export const SafeAreaProvider: React.FC<SafeAreaProviderProps>;
}
</file>

<file path="src/types/navigation.ts">
import { NavigatorScreenParams } from '@react-navigation/native';

// Define the root stack navigator parameter list
export type RootStackParamList = {
  Auth: NavigatorScreenParams<AuthStackParamList>;
  Main: NavigatorScreenParams<MainTabParamList>;
  PrivacyPolicy: undefined;
  TermsOfService: undefined;
};

// Auth stack navigator parameter list
export type AuthStackParamList = {
  Login: undefined;
  SignUp: undefined;
};

// Main tab navigator parameter list
export type MainTabParamList = {
  Home: undefined;
  CulturalBriefings: NavigatorScreenParams<CulturalBriefingStackParamList>;
  Analysis: undefined;
  Idioms: NavigatorScreenParams<IdiomsStackParamList>;
  ImageAnalysis: undefined;
  Settings: undefined;
};

// Cultural Briefing stack parameter list
export type CulturalBriefingStackParamList = {
  CultureSelection: undefined;
  CulturalBriefingDetail: { cultureId: string };
};

// Idioms stack parameter list
export type IdiomsStackParamList = {
  IdiomSearch: undefined;
  IdiomDetail: { idiomId: string, idiomPhrase?: string };
};
</file>

<file path="src/types/react-native.d.ts">
declare module 'react-native' {
  import React from 'react';

  export interface ViewProps {
    style?: any;
    children?: React.ReactNode;
  }

  export interface TextProps {
    style?: any;
    children?: React.ReactNode;
  }

  export interface StyleSheetStatic {
    create<T extends Record<string, any>>(styles: T): T;
  }

  export class View extends React.Component<ViewProps> {}
  export class Text extends React.Component<TextProps> {}
  
  export const StyleSheet: StyleSheetStatic;
}
</file>

<file path="src/types/react.d.ts">
declare module 'react' {
  export interface ReactElement<P = any, T = any> {
    type: T;
    props: P;
    key: string | null;
  }

  export interface ReactNode {
    children?: ReactNode;
  }

  export function createElement(
    type: any,
    props?: any,
    ...children: any[]
  ): ReactElement;

  export const Fragment: any;

  export default {
    createElement,
    Fragment
  };
}
</file>

<file path="src/types/user.ts">
export interface User {
  id: string;
  email: string;
  createdAt: string;
}

export interface SignUpCredentials {
  email: string;
  password: string;
  confirmPassword: string;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}
</file>

<file path="src/utils/config.ts">
/**
 * Application Configuration
 * 
 * This file contains configuration settings for the application.
 * Different environments (development, production) can be configured here.
 */

// API Base URL - Change this based on your environment
export const API_BASE_URL = __DEV__ 
  ? 'http://localhost:3000'  // Development
  : 'https://api.culturalai.com'; // Production

// Feature flags
export const FEATURES = {
  ENABLE_SCENARIO_SIMULATOR: false, // Disabled for MVP
  ENABLE_SPEECH_ANALYSIS: false,    // Disabled for MVP
  ENABLE_IMAGE_ANALYSIS: false,     // Disabled for MVP
};

// App version
export const APP_VERSION = '1.0.0';

// Privacy settings
export const PRIVACY = {
  // How long to keep analyzed text (0 = don't store)
  TEXT_RETENTION_DAYS: 0,
  
  // Default consent settings (user can override)
  DEFAULT_TEXT_ANALYSIS_CONSENT: false,
  DEFAULT_AI_IMPROVEMENT_CONSENT: false,
};

// Timeouts
export const TIMEOUTS = {
  API_REQUEST_MS: 10000, // 10 seconds
  TEXT_ANALYSIS_MS: 15000, // 15 seconds
};
</file>

<file path="src/utils/consentManager.ts">
import AsyncStorage from '@react-native-async-storage/async-storage';

const CONSENT_KEYS = {
  TEXT_ANALYSIS: 'consent_text_analysis',
  AI_IMPROVEMENT: 'consent_ai_improvement',
};

/**
 * Stores text analysis consent preference
 * @param hasConsented Whether the user has given consent
 */
export const storeTextAnalysisConsent = async (hasConsented: boolean): Promise<void> => {
  try {
    await AsyncStorage.setItem(CONSENT_KEYS.TEXT_ANALYSIS, hasConsented.toString());
  } catch (error) {
    console.error('Error storing text analysis consent:', error);
  }
};

/**
 * Stores AI improvement data usage consent preference
 * @param hasConsented Whether the user has given consent
 */
export const storeAIImprovementConsent = async (hasConsented: boolean): Promise<void> => {
  try {
    await AsyncStorage.setItem(CONSENT_KEYS.AI_IMPROVEMENT, hasConsented.toString());
  } catch (error) {
    console.error('Error storing AI improvement consent:', error);
  }
};

/**
 * Retrieves text analysis consent preference
 * @returns Boolean indicating if user has consented, or null if no preference has been set
 */
export const getTextAnalysisConsent = async (): Promise<boolean | null> => {
  try {
    const value = await AsyncStorage.getItem(CONSENT_KEYS.TEXT_ANALYSIS);
    if (value === null) {
      return null;
    }
    return value === 'true';
  } catch (error) {
    console.error('Error retrieving text analysis consent:', error);
    return null;
  }
};

/**
 * Retrieves AI improvement consent preference
 * @returns Boolean indicating if user has consented, or null if no preference has been set
 */
export const getAIImprovementConsent = async (): Promise<boolean | null> => {
  try {
    const value = await AsyncStorage.getItem(CONSENT_KEYS.AI_IMPROVEMENT);
    if (value === null) {
      return null;
    }
    return value === 'true';
  } catch (error) {
    console.error('Error retrieving AI improvement consent:', error);
    return null;
  }
};

/**
 * Resets all consent preferences
 */
export const resetAllConsents = async (): Promise<void> => {
  try {
    await AsyncStorage.multiRemove([
      CONSENT_KEYS.TEXT_ANALYSIS,
      CONSENT_KEYS.AI_IMPROVEMENT,
    ]);
  } catch (error) {
    console.error('Error resetting consents:', error);
  }
};
</file>

<file path="src/utils/constants.ts">
/**
 * Application Constants
 */

// API Configuration
export const API_BASE_URL = 'http://localhost:3000/api';

// App Theme Colors
export const COLORS = {
  primary: '#4A6FA5',
  secondary: '#E6A817',
  background: '#F5F7FA',
  white: '#FFFFFF',
  text: '#4D5156',
  error: '#D93025',
  success: '#34A853',
  warning: '#FBBC05',
  lightGray: '#E1E4E8',
  darkGray: '#A0A5AA',
};

// Storage Keys
export const STORAGE_KEYS = {
  authToken: 'auth_token',
  userId: 'user_id',
  selectedCulture: 'selected_culture',
  userPreferences: 'user_preferences',
};

// App Settings
export const APP_SETTINGS = {
  version: '0.1.0',
  defaultLanguage: 'en',
};

// Timeout Durations (in milliseconds)
export const TIMEOUTS = {
  apiRequest: 10000, // 10 seconds
  tokenRefresh: 300000, // 5 minutes
};

// Screen Names (for navigation)
export const SCREENS = {
  login: 'Login',
  signup: 'SignUp',
  home: 'Home',
  culturalBriefings: 'CulturalBriefings',
  cultureSelection: 'CultureSelection',
  culturalBriefingDetail: 'CulturalBriefingDetail',
  analysis: 'Analysis',
  textAnalysis: 'TextAnalysis',
  idioms: 'Idioms',
  settings: 'Settings',
};
</file>

<file path="src/utils/database.ts">
import sql from 'mssql';
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs';

// Load environment variables from .env
dotenv.config();

// Try to load from database.env if available
const dbEnvPath = path.resolve(process.cwd(), 'database.env');
if (fs.existsSync(dbEnvPath)) {
  dotenv.config({ path: dbEnvPath });
}

// Database configuration
const config = {
  server: process.env.DB_SERVER || 'localhost',
  database: process.env.DB_NAME || 'CulturalAI',
  user: process.env.DB_USER || 'sa',
  password: process.env.DB_PASSWORD || '',
  options: {
    trustServerCertificate: true, // For development only; don't use in production
    enableArithAbort: true
  }
};

console.log('Database connection config:', {
  server: config.server,
  database: config.database,
  user: config.user,
  // Don't log password
});

// Create a connection pool
const pool = new sql.ConnectionPool(config);
const poolConnect = pool.connect();

// Handle connection errors
poolConnect.catch(err => {
  console.error('Database connection error:', err);
});

/**
 * Execute a SQL query with parameters
 * @param query The SQL query to execute
 * @param params Parameters for the query
 * @returns Promise with the query result
 */
export async function executeQuery<T>(query: string, params: any = {}): Promise<T[]> {
  try {
    // Wait for pool connection to initialize
    await poolConnect;
    
    // Create request and add parameters
    const request = pool.request();
    
    // Add parameters to the request
    Object.entries(params).forEach(([key, value]) => {
      request.input(key, value);
    });
    
    // Execute the query
    const result = await request.query(query);
    
    return result.recordset as T[];
  } catch (error) {
    console.error('Error executing query:', error);
    throw error;
  }
}

/**
 * Execute a stored procedure with parameters
 * @param procedure The name of the stored procedure
 * @param params Parameters for the stored procedure
 * @returns Promise with the procedure result
 */
export async function executeStoredProcedure<T>(procedure: string, params: any = {}): Promise<T[]> {
  try {
    // Wait for pool connection to initialize
    await poolConnect;
    
    // Create request and add parameters
    const request = pool.request();
    
    // Add parameters to the request
    Object.entries(params).forEach(([key, value]) => {
      request.input(key, value);
    });
    
    // Execute the stored procedure
    const result = await request.execute(procedure);
    
    return result.recordset as T[];
  } catch (error) {
    console.error('Error executing stored procedure:', error);
    throw error;
  }
}

/**
 * Close the database connection pool
 */
export async function closePool(): Promise<void> {
  try {
    await pool.close();
    console.log('Database connection pool closed');
  } catch (error) {
    console.error('Error closing connection pool:', error);
    throw error;
  }
}

// Make sure to close the pool when your application shuts down
process.on('SIGINT', async () => {
  await closePool();
  process.exit(0);
});

export default {
  executeQuery,
  executeStoredProcedure,
  closePool
};
</file>

<file path="src/utils/secureStorage.ts">
import * as SecureStore from 'expo-secure-store';
import { User } from '../types/user';

// Key constants
const USER_KEY = 'cultural_ai_user';
const TOKEN_KEY = 'cultural_ai_token';

// Store user data securely
export const storeUserData = async (user: User): Promise<void> => {
  try {
    const jsonValue = JSON.stringify(user);
    await SecureStore.setItemAsync(USER_KEY, jsonValue);
  } catch (error) {
    console.error('Error storing user data:', error);
    throw error;
  }
};

// Retrieve user data
export const getUserData = async (): Promise<User | null> => {
  try {
    const jsonValue = await SecureStore.getItemAsync(USER_KEY);
    return jsonValue ? JSON.parse(jsonValue) : null;
  } catch (error) {
    console.error('Error retrieving user data:', error);
    return null;
  }
};

// Store JWT token
export const storeToken = async (token: string): Promise<void> => {
  try {
    await SecureStore.setItemAsync(TOKEN_KEY, token);
  } catch (error) {
    console.error('Error storing token:', error);
    throw error;
  }
};

// Retrieve JWT token
export const getToken = async (): Promise<string | null> => {
  try {
    return await SecureStore.getItemAsync(TOKEN_KEY);
  } catch (error) {
    console.error('Error retrieving token:', error);
    return null;
  }
};

// Clear all stored data (for logout)
export const clearStorage = async (): Promise<void> => {
  try {
    await SecureStore.deleteItemAsync(USER_KEY);
    await SecureStore.deleteItemAsync(TOKEN_KEY);
  } catch (error) {
    console.error('Error clearing storage:', error);
    throw error;
  }
};
</file>

<file path="src/utils/testConnection.ts">
import { executeQuery, closePool } from './database';

async function testConnection() {
  try {
    console.log('Testing database connection...');
    
    // Try to query the database version
    const result = await executeQuery<{ version: string }>('SELECT @@VERSION as version');
    
    console.log('Connection successful!');
    console.log('SQL Server version:', result[0].version);
    
    // Test querying Cultures table
    const cultures = await executeQuery('SELECT COUNT(*) as count FROM Cultures');
    console.log('Number of cultures in the database:', cultures[0].count);
    
    await closePool();
  } catch (error) {
    console.error('Database connection test failed:', error);
  }
}

// Run the test
testConnection();
</file>

<file path="src/index.d.ts">
declare module 'react' {
  export = React;
  export as namespace React;

  const React: any;
}

declare module 'react-native' {
  export const View: any;
  export const Text: any;
  export const StyleSheet: {
    create: (styles: any) => any;
  };
}
</file>

<file path=".cursor-tasks.md">
# Combined Project Plan: AI Cultural Nuance Navigator & Project Document Mobile Refinement

## Part 1: Project Plan - AI-Powered "Cultural Nuance Navigator" Application

### Overview

This section outlines the user stories and tasks required to build the AI-Powered "Cultural Nuance Navigator" mobile application. The goal is to provide users with real-time, context-aware insights into cultural nuances, etiquette, social norms, idioms, and unspoken expectations of a different culture they are interacting with.

### MVP / Live Demo Strategy

**Goal:** To have a functional live demo of the "Cultural Nuance Navigator" application showcasing its core value proposition.

**Core Features for Live Demo (MVP):**

1.  **User Authentication (Epic 1):**
    * User Story 1.1: New user signup.
    * User Story 1.2: Existing user login.
    * User Story 1.4: Basic application shell and navigation.
2.  **Cultural Knowledge Base (Epic 2 - Simplified for MVP):**
    * Focus on backend APIs (User Story 2.2) to serve data for 2-3 pre-populated cultures.
    * The full admin UI (User Story 2.1) can be deferred or be very minimal for initial data population by developers.
3.  **Cultural Briefings (Epic 3):**
    * User Story 3.1: Select a culture.
    * User Story 3.2: View a structured cultural briefing for the demo cultures.
4.  **Real-Time Text Analysis (Epic 4 - Core of Demo):**
    * User Story 4.1: Input text and select target culture.
    * User Story 4.2: Receive AI-generated feedback (for the demo cultures).
    * Focus on a robust backend and AI integration for this feature.
5.  **Idiom Demystifier (Epic 7 - Simplified for MVP):**
    * User Story 7.1 & 7.2: Search and view details for idioms within the demo cultures.
6.  **Basic Settings (Epic 10 - Minimal):**
    * Placeholders for most settings; functional logout (from Epic 1).
7.  **Ethical AI & Privacy (Epic 11 - Foundational):**
    * User Story 11.1: Basic Privacy Policy/ToS display.
    * User Story 11.2: Basic consent mechanisms for analysis.
8.  **Deployment for Demo (Epic 12 - Essential Components):**
    * User Story 12.2: Backend deployment.
    * User Story 12.3: Basic logging/monitoring for the demo.
    * (Frontend deployment is implicit in client tasks for the app shell).

**Features to Defer or Heavily Simplify for Initial Live Demo:**

* Full CKB Admin UI (User Story 2.1)
* Speech Analysis (Epic 5)
* Image Analysis (Epic 6)
* Full Scenario Simulator (Epic 8) - Can be a "coming soon" feature or a single, very polished scenario.
* Personalized Alert & Reminder System (Epic 9)
* Advanced Settings & Full User Management (most of Epic 10 beyond basics)
* Full App Store Submission tasks (User Story 12.4) - Focus on web-accessible demo or ad-hoc mobile builds.

This MVP strategy will guide the prioritization of tasks below to ensure a demonstrable product can be achieved efficiently.

### Target Platforms (for the AI Application)

* **Mobile:** iOS and Android (primary focus, cross-platform development preferred).
* **Web:** Potential for an admin interface for knowledge base management (secondary).

### Key Legend (for the AI Application Plan)

* **[ ]**: Task not yet started.
* **AI Integration Point**: Denotes a task where the core AI model/service for cultural analysis will be called or is a prerequisite.
* **AI Model Task**: Denotes a task specifically for the development, training, or refinement of an AI model component.

---

### Epic 1: Core Application Framework & User Management (AI App)

**Goal:** Establish the basic application structure, navigation, and user authentication for the AI app.

**User Story 1.1: As a new user, I want to be able to sign up for an account so that I can save my preferences and access personalized features.**
* [x] Design UI: Sign-up screen with fields for email, password, and confirm password.
* [x] Design UI: Visual feedback for password strength requirements.
* [x] Implement Client: Sign-up form component.
* [x] Implement Client: Input validation for email format.
* [x] Implement Client: Input validation for password (e.g., min length, complexity).
* [x] Implement Client: Input validation for matching passwords.
* [x] Implement Client: API call to backend for registration.
* [x] Implement Client: Handling of successful registration response (e.g., navigate to login or home).
* [x] Implement Client: Handling of registration error responses (e.g., display error messages).
* [x] Implement Backend: API endpoint (`POST /auth/signup`).
* [x] Implement Backend: Validation of incoming registration data (email format, password presence).
* [x] Implement Backend: Check if email already exists in the database.
* [x] Implement Backend: Secure password hashing (e.g., bcrypt, Argon2).
* [x] Implement Backend: Store new user record in the database (UserID, email, hashed_password, created_at).
* [x] Implement Backend: Return appropriate success or error responses.
* [x] Define Database: `Users` table schema.
* [x] Task: Implement placeholder for email verification process (e.g., log "verification email sent" - full email service deferred for MVP).

**User Story 1.2: As an existing user, I want to be able to log in to my account so that I can access my saved data and personalized features.**
* [x] Design UI: Login screen with fields for email and password.
* [x] Design UI: "Forgot Password?" link (functionality deferred for MVP).
* [x] Implement Client: Login form component.
* [x] Implement Client: Input validation for email and password fields.
* [x] Implement Client: API call to backend for authentication.
* [x] Implement Client: Securely store authentication token (e.g., JWT) upon successful login.
* [x] Implement Client: Handling of successful login response (e.g., navigate to home screen).
* [x] Implement Client: Handling of login error responses (e.g., display "Invalid credentials").
* [x] Implement Backend: API endpoint (`POST /auth/login`).
* [x] Implement Backend: Validation of incoming login data.
* [x] Implement Backend: Retrieve user by email from the database.
* [x] Implement Backend: Compare provided password with stored hashed password.
* [x] Implement Backend: Generate and return JWT (or session token) upon successful authentication.
* [x] Implement Backend: Return appropriate success or error responses for login attempts.
* [x] Task: Implement basic rate limiting for login attempts to prevent brute-force attacks.

**User Story 1.3: As a logged-in user, I want to be able to log out of my account so that my session is terminated.**
* [x] Design UI: Logout button/option (e.g., in settings or profile menu).
* [x] Implement Client: Logic to clear stored authentication token.
* [x] Implement Client: Navigate user to login screen upon logout.
* [x] Implement Backend: API endpoint (`POST /auth/logout`) for server-side session invalidation (if using session IDs or token blocklist).
* [x] Implement Backend: Add token to a blocklist if using JWTs and immediate server-side invalidation is required (optional for MVP).

**User Story 1.4: As a developer, I want a basic mobile application shell (iOS and Android) with core navigation so that features can be built upon it.**
* [x] Setup: Initialize cross-platform project (e.g., React Native with Expo, or Flutter).
* [x] Implement Client: Basic tab-based or drawer-based navigation structure.
    * [x] Implement Client: Placeholder screen for "Home".
    * [x] Implement Client: Placeholder screen for "Cultural Briefings".
    * [x] Implement Client: Placeholder screen for "Real-Time Analysis".
    * [x] Implement Client: Placeholder screen for "Scenario Simulator" (can be "Coming Soon" for MVP).
    * [x] Implement Client: Placeholder screen for "Idiom Demystifier".
    * [x] Implement Client: Placeholder screen for "Settings".
* [x] Implement Client: Basic app styling (theme colors, primary font).
* [x] Implement Client: Routing logic between placeholder screens.
* [x] Implement Client: Protected routes that require authentication to access.

---

### Epic 2: Cultural Knowledge Base (CKB) Management (AI App)

**Goal:** Create and manage the repository of cultural information that powers the AI app. (For MVP, focus on developer-populated data for 2-3 cultures).

**User Story 2.1: As an administrator/developer, I need a system to input, structure, and manage diverse cultural data.**
* [x] Define Database: `Cultures` table schema (CultureID PK, CultureName, Region, PrimaryLanguage, Description, LastUpdated).
* [x] Define Database: `CulturalNorms` table schema (NormID PK, CultureID FK, Category [e.g., Greeting, Dining, Business, Gesture, SensitiveTopic], SubCategory, Description, DoBehavior, DontBehavior, Explanation, SeverityLevel, LastUpdated).
* [x] Define Database: `Idioms` table schema (IdiomID PK, CultureID FK, Language, Phrase, LiteralTranslation, Meaning, UsageExamples, ContextNotes, PolitenessLevel, LastUpdated).
* [x] Define Database: `Scenarios` table schema (ScenarioID PK, CultureID FK, Category, Title, SituationDescription, ImageURL_optional, LastUpdated).
* [x] Define Database: `ScenarioChoices` table schema (ChoiceID PK, ScenarioID FK, ChoiceText, IsCorrectChoice, FeedbackText, ConsequenceDescription).
* [x] Define Database: `UserPreferences` table schema (PreferenceID PK, UserID FK, CultureID FK, NormID FK, ReminderEnabled BOOLEAN).
* [x] Setup: Choose database system (e.g., PostgreSQL, MySQL, MongoDB).
* [x] Implement Backend: CRUD API endpoints for `Cultures` (MVP: ensure GET exists for app).
    * [x] Implement Backend: `POST /admin/cultures` (Create) (Lower priority for MVP if manually populating)
    * [x] Implement Backend: `GET /admin/cultures` (Read List) (MVP: ensure non-admin GET /cultures exists)
    * [x] Implement Backend: `GET /admin/cultures/{id}` (Read One)
    * [x] Implement Backend: `PUT /admin/cultures/{id}` (Update) (Lower priority for MVP)
    * [x] Implement Backend: `DELETE /admin/cultures/{id}` (Delete) (Lower priority for MVP)
* [x] Implement Backend: CRUD API endpoints for `CulturalNorms` (scoped by CultureID) (MVP: ensure GET exists for app).
* [x] Implement Backend: CRUD API endpoints for `Idioms` (scoped by CultureID) (MVP: ensure GET exists for app).
* [x] Implement Backend: CRUD API endpoints for `Scenarios` and `ScenarioChoices` (scoped by CultureID) (Lower priority for MVP).
* [ ] Design UI (Admin): Simple web interface for CKB data entry and management (Defer full UI for post-MVP; use scripts or direct DB access for initial MVP data).
    * [ ] Implement UI (Admin): Form for adding/editing `Cultures` (Defer for post-MVP).
    * [ ] Implement UI (Admin): Form for adding/editing `CulturalNorms` (Defer for post-MVP).
    * [ ] Implement UI (Admin): Form for adding/editing `Idioms` (Defer for post-MVP).
    * [ ] Implement UI (Admin): Form for adding/editing `Scenarios` (Defer for post-MVP).
* [ ] Implement Backend: Secure admin interface/API endpoints (Defer for post-MVP if no admin UI).
* [ ] Task: Develop data validation rules for all CKB inputs on the backend (Essential for data integrity).
* [ ] Task: Plan for versioning or audit trails for CKB entries (Post-MVP).
* [x] Task: Populate initial CKB with data for 2-3 diverse cultures for MVP testing and demo. (CRITICAL for MVP)

**User Story 2.2: As the application, I need efficient and structured access to the CKB to serve user requests.** (CRITICAL for MVP)
* [x] Implement Backend: API endpoint (`GET /cultures`) to list all available cultures for user selection.
* [x] Implement Backend: API endpoint (`GET /cultures/{cultureId}/briefing`) to fetch all relevant `CulturalNorms` for a full briefing.
* [x] Implement Backend: API endpoint (`GET /cultures/{cultureId}/idioms?search={query}`) to search idioms for a culture.
* [x] Implement Backend: API endpoint (`GET /cultures/{cultureId}/idioms/{idiomId}`) to fetch specific idiom details.
* [x] Implement Backend: API endpoint (`GET /cultures/{cultureId}/scenarios?category={category}`) to list scenarios (Lower priority for MVP if scenarios deferred).
* [x] Implement Backend: API endpoint (`GET /scenarios/{scenarioId}`) to fetch scenario details including choices (Lower priority for MVP).
* [x] Implement Backend: API endpoint (`POST /scenarios/{scenarioId}/submit`) to evaluate a user's choice for a scenario (Lower priority for MVP).
* [x] Task: Implement database indexing on frequently queried CKB fields (CultureID, Category, search terms).
* [x] Task: Implement caching strategy for CKB data (e.g., Redis) to improve performance for common requests (Consider for MVP if performance is an issue).

---

### Epic 3: Pre-Travel/Pre-Interaction Cultural Briefings (AI App)

**Goal:** Allow users to learn about a culture's general norms and etiquette. (CRITICAL for MVP)

**User Story 3.1: As a user, I want to select a country/culture to get a detailed briefing.**
* [x] Design UI: Screen for selecting a culture (e.g., searchable list - start with list for MVP).
* [x] Implement Client: Fetch list of available cultures from `GET /cultures` endpoint.
* [x] Implement Client: Display list of cultures in a user-friendly way (e.g., sort alphabetically).
* [x] Implement Client: Allow user to tap/select a culture to view its briefing.
* [x] Implement Client: Store the currently selected culture in app state.

**User Story 3.2: As a user, I want to view a structured cultural briefing covering various topics (greetings, dining, business, etc.) for my selected culture.**
* [x] Design UI: Briefing screen with clear sections for different cultural categories (e.g., using tabs, accordions, or a scrollable list of cards).
* [x] Implement Client: When a culture is selected, fetch its detailed briefing data from `GET /cultures/{cultureId}/briefing`.
* [x] Implement Client: Dynamically render briefing content based on fetched data, organized by `CulturalNorms.Category`.
    * [x] Implement Client: Display "Greetings" norms.
    * [x] Implement Client: Display "Dining Etiquette" norms.
    * [x] Implement Client: Display "Business Protocols" norms.
    * [x] Implement Client: Display "Gestures (Do's and Don'ts)" norms.
    * [x] Implement Client: Display "Sensitive Topics to Avoid" norms.
    * [x] Implement Client: Display other relevant categories from CKB for demo cultures.
* [x] Implement Client: Ensure text is well-formatted, readable, and supports rich text if applicable (e.g., bolding, bullet points from CKB).
* [x] Implement Client: Display "Last Updated" timestamp for the briefing content.
* [x] Design UI: Visual cues for "Do" vs. "Don't" behaviors (e.g., icons, color coding).
* [x] Implement Client: Handle cases where specific information for a sub-section is not available.
* [x] Design UI: "Save for Offline Access" button (placeholder, functionality deferred for MVP).
* [x] Design UI: "Set Reminder for this Norm" button next to specific norms (functionality deferred for MVP, links to Epic 9).

---

### Epic 4: Real-Time Interaction Analysis - Text/Chat (AI App)

**Goal:** Provide users with AI-driven feedback on their text-based communications in a cross-cultural context. (CRITICAL for MVP - Core Demo Feature)

**User Story 4.1: As a user, I want to input text (my own or from others) and select a target culture for analysis.**
* [x] Design UI: Screen for text analysis with a multi-line text input area.
* [x] Design UI: Dropdown or selector to choose the target culture for analysis (pre-fill with last selected culture if any, from demo cultures).
* [x] Design UI: Option (e.g., toggle, radio buttons) to specify if the text is "My Text" (for proactive advice) or "Their Text" (for interpretation aid).
* [x] Implement Client: Component for text input and culture/origin selection.
* [x] Implement Client: "Analyze Text" button.
* [x] Implement Client: On "Analyze Text" click, send text, target culture ID, and text origin to backend.

**User Story 4.2: As a user, I want to receive AI-generated feedback highlighting potential cultural missteps, problematic tone, confusing idioms, or offering alternative phrasing.**
* [x] Design UI: Display area for AI feedback. This could involve:
    * [x] Design UI: Highlighting specific phrases in the original text.
    * [x] Design UI: Annotations or pop-ups next to highlighted text.
    * [x] Design UI: A summary section for overall feedback and suggestions.
    * [x] Design UI: Clear distinction between identified issues and suggested improvements.
* [x] Implement Backend: API endpoint (`POST /analysis/text`) to receive text, culture ID, and origin.
* [x] **AI Integration Point (Backend):** (CRITICAL for MVP)
    * [x] Task: Pre-process input text (cleaning, tokenization).
    * [x] Task for AI Model: Call sentiment/tone analysis model, calibrated for the target demo culture(s).
    * [x] Task for AI Model: Call idiom detection model for the target demo culture(s).
    * [x] Task for AI Model: Call cultural misstep detection model for the target demo culture(s).
    * [x] Task for AI Model: Call alternative phrasing suggestion model for the target demo culture(s).
    * [x] Task: Consolidate results from various AI model components. (Focus on clear, actionable feedback for MVP).
* [x] Implement Backend: Format AI analysis results into a structured JSON response for the client. Include identified issues (type, location in text, severity, explanation) and suggestions.
* [x] Implement Client: Parse AI feedback from backend.
* [x] Implement Client: Render AI feedback in the designed UI, linking annotations to text.
* [x] Implement Client: If an idiom is identified, provide a link/button to view its details in the Idiom Demystifier.
* [x] Design UI: Loading indicator while analysis is in progress.
* [x] Implement Client: Display loading indicator.
* [x] Design UI: Error message display if analysis fails or returns no specific insights.
* [x] Implement Client: Handle error responses from the analysis API.
* [x] Task: Ensure feedback is constructive, educational, and avoids overly prescriptive language.

**User Story 4.3: As a user, I want the text analysis to be reasonably fast for near real-time feedback.**
* [x] Task (Backend/AI): Optimize AI model inference times for demo cultures.
* [x] Task (Backend): Optimize backend processing logic for text analysis.
* [x] Task (Backend): Aim for synchronous processing for typical chat snippets for MVP.

---

### Epic 5: Real-Time Interaction Analysis - Speech (MVP/Future - AI App)

**Goal:** Lay groundwork for speech analysis; full analysis is complex and likely post-MVP. (Defer for MVP)

**User Story 5.1 (MVP Groundwork): As a user, I want to record a short audio snippet, have it transcribed, and see the transcription.** (Defer for MVP)
* [ ] Design UI: Screen for speech input with a "Record Audio" button. (Defer)
* [ ] Design UI: Visual feedback for recording state (e.g., timer, pulsing icon). (Defer)
* [ ] Design UI: "Stop Recording" button. (Defer)
* [ ] Design UI: Audio playback controls for the recorded snippet. (Defer)
* [ ] Design UI: "Transcribe Audio" button. (Defer)
* [ ] Implement Client: Request microphone permissions from the user. (Defer)
* [ ] Implement Client: Logic to start and stop audio recording using device microphone. (Defer)
* [ ] Implement Client: Store recorded audio locally (e.g., temporary WAV or M4A file). (Defer)
* [ ] Implement Client: Allow playback of the recorded audio. (Defer)
* [ ] Implement Client: On "Transcribe Audio" click, send audio file to backend. (Defer)
* [ ] Implement Backend: API endpoint (`POST /analysis/speech/transcribe`) to receive audio file. (Defer)
* [ ] **AI Integration Point (Backend):** Call a third-party Speech-to-Text service. (Defer)
    * [ ] Task: Configure STT service with appropriate language codes. (Defer)
* [ ] Implement Backend: Return transcribed text to the client. (Defer)
* [ ] Implement Client: Display the transcribed text. (Defer)
* [ ] Design UI: Loading indicator during transcription. (Defer)
* [ ] Implement Client: Handle errors from transcription service. (Defer)
* [ ] Task: *Cultural analysis of transcribed speech is deferred for post-MVP.*

---

### Epic 6: Real-Time Interaction Analysis - Image/Scene (Future - Placeholder - AI App)

**Goal:** Explore future capabilities for image-based cultural context. (Defer for MVP)

**User Story 6.1 (Placeholder): As a user, I want a placeholder to understand that image-based cultural analysis is a future feature.**
* [x] Design UI: A section or button labeled "Image Analysis (Coming Soon)" or similar.
* [x] Implement Client: Basic UI element that, when interacted with, shows a message about future availability.
* [x] *No backend or AI work for this in MVP.*

---

### Epic 7: Idiom & Slang Demystifier (AI App)

**Goal:** Help users understand culturally specific idioms and slang. (Include for MVP for demo cultures)

**User Story 7.1: As a user, I want to search for idioms/slang for a selected culture and view a list of results.**
* [x] Design UI: Screen for Idiom Demystifier with a search bar and a culture selector (defaults to current app culture context, show demo cultures).
* [x] Implement Client: Input field for search query.
* [x] Implement Client: Culture selector component.
* [x] Implement Client: On search, call backend API `GET /cultures/{cultureId}/idioms?search={query}`.
* [x] Implement Client: Display list of matching idioms (e.g., idiom phrase and brief meaning).
* [x] Implement Client: Handle "no results found" state.
* [x] Implement Client: Allow tapping on an idiom from the list to see details.

**User Story 7.2: As a user, I want to view detailed explanations for a selected idiom, including meaning, usage examples, and cultural context.**
* [x] Design UI: Detail screen for a single idiom.
* [x] Implement Client: On selecting an idiom, fetch its full details from `GET /cultures/{cultureId}/idioms/{idiomId}`.
* [x] Implement Client: Display idiom phrase.
* [x] Implement Client: Display literal translation (if available).
* [x] Implement Client: Display actual meaning.
* [x] Implement Client: Display usage examples.
* [x] Implement Client: Display context notes (e.g., formality, when to use/avoid).
* [x] Implement Client: Display politeness level.
* [x] Implement Client: Display "Last Updated" for the idiom data.
* [x] Design UI: "Save this Idiom" button (placeholder, functionality deferred for MVP).

---

### Epic 8: "Do's and Don'ts" Simulator/Scenario Trainer (AI App)

**Goal:** Allow users to practice navigating cultural situations in a safe, simulated environment. (Defer for MVP, or one very simple scenario)

**User Story 8.1: As a user, I want to select a culture and scenario category (e.g., dining, business) to start a simulation.** (Defer or simplify to one scenario for MVP)
* [ ] Design UI: Scenario Simulator home screen. (Defer/Simplify)
* [ ] Design UI: Culture selector for the simulation. (Defer/Simplify)
* [ ] Design UI: Scenario category selector. (Defer/Simplify)
* [ ] Implement Client: Fetch available scenario categories. (Defer/Simplify)
* [ ] Implement Client: On selecting culture and category, fetch list of relevant scenarios. (Defer/Simplify)
* [ ] Implement Client: Display list of available scenarios. (Defer/Simplify)
* [ ] Implement Client: Allow user to select a scenario to start. (Defer/Simplify)

**User Story 8.2: As a user, I want to be presented with a cultural scenario description and multiple-choice options for how to respond.** (Defer or simplify for MVP)
* [ ] Design UI: Scenario presentation screen. (Defer/Simplify)
* [ ] Implement Client: On starting a scenario, fetch its full details. (Defer/Simplify)
* [ ] Implement Client: Display scenario situation description clearly. (Defer/Simplify)
* [ ] Implement Client: Display image associated with scenario, if available. (Defer/Simplify)
* [ ] Implement Client: Display multiple-choice response options. (Defer/Simplify)
* [ ] Implement Client: Capture user's selected choice. (Defer/Simplify)

**User Story 8.3: As a user, after choosing an option, I want to receive immediate feedback explaining the cultural implications of my choice and see the correct/most appropriate actions.** (Defer or simplify for MVP)
* [ ] Design UI: Feedback display after a choice is made. (Defer/Simplify)
* [ ] Implement Client: On submitting a choice, send ScenarioID and ChoiceID to backend. (Defer/Simplify)
* [ ] Implement Client: Receive and display feedback from the backend. (Defer/Simplify)
* [ ] Implement Client: Clearly indicate if the chosen option was appropriate, neutral, or inappropriate. (Defer/Simplify)
* [ ] Implement Client: Provide explanations for why the choice had certain cultural implications. (Defer/Simplify)
* [ ] Design UI: Option to "Try Again" or "Next Scenario". (Defer/Simplify)
* [ ] Implement Client: Logic for proceeding or restarting. (Defer/Simplify)
* [ ] Task (Backend): Ensure `ScenarioChoices` in CKB contains rich feedback (Only if including a scenario in MVP).
* [ ] Task (Optional): Implement scoring or progress tracking (Defer for MVP).

---

### Epic 9: Personalized Alert & Reminder System (AI App)

**Goal:** Provide users with timely, context-specific cultural reminders based on their preferences. (Defer for MVP)

**User Story 9.1: As a user, I want to be able to mark specific cultural norms (from briefings) or topics for which I'd like to receive reminders when that culture is active in the app.** (Defer for MVP)
* [ ] Design UI: Mechanism to "set reminder" for a specific norm. (Defer)
* [ ] Implement Client: When a user sets a reminder, store this preference. (Defer)
* [ ] Implement Client: API call to backend to save user's reminder preferences. (Defer)
* [ ] Implement Backend: API endpoint to save/update `UserPreferences` for reminders. (Defer)
* [ ] Design UI: A section in "Settings" to view and manage all active reminders. (Defer)
* [ ] Implement Client: List active reminders in settings. (Defer)

**User Story 9.2: As a user, when I engage with a feature related to a culture for which I have active reminders, I want to see a gentle, non-intrusive notification of those reminders.** (Defer for MVP)
* [ ] Implement Client: Logic to check for active reminders. (Defer)
* [ ] Design UI: Non-intrusive reminder display. (Defer)
* [ ] Implement Client: Display relevant reminder text. (Defer)
* [ ] Implement Client: Allow dismissal of the current reminder display. (Defer)
* [ ] Task: Ensure reminders are specific to the active cultural context. (Defer)

---

### Epic 10: Settings & Personalization (AI App)

**Goal:** Allow users to customize their app experience and manage their account. (Minimal for MVP)

**User Story 10.1: As a user, I want a dedicated settings screen to manage my account, app preferences, and access information.**
* [x] Design UI: Main Settings screen with navigation to sub-sections.
* [x] Implement Client: Settings screen component.
* [x] Implement Client: Navigation links to:
    * [x] Account Management (Logout - from Epic 1. Change Password - placeholder for MVP, Delete Account - placeholder for MVP).
    * [x] Notification Preferences (placeholder for MVP).
    * [x] App Language Selection (placeholder for MVP, default to English).
    * [x] Appearance (Light/Dark Mode) (placeholder for MVP, default to light/system).
    * [x] Data & Privacy (link to Privacy Policy - from Epic 11).
    * [x] About (App Version, Credits, Feedback Link - placeholder, Terms of Service Link - from Epic 11).

**User Story 10.2: As a user, I want to select the display language for the app's interface (e.g., English, Spanish).** (Defer for MVP, default to English)
* [ ] Setup: Integrate an internationalization (i18n) library. (Defer)
* [ ] Task: Create translation files for UI strings for English. (Defer)
* [ ] Task: Create translation files for UI strings for at least one other language. (Defer)
* [ ] Design UI: Language selection dropdown/list in Settings. (Defer)
* [ ] Implement Client: Logic to load and apply the selected language pack. (Defer)
* [ ] Implement Client: Store user's language preference. (Defer)
* [ ] Implement Backend: Store user's language preference in `Users` table if syncing. (Defer)

**User Story 10.3: As a user, I want to switch between light and dark themes for the app's appearance.** (Defer for MVP, default to one theme or system theme)
* [ ] Design UI: Define color palettes for light theme. (Defer)
* [ ] Design UI: Define color palettes for dark theme. (Defer)
* [ ] Implement Client: Theme switching logic. (Defer)
* [ ] Design UI: Toggle switch for Light/Dark mode in Settings -> Appearance. (Defer)
* [ ] Implement Client: Apply selected theme globally across the app. (Defer)
* [ ] Implement Client: Store user's theme preference. (Defer)
* [ ] Implement Backend: Store user's theme preference in `Users` table if syncing. (Defer)

---

### Epic 11: Ethical AI & Privacy Implementation (AI App)

**Goal:** Ensure the AI app is built and operates ethically, respecting user privacy and minimizing bias. (Foundational for MVP)

**User Story 11.1: As a user, I want to be clearly informed about data collection and usage via an accessible Privacy Policy and Terms of Service.**
* [x] Task: Draft a comprehensive Privacy Policy (MVP: simplified version focusing on demo features).
* [x] Task: Draft Terms of Service (MVP: simplified version).
* [x] Design UI: Screens to display Privacy Policy and Terms of Service (accessible from Settings and during onboarding).
* [x] Implement Client: Static display of these legal documents.
* [x] Task: Ensure Privacy Policy clearly states what data is collected for MVP features, how it's used, stored, and for how long.

**User Story 11.2: As a user, I want my data handled securely, and I want control over consent for analysis and data usage for AI improvement.**
* [x] Implement Client: Clear, explicit consent request before submitting text for analysis for the first time, explaining its purpose (CRITICAL for MVP).
* [x] Implement Client: Option during consent (or in settings) to opt-in/out of allowing anonymized data to be used for improving AI models (MVP: Can be a simple statement, full toggle deferred).
* [x] Implement Backend: Ensure all client-server communication uses HTTPS.
* [x] Implement Backend: Encryption at rest for sensitive user-generated content if stored (MVP: aim for transient processing of analyzed text).
* [x] Implement Backend: If data is used for AI training, implement robust anonymization/de-identification pipelines (Post-MVP focus, for MVP ensure no PII is logged from analysis).
* [x] Design UI (Settings): Section for "Data & Privacy" where users can review their consent choices (MVP: Link to policy).
* [x] Task: Implement data retention policies (MVP: Analyzed text snippets are not stored beyond the session, or for a very short debug period).
* [x] Task: Placeholder for "Request Data Deletion" and "Request Data Export" (manual fulfillment initially, post-MVP).

**User Story 11.3: As a developer and user, I want the AI to minimize bias and avoid promoting harmful stereotypes, with a way to report issues.**
* [x] **AI Model Task:** During CKB population and AI model development for demo cultures, actively curate diverse and representative data.
* [x] **AI Model Task:** Implement techniques to detect and mitigate bias in AI models for demo cultures (ongoing process).
* [x] Task: Design AI feedback to be nuanced, use cautious language, and emphasize that cultural norms are general tendencies, not absolute rules for individuals. Include disclaimers in the UI.
* [x] Design UI: A "Report Issue" or "Feedback on Analysis" button associated with AI-generated feedback (MVP: Simple email link for feedback).
* [x] Implement Client: Form for users to submit feedback/reports (MVP: Email link).
* [x] Implement Backend: API endpoint to receive user feedback/reports (MVP: Manual collection via email).
* [x] Task: Establish a review process for user-reported issues to refine CKB and AI models (Post-MVP for systematic process).

---

### Epic 12: Deployment & Monitoring (AI App)

**Goal:** Prepare the AI application for release and ongoing maintenance. (Essential components for Live Demo)

**User Story 12.1: As a developer, I want a CI/CD pipeline for automated builds, tests, and deployments.** (Simplified for MVP demo - manual/scripted deployment acceptable)
* [x] Setup: Choose and configure CI/CD platform (Defer full CI/CD for post-MVP).
* [x] Task: Create build scripts for iOS (MVP: for local/ad-hoc demo builds).
* [x] Task: Create build scripts for Android (MVP: for local/ad-hoc demo builds).
* [x] Task: Create deployment scripts for the backend application (MVP: to chosen cloud environment).
* [x] Task: Integrate automated unit tests (Highly recommended even for MVP, but scale can be limited).
* [x] Task: Integrate basic automated integration tests (Defer for post-MVP).

**User Story 12.2: As a developer, I want to deploy the backend to a scalable cloud environment.** (CRITICAL for Live Demo)
* [x] Setup: Choose cloud provider and services (e.g., Heroku, AWS Amplify, Firebase, or simple VPS for demo).
* [x] Setup: Configure production-like database instance for demo cultures.
* [x] Setup: Configure load balancing if applicable (Likely not needed for initial demo).
* [x] Setup: Configure environment variables for demo deployment (API keys, database credentials).

**User Story 12.3: As a developer, I want robust logging and error monitoring for the entire application.** (Basic logging for Live Demo)
* [ ] Implement Backend: Integrate a logging library.
* [ ] Implement Backend: Implement structured logging for important events, errors, and API requests for demo features.
* [ ] Implement Client: Integrate a client-side error tracking service (Optional for MVP demo, but useful).
* [ ] Setup: Centralized logging and monitoring platform (Optional for MVP demo, console logs might suffice).
* [ ] Setup: Alerts for critical errors (Optional for MVP demo).

**User Story 12.4: As a developer, I want to prepare the mobile app for app store submission.**
* [ ] **Note:** *These tasks are generally post-MVP/Live Demo. Ignore unless specifically given permission to complete these tasks for an app store release.*
* [ ] Task: Create Apple Developer Program account.
* [ ] Task: Create Google Play Console developer account.
* [ ] Task: Generate necessary app signing certificates and provisioning profiles.
* [ ] Task: Prepare app store listing materials:
    * [ ] App Name
    * [ ] Subtitle/Short Description
    * [ ] Full Description
    * [ ] Keywords
    * [ ] App Icons (various sizes)
    * [ ] Screenshots (for different device sizes)
    * [ ] Feature Graphic (Google Play)
    * [ ] Privacy Policy URL
    * [ ] Support URL/Email
* [ ] Task: Configure app for beta testing (e.g., TestFlight for iOS, Google Play Internal/Closed Testing).
* [ ] Task: Ensure compliance with all relevant Apple App Store Review Guidelines.
* [ ] Task: Ensure compliance with all relevant Google Play Developer Policies.

---
---

## Part 2: Project Plan - Mobile Web Refinement for HTML Project Document

### Overview (HTML Document Refinement)

This section outlines the user stories and tasks required to enhance the mobile responsiveness and readability of the existing HTML-based project plan document (Part 1 of this combined document, when rendered as HTML). The goal is to ensure the HTML document itself provides an optimal viewing experience on mobile devices as a static webpage.

### Target Document (for Refinement)

* The HTML document version of "Part 1: Project Plan - AI-Powered 'Cultural Nuance Navigator' Application".

### Key Legend (for HTML Document Refinement Plan)

* **[ ]**: Task not yet started. Each task is considered a 1-point effort.

---

### Meta-Epic 1: Foundational Mobile Responsiveness for Project Plan HTML Document

**Goal:** Ensure the HTML project plan document has the basic structure for correct scaling and layout on mobile devices.

**Meta-User Story 1.1: As a reader, I want the project plan HTML document to include a viewport meta tag so it scales correctly on mobile devices.**
* [ ] Task: Verify or add `<meta name="viewport" content="width=device-width, initial-scale=1.0">` to the `<head>` of the HTML document.

**Meta-User Story 1.2: As a reader, I want the main content of the project plan HTML document to be appropriately constrained and centered for readability on various screen sizes.**
* [ ] Task: Confirm the main content container (e.g., `div.max-w-4xl.mx-auto`) effectively uses Tailwind CSS classes like `max-w-*` and `mx-auto` for responsive centering and width limitation.
* [ ] Task: Verify that padding on the main container (e.g., `p-2 sm:p-4 md:p-6`) adapts suitably across different screen sizes, ensuring content isn't too close to screen edges on mobile.

---

### Meta-Epic 2: Responsive Typography & Spacing for Project Plan HTML Document

**Goal:** Optimize text elements and spacing within the HTML project plan document for clarity and readability on mobile screens.

**Meta-User Story 2.1: As a reader, I want headings (H1, H2, H3) in the project plan HTML document to use responsive font sizes, ensuring they are prominent yet well-proportioned on mobile.**
* [ ] Task: Review H1 styling (e.g., `text-3xl sm:text-4xl`) and adjust Tailwind classes if necessary for optimal mobile display.
* [ ] Task: Review H2 styling (e.g., `text-2xl sm:text-3xl` for Epics, `text-xl sm:text-2xl` for other sections) and adjust Tailwind classes if needed for mobile.
* [ ] Task: Review H3 styling (e.g., `text-lg sm:text-xl` for User Stories) and adjust Tailwind classes if needed for mobile.

**Meta-User Story 2.2: As a reader, I want paragraph text and list items in the project plan HTML document to maintain readable font sizes and line heights on mobile devices.**
* [ ] Task: Confirm the base text size (e.g., `text-sm sm:text-base` via Tailwind) is suitable for comfortable reading on mobile screens.
* [ ] Task: Verify that line height (e.g., `leading-relaxed`) contributes to good readability for blocks of text on mobile.

**Meta-User Story 2.3: As a reader, I want margins and padding around sections and elements in the project plan HTML document to be adjusted for mobile, preventing overly cramped or excessively sparse layouts.**
* [ ] Task: Evaluate and adjust `mb-*` (margin-bottom) Tailwind classes for header elements, Epic sections, and User Story blocks to ensure appropriate vertical spacing on mobile.
* [ ] Task: Evaluate and adjust `p-*` (padding) Tailwind classes for container elements (Overview, Platforms, Legend, Epic sections, User Story blocks) for optimal internal spacing on mobile.
* [ ] Task: Review `gap-*` (gap) Tailwind classes in grid layouts (like for Platforms/Legend) to ensure adequate spacing on mobile.

---

### Meta-Epic 3: Responsive Layout for Specific Components in Project Plan HTML Document

**Goal:** Ensure specific UI components within the HTML project plan document adapt their layout effectively on mobile screens.

**Meta-User Story 3.1: As a reader, I want the "Target Platforms" and "Key Legend" sections in the header of the project plan HTML document to stack vertically on small screens if they are displayed side-by-side on larger screens.**
* [ ] Task: Verify that the Tailwind CSS grid classes (e.g., `grid grid-cols-1 md:grid-cols-2`) correctly adapt the layout of these sections, ensuring they stack on screens smaller than the `md` breakpoint.

**Meta-User Story 3.2: As a reader, I want task list items (checkboxes and text) within user stories in the project plan HTML document to be easily readable and visually clear on mobile.**
* [ ] Task: Confirm that the `margin-right` on `input[type="checkbox"]` provides enough separation from the task text on mobile.
* [ ] Task: Check that the vertical spacing between list items (e.g., `space-y-1.5`) is sufficient for mobile readability.
* [ ] Task: Ensure the checkbox size (e.g., `transform: scale(1.1)`) is visually adequate on mobile.

**Meta-User Story 3.3: As a reader, I want the "Epic Goal" informational box within the project plan HTML document to be clearly delineated and its content easily readable on mobile devices.**
* [ ] Task: Review the styling of the `.epic-goal` class (padding, border, background color, font style) to ensure it presents well and is legible on mobile screens.

---

### Meta-Epic 4: General Mobile Usability & Testing for Project Plan HTML Document

**Goal:** Address overall mobile usability aspects and perform testing to confirm the mobile-friendliness of the HTML project plan document.

**Meta-User Story 4.1: As a reader, I want to view the project plan HTML document on mobile devices without encountering any horizontal scrolling.**
* [ ] Task: Thoroughly test the HTML document across various simulated mobile screen widths and on actual devices to identify and rectify any elements causing horizontal overflow.
* [ ] Task: If any images are present or added later, ensure they use responsive Tailwind classes (e.g., `max-w-full h-auto`) to prevent them from breaking the layout.

**Meta-User Story 4.2: As a reader, I want any interactive elements (like links, if present) in the project plan HTML document to be easily tappable on mobile devices.**
* [ ] Task: (If applicable) For any hyperlinks or future interactive elements, ensure they have sufficient padding or an adequate target size to be easily and accurately tapped on touchscreens. (Currently, the document is mostly static).

**Meta-User Story 4.3: As a developer, I want to ensure all custom CSS (if any beyond Tailwind) in the project plan HTML document is reviewed for mobile compatibility.**
* [ ] Task: Review the `<style>` block in the HTML document for any custom CSS rules and ensure they do not conflict with mobile responsiveness or introduce mobile-specific issues.
* [ ] Task: Specifically check the custom scrollbar CSS (`::-webkit-scrollbar`) to ensure it doesn't negatively impact mobile views (though it typically only applies to desktop browsers that support it).

---
</file>

<file path=".gitignore">
# Dependency directories
node_modules/
*/node_modules/

# Environment variables
database.env
.env
*.env

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build directories
dist/
build/
*/dist/
*/build/

# OS specific files
.DS_Store
Thumbs.db

# IDE specific files
.idea/
.vscode/
*.swp
*.swo

# Cache directories
.npm
.eslintcache
</file>

<file path="App.tsx">
// @ts-ignore
import * as React from 'react';
// @ts-ignore
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Cultural AI App</Text>
      <Text style={styles.subtitle}>Welcome to the application!</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#4A6FA5',
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
});
</file>

<file path="create_database.sql">
-- Cultural Nuance Navigator Database Setup Script
-- This script creates the database and all required tables for the application

-- Create database if it doesn't exist
IF NOT EXISTS (SELECT * FROM sys.databases WHERE name = 'CulturalAI')
BEGIN
    CREATE DATABASE CulturalAI;
END
GO

USE CulturalAI;
GO

-- -----------------------------------------------------
-- Table structure for Users
-- -----------------------------------------------------
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Users]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[Users] (
  UserID NVARCHAR(36) PRIMARY KEY,
  Email NVARCHAR(255) NOT NULL UNIQUE,
  HashedPassword NVARCHAR(255) NOT NULL,
  CreatedAt DATETIME2 DEFAULT GETDATE(),
  LastLogin DATETIME2 NULL,
  IsActive BIT DEFAULT 1,
  IsVerified BIT DEFAULT 0,
  VerificationToken NVARCHAR(255) NULL,
  ResetPasswordToken NVARCHAR(255) NULL,
  ResetPasswordExpiry DATETIME2 NULL
);
CREATE INDEX idx_email ON [dbo].[Users](Email);
END
GO

-- -----------------------------------------------------
-- Table structure for Cultures
-- -----------------------------------------------------
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Cultures]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[Cultures] (
  CultureID NVARCHAR(36) PRIMARY KEY,
  CultureName NVARCHAR(100) NOT NULL,
  Region NVARCHAR(100) NOT NULL,
  PrimaryLanguage NVARCHAR(100) NOT NULL,
  Description NVARCHAR(MAX) NOT NULL,
  LastUpdated DATETIME2 DEFAULT GETDATE()
);
CREATE INDEX idx_culture_name ON [dbo].[Cultures](CultureName);
CREATE INDEX idx_region ON [dbo].[Cultures](Region);
END
GO

-- -----------------------------------------------------
-- Table structure for CulturalNorms
-- -----------------------------------------------------
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CulturalNorms]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[CulturalNorms] (
  NormID NVARCHAR(36) PRIMARY KEY,
  CultureID NVARCHAR(36) NOT NULL,
  Category NVARCHAR(50) NOT NULL,
  SubCategory NVARCHAR(100) NULL,
  Description NVARCHAR(MAX) NOT NULL,
  DoBehavior NVARCHAR(MAX) NOT NULL,
  DontBehavior NVARCHAR(MAX) NOT NULL,
  Explanation NVARCHAR(MAX) NOT NULL,
  SeverityLevel NVARCHAR(20) NOT NULL,
  LastUpdated DATETIME2 DEFAULT GETDATE(),
  CONSTRAINT FK_CulturalNorms_Cultures FOREIGN KEY (CultureID) REFERENCES [dbo].[Cultures](CultureID) ON DELETE CASCADE
);
CREATE INDEX idx_culture_category ON [dbo].[CulturalNorms](CultureID, Category);
END
GO

-- -----------------------------------------------------
-- Table structure for Idioms
-- -----------------------------------------------------
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Idioms]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[Idioms] (
  IdiomID NVARCHAR(36) PRIMARY KEY,
  CultureID NVARCHAR(36) NOT NULL,
  Language NVARCHAR(100) NOT NULL,
  Phrase NVARCHAR(MAX) NOT NULL,
  LiteralTranslation NVARCHAR(MAX) NOT NULL,
  Meaning NVARCHAR(MAX) NOT NULL,
  ContextNotes NVARCHAR(MAX) NULL,
  PolitenessLevel NVARCHAR(20) NOT NULL,
  LastUpdated DATETIME2 DEFAULT GETDATE(),
  CONSTRAINT FK_Idioms_Cultures FOREIGN KEY (CultureID) REFERENCES [dbo].[Cultures](CultureID) ON DELETE CASCADE
);
CREATE INDEX idx_culture_idiom ON [dbo].[Idioms](CultureID);
END
GO

-- -----------------------------------------------------
-- Table structure for IdiomUsageExamples
-- -----------------------------------------------------
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IdiomUsageExamples]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[IdiomUsageExamples] (
  ExampleID NVARCHAR(36) PRIMARY KEY,
  IdiomID NVARCHAR(36) NOT NULL,
  ExampleText NVARCHAR(MAX) NOT NULL,
  CONSTRAINT FK_IdiomUsageExamples_Idioms FOREIGN KEY (IdiomID) REFERENCES [dbo].[Idioms](IdiomID) ON DELETE CASCADE
);
END
GO

-- -----------------------------------------------------
-- Table structure for Scenarios
-- -----------------------------------------------------
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Scenarios]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[Scenarios] (
  ScenarioID NVARCHAR(36) PRIMARY KEY,
  CultureID NVARCHAR(36) NOT NULL,
  Category NVARCHAR(100) NOT NULL,
  Title NVARCHAR(255) NOT NULL,
  SituationDescription NVARCHAR(MAX) NOT NULL,
  ImageURL NVARCHAR(255) NULL,
  LastUpdated DATETIME2 DEFAULT GETDATE(),
  CONSTRAINT FK_Scenarios_Cultures FOREIGN KEY (CultureID) REFERENCES [dbo].[Cultures](CultureID) ON DELETE CASCADE
);
CREATE INDEX idx_scenarios_culture_category ON [dbo].[Scenarios](CultureID, Category);
END
GO

-- -----------------------------------------------------
-- Table structure for ScenarioChoices
-- -----------------------------------------------------
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ScenarioChoices]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[ScenarioChoices] (
  ChoiceID NVARCHAR(36) PRIMARY KEY,
  ScenarioID NVARCHAR(36) NOT NULL,
  ChoiceText NVARCHAR(MAX) NOT NULL,
  IsCorrectChoice BIT NOT NULL DEFAULT 0,
  FeedbackText NVARCHAR(MAX) NOT NULL,
  ConsequenceDescription NVARCHAR(MAX) NOT NULL,
  CONSTRAINT FK_ScenarioChoices_Scenarios FOREIGN KEY (ScenarioID) REFERENCES [dbo].[Scenarios](ScenarioID) ON DELETE CASCADE
);
END
GO

-- -----------------------------------------------------
-- Table structure for UserPreferences
-- -----------------------------------------------------
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UserPreferences]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[UserPreferences] (
  PreferenceID NVARCHAR(36) PRIMARY KEY,
  UserID NVARCHAR(36) NOT NULL,
  CultureID NVARCHAR(36) NOT NULL,
  NormID NVARCHAR(36) NULL,
  ReminderEnabled BIT NOT NULL DEFAULT 1,
  CONSTRAINT FK_UserPreferences_Users FOREIGN KEY (UserID) REFERENCES [dbo].[Users](UserID) ON DELETE CASCADE,
  CONSTRAINT FK_UserPreferences_Cultures FOREIGN KEY (CultureID) REFERENCES [dbo].[Cultures](CultureID) ON DELETE NO ACTION,
  CONSTRAINT FK_UserPreferences_CulturalNorms FOREIGN KEY (NormID) REFERENCES [dbo].[CulturalNorms](NormID) ON DELETE SET NULL,
  CONSTRAINT UQ_UserPreferences_UserCultureNorm UNIQUE (UserID, CultureID, NormID)
);
END
GO

-- -----------------------------------------------------
-- Sample data population for demonstration
-- -----------------------------------------------------

-- Sample Cultures
IF NOT EXISTS (SELECT * FROM [dbo].[Cultures] WHERE CultureID = 'jp-001')
BEGIN
    INSERT INTO [dbo].[Cultures] (CultureID, CultureName, Region, PrimaryLanguage, Description, LastUpdated) 
    VALUES ('jp-001', 'Japanese', 'East Asia', 'Japanese', 'Japan has a rich cultural heritage spanning thousands of years, with strong emphasis on politeness, social harmony, and respect for tradition.', '2023-05-01');
END

IF NOT EXISTS (SELECT * FROM [dbo].[Cultures] WHERE CultureID = 'ar-001')
BEGIN
    INSERT INTO [dbo].[Cultures] (CultureID, CultureName, Region, PrimaryLanguage, Description, LastUpdated) 
    VALUES ('ar-001', 'Arabic (Gulf)', 'Middle East', 'Arabic', 'Gulf Arabic cultures value hospitality, respect, family bonds, and religious traditions, with distinct customs around greetings and social interactions.', '2023-05-02');
END

IF NOT EXISTS (SELECT * FROM [dbo].[Cultures] WHERE CultureID = 'br-001')
BEGIN
    INSERT INTO [dbo].[Cultures] (CultureID, CultureName, Region, PrimaryLanguage, Description, LastUpdated) 
    VALUES ('br-001', 'Brazilian', 'South America', 'Portuguese', 'Brazilian culture is known for its warmth, diversity, and rich expressions in music, cuisine, and social gatherings, with relaxed yet specific social norms.', '2023-05-03');
END
GO

-- Sample Cultural Norms for Japanese culture
IF NOT EXISTS (SELECT * FROM [dbo].[CulturalNorms] WHERE NormID = 'jp-norm-001')
BEGIN
    INSERT INTO [dbo].[CulturalNorms] (NormID, CultureID, Category, SubCategory, Description, DoBehavior, DontBehavior, Explanation, SeverityLevel, LastUpdated) 
    VALUES ('jp-norm-001', 'jp-001', 'Greeting', 'Bowing', 'Bowing etiquette in Japan', 'Bow when greeting someone, with the depth of bow reflecting the level of respect.', 'Don''t offer a handshake first, and don''t bow with hands in pockets or while chewing gum.', 'Bowing is an essential part of Japanese culture, showing respect and social status. The deeper and longer the bow, the more respect is shown.', 'High', '2023-05-01');
END
GO

-- Add more sample data as needed following the same pattern...

-- Sample user for testing
IF NOT EXISTS (SELECT * FROM [dbo].[Users] WHERE UserID = 'user-123456789')
BEGIN
    INSERT INTO [dbo].[Users] (UserID, Email, HashedPassword, CreatedAt, IsActive, IsVerified) 
    VALUES ('user-123456789', 'demo@example.com', '$2a$10$jZFb.EZ.lnVN8AfNxaVE/u.1QU5w26RtIRKS815lDHoELZCRh7qEe', '2023-05-01', 1, 1);
END
GO
</file>

<file path="global.d.ts">
declare module 'react';
declare module 'react-native';
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cultural AI - API Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .result {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .status {
            font-weight: bold;
        }
        .status.online {
            color: green;
        }
        .status.offline {
            color: red;
        }
    </style>
</head>
<body>
    <h1>Cultural AI - API Test</h1>
    
    <div>
        <h2>API Status: <span id="apiStatus" class="status">Checking...</span></h2>
        <button id="checkHealth">Check API Health</button>
    </div>

    <div class="result">
        <h3>Response:</h3>
        <pre id="result">No data yet</pre>
    </div>

    <script>
        document.getElementById('checkHealth').addEventListener('click', async () => {
            const resultElement = document.getElementById('result');
            const statusElement = document.getElementById('apiStatus');
            
            try {
                resultElement.textContent = 'Loading...';
                statusElement.textContent = 'Checking...';
                statusElement.className = 'status';
                
                const response = await fetch('http://localhost:3000/api/health');
                const data = await response.json();
                
                resultElement.textContent = JSON.stringify(data, null, 2);
                statusElement.textContent = 'Online';
                statusElement.className = 'status online';
            } catch (error) {
                resultElement.textContent = `Error: ${error.message}`;
                statusElement.textContent = 'Offline';
                statusElement.className = 'status offline';
            }
        });

        // Auto-check on page load
        document.getElementById('checkHealth').click();
    </script>
</body>
</html>
</file>

<file path="index.js">
import { registerRootComponent } from 'expo';
import App from './simple-app';

// Register the app
registerRootComponent(App);
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Emmanuel Lawal

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "culturalai",
  "version": "1.0.0",
  "description": "",
  "main": "test-db.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/emmanuellawal/culturalai.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/emmanuellawal/culturalai/issues"
  },
  "homepage": "https://github.com/emmanuellawal/culturalai#readme",
  "dependencies": {
    "dotenv": "^16.5.0",
    "mssql": "^11.0.1",
    "tedious": "^18.6.1"
  },
  "devDependencies": {
    "typescript": "^5.8.3"
  }
}
</file>

<file path="README.md">
# Cultural AI

A platform that leverages AI to provide cultural insights and recommendations.

## Overview

Cultural AI is a React Native application with a Node.js/Express backend that connects users with culturally relevant content and recommendations. The application uses AI to analyze and understand cultural contexts, providing personalized experiences.

## Features

- Cultural content recommendations
- AI-powered cultural insights
- User authentication and personalization
- SQL Server database integration

## Tech Stack

### Frontend
- React Native
- TypeScript
- StyleSheet for styling

### Backend
- Node.js
- Express
- SQL Server (MSSQL)
- OpenAI integration

### DevOps
- Docker support
- GitHub Actions for CI/CD

## Getting Started

### Prerequisites
- Node.js (v18 or higher)
- SQL Server instance
- Environment variables configured

### Installation

1. Clone the repository:
```
git clone https://github.com/emmanuellawal/culturalai.git
cd culturalai
```

2. Install dependencies:
```
npm install
cd server
npm install
```

3. Set up the database:
```
npm run db:setup
```

4. Start the server:
```
cd server
npm run dev
```

5. Start the client application:
```
npm start
```

## Environment Variables

Create a `database.env` file with the following variables:
- DB_USER
- DB_PASSWORD
- DB_SERVER
- DB_DATABASE
- API_KEY (for OpenAI integration)

## License

This project is licensed under the ISC License - see the LICENSE file for details.

## Contact

For questions or support, please open an issue on the GitHub repository.
</file>

<file path="simple-app.js">
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Cultural AI App</Text>
      <Text style={styles.subtitle}>Welcome to the application!</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#4A6FA5',
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
});
</file>

<file path="test-db.js">
const sql = require('mssql');
const dotenv = require('dotenv');
const path = require('path');
const fs = require('fs');

// Load environment variables from database.env
const dbEnvPath = path.resolve(__dirname, 'database.env');
if (fs.existsSync(dbEnvPath)) {
  console.log('Loading environment variables from database.env');
  dotenv.config({ path: dbEnvPath });
}

// Try multiple connection methods
async function testConnection() {
  // Try connection string first (if defined)
  if (process.env.DB_CONNECTION_STRING) {
    let pool;
    try {
      console.log('Attempt 1: Testing connection with connection string...');
      
      // Mask sensitive info in logs
      const connectionString = process.env.DB_CONNECTION_STRING;
      const maskedString = connectionString.replace(/Password=[^;]+/i, 'Password=*****');
      console.log('Connection string (masked):', maskedString);
      
      pool = await sql.connect(process.env.DB_CONNECTION_STRING);
      await runTests(pool);
      return;
    } catch (error) {
      console.error('Connection string attempt failed:', error.message);
    } finally {
      if (pool) {
        try {
          await pool.close();
        } catch (err) {
          // Ignore close error
        }
      }
    }
  }
  
  // Try Windows Authentication
  const configWindowsAuth = {
    server: process.env.DB_SERVER || 'localhost',
    database: process.env.DB_NAME || 'master',
    options: {
      trustedConnection: true,
      trustServerCertificate: process.env.DB_TRUST_SERVER_CERTIFICATE === 'true',
      encrypt: false
    }
  };
  
  let pool;
  try {
    console.log('\nAttempt 2: Testing with Windows Authentication...');
    console.log('Config:', {
      server: configWindowsAuth.server,
      database: configWindowsAuth.database,
      authentication: 'Windows Authentication'
    });
    
    pool = await sql.connect(configWindowsAuth);
    await runTests(pool);
    return;
  } catch (error) {
    console.error('Windows Authentication failed:', error.message);
  } finally {
    if (pool) {
      try {
        await pool.close();
      } catch (err) {
        // Ignore close error
      }
    }
  }
  
  // If we're still here, try one more approach: connecting to localhost
  const configLocalhost = {
    server: 'localhost',
    database: process.env.DB_NAME || 'master',
    user: process.env.DB_USER || 'sa',
    password: process.env.DB_PASSWORD || '',
    options: {
      trustServerCertificate: true,
      encrypt: false
    }
  };
  
  try {
    console.log('\nAttempt 3: Testing direct localhost connection...');
    console.log('Config:', {
      server: 'localhost',
      database: configLocalhost.database,
      user: configLocalhost.user
    });
    
    pool = await sql.connect(configLocalhost);
    await runTests(pool);
    return;
  } catch (error) {
    console.error('All connection attempts failed.');
    console.error('Last error:', error.message);
    
    console.log('\nTroubleshooting tips for SQL Server connection:');
    console.log('1. Enable SQL Server Authentication (Mixed Mode) in SQL Server Management Studio');
    console.log('2. Enable TCP/IP in SQL Server Configuration Manager');
    console.log('3. Make sure the SA account is enabled with a strong password');
    console.log('4. Configure SQL Server to allow remote connections');
    console.log('5. Open firewall for SQL Server port (usually 1433)');
    console.log('6. Check if SQL Server Browser service is running');
    console.log('7. Restart SQL Server after making these changes');
    console.log('\nTo use SQL Server from WSL2, try these commands in Windows PowerShell to check your SQL Server configuration:');
    console.log('  netstat -a | findstr 1433    (check if SQL Server is listening)');
    console.log('  Get-Service | findstr "SQL Server"   (check if SQL Server is running)');
  } finally {
    if (pool) {
      try {
        await pool.close();
        console.log('Database connection pool closed');
      } catch (err) {
        console.error('Error closing pool:', err.message);
      }
    }
  }
}

async function runTests(pool) {
  // Test query
  const result = await pool.request().query('SELECT @@VERSION as version');
  console.log('Database connection successful!');
  console.log('SQL Server version:', result.recordset[0].version);
  
  // Test if CulturalAI database exists
  try {
    const dbExists = await pool.request().query("SELECT COUNT(*) as count FROM sys.databases WHERE name = 'CulturalAI'");
    const dbCount = dbExists.recordset[0].count;
    
    if (dbCount > 0) {
      console.log('CulturalAI database exists!');
      
      // Check if we can access the Cultures table
      try {
        await pool.request().query("USE CulturalAI");
        const tableExists = await pool.request().query("SELECT COUNT(*) as count FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Cultures'");
        
        if (tableExists.recordset[0].count > 0) {
          console.log('Cultures table exists!');
          const cultures = await pool.request().query('SELECT COUNT(*) as count FROM Cultures');
          console.log('Number of cultures in database:', cultures.recordset[0].count);
        } else {
          console.log('Cultures table does not exist yet. You may need to run your create_database.sql script.');
        }
      } catch (err) {
        console.error('Error accessing CulturalAI tables:', err.message);
      }
    } else {
      console.log('CulturalAI database does not exist yet. You need to run your create_database.sql script.');
    }
  } catch (err) {
    console.error('Error checking database existence:', err.message);
  }
}

// Run the test
testConnection();
</file>

<file path="tsconfig.json">
{
 "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  },
  "include": ["**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules", "culturalai/**/*"]
}
</file>

</files>
